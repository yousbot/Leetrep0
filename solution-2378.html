<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-2378.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-2378.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>2378 - Choose Edges to Maximize Score in a Tree</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 2378. Choose Edges to Maximize Score in a Tree Description You are given a weighted tree consisting of n nodes numbered from 0 to n - 1. The tree is rooted at node 0 and represented with a 2D array edges of size n where...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-2378.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-2378.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-2378.html" rel="stylesheet"/>
   <link href="solution-2378.html" rel="stylesheet"/>
   <link href="solution-2378.html" rel="stylesheet"/>
   <link href="solution-2378.html" rel="stylesheet"/>
   <link href="solution-2378.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="2378 - Choose Edges to Maximize Score in a Tree" property="og:title"/>
   <meta content="Leetcode 2378. Choose Edges to Maximize Score in a Tree Description You are given a weighted tree consisting of n nodes numbered from 0 to n - 1. The tree is rooted at node 0 and represented with a 2D array edges of size n where edges[i] = [pari, weighti] indicates that node pari is the parent of node i, and the edge between them has a weight equal to weighti. Since the root does not have a parent, you have edges[0] = [-1, -1]. Choose some edges from the tree such that no two chosen edges are adjacent and the sum of the weights of the chosen edges is maximized. Return the maximum sum of the chosen edges. Note: You are allowed to not choose any edges in the tree, the sum of weights in this case will be 0. Two edges Edge1 and Edge2 in the tree are adjacent if they have a common node. In other words, they are adjacent if Edge1 connects nodes a and b and Edge2 connects nodes b and c. &amp;nbsp; Example 1: Input: edges = [[-1,-1],[0,5],[0,10],[2,6],[2,4]] Output: 11 Explanation: The above diagram shows the edges that we have to choose colored in red. The total score is 5 + 6 = 11. It can be shown that no better score can be obtained. Example 2: Input: edges = [[-1,-1],[0,5],[0,-6],[0,7]] Output: 7 Explanation: We choose the edge with weight 7. Note that we cannot choose more than one edge because all edges are adjacent to each other. &amp;nbsp; Constraints: n == edges.length 1 &amp;lt;= n &amp;lt;= 105 edges[i].length == 2 par0 == weight0 == -1 0 &amp;lt;= pari &amp;lt;= n - 1 for all i &amp;gt;= 1. pari != i -106 &amp;lt;= weighti &amp;lt;= 106 for all i &amp;gt;= 1. edges represents a valid tree. Solutions Java C++ Python Go class Solution { private List&amp;lt;int[]&amp;gt;[] g; public long maxScore(int[][] edges) { int n = edges.length; g = new List[n]; Arrays.setAll(g, k -&amp;gt; new ArrayList&amp;lt;&amp;gt;()); for (int i = 1; i &amp;lt; n; ++i) { int p = edges[i][0], w = edges[i][1]; g[p].add(new int[] {i, w}); } return dfs(0)[1]; } private long[] dfs(int i) { long a = 0, b = 0, t = 0; for (int[] nxt : g[i]) { int j = nxt[0], w = nxt[1]; long[] s = dfs(j); a += s[1]; b += s[1]; t = Math.max(t, s[0] - s[1] + w); } b += t; return new long[] {a, b}; } } class Solution { public: long long maxScore(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; edges) { int n = edges.size(); vector&amp;lt;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; g(n); for (int i = 1; i &amp;lt; n; ++i) { int p = edges[i][0], w = edges[i][1]; g[p].emplace_back(i, w); } using ll = long long; using pll = pair&amp;lt;ll, ll&amp;gt;; function&amp;lt;pll(int)&amp;gt; dfs = [&amp;amp;](int i) -&amp;gt; pll { ll a = 0, b = 0, t = 0; for (auto&amp;amp; [j, w] : g[i]) { auto [x, y] = dfs(j); a += y; b += y; t..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2022-06-04T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2022-06-04-2378-Choose-Edges-to-Maximize-Score-in-a-Tree/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-2378.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="2378 - Choose Edges to Maximize Score in a Tree" property="twitter:title"/>
   <meta content="Leetcode 2378. Choose Edges to Maximize Score in a Tree Description You are given a weighted tree consisting of n nodes numbered from 0 to n - 1. The tree is rooted at node 0 and represented with a 2D array edges of size n where edges[i] = [pari, weighti] indicates that node pari is the parent of node i, and the edge between them has a weight equal to weighti. Since the root does not have a parent, you have edges[0] = [-1, -1]. Choose some edges from the tree such that no two chosen edges are adjacent and the sum of the weights of the chosen edges is maximized. Return the maximum sum of the chosen edges. Note: You are allowed to not choose any edges in the tree, the sum of weights in this case will be 0. Two edges Edge1 and Edge2 in the tree are adjacent if they have a common node. In other words, they are adjacent if Edge1 connects nodes a and b and Edge2 connects nodes b and c. &amp;nbsp; Example 1: Input: edges = [[-1,-1],[0,5],[0,10],[2,6],[2,4]] Output: 11 Explanation: The above diagram shows the edges that we have to choose colored in red. The total score is 5 + 6 = 11. It can be shown that no better score can be obtained. Example 2: Input: edges = [[-1,-1],[0,5],[0,-6],[0,7]] Output: 7 Explanation: We choose the edge with weight 7. Note that we cannot choose more than one edge because all edges are adjacent to each other. &amp;nbsp; Constraints: n == edges.length 1 &amp;lt;= n &amp;lt;= 105 edges[i].length == 2 par0 == weight0 == -1 0 &amp;lt;= pari &amp;lt;= n - 1 for all i &amp;gt;= 1. pari != i -106 &amp;lt;= weighti &amp;lt;= 106 for all i &amp;gt;= 1. edges represents a valid tree. Solutions Java C++ Python Go class Solution { private List&amp;lt;int[]&amp;gt;[] g; public long maxScore(int[][] edges) { int n = edges.length; g = new List[n]; Arrays.setAll(g, k -&amp;gt; new ArrayList&amp;lt;&amp;gt;()); for (int i = 1; i &amp;lt; n; ++i) { int p = edges[i][0], w = edges[i][1]; g[p].add(new int[] {i, w}); } return dfs(0)[1]; } private long[] dfs(int i) { long a = 0, b = 0, t = 0; for (int[] nxt : g[i]) { int j = nxt[0], w = nxt[1]; long[] s = dfs(j); a += s[1]; b += s[1]; t = Math.max(t, s[0] - s[1] + w); } b += t; return new long[] {a, b}; } } class Solution { public: long long maxScore(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; edges) { int n = edges.size(); vector&amp;lt;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; g(n); for (int i = 1; i &amp;lt; n; ++i) { int p = edges[i][0], w = edges[i][1]; g[p].emplace_back(i, w); } using ll = long long; using pll = pair&amp;lt;ll, ll&amp;gt;; function&amp;lt;pll(int)&amp;gt; dfs = [&amp;amp;](int i) -&amp;gt; pll { ll a = 0, b = 0, t = 0; for (auto&amp;amp; [j, w] : g[i]) { auto [x, y] = dfs(j); a += y; b += y; t..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    2378 - Choose Edges to Maximize Score in a Tree | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="2378 - Choose Edges to Maximize Score in a Tree" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-2378.html" rel="canonical">
          <meta content="https://leetcode.ca/2022-06-04-2378-Choose-Edges-to-Maximize-Score-in-a-Tree/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2022-06-04T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"2378 - Choose Edges to Maximize Score in a Tree","dateModified":"2022-06-04T00:00:00-07:00","datePublished":"2022-06-04T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2022-06-04-2378-Choose-Edges-to-Maximize-Score-in-a-Tree/"},"url":"https://leetcode.ca/2022-06-04-2378-Choose-Edges-to-Maximize-Score-in-a-Tree/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="2378-choose-edges-to-maximize-score-in-a-tree">
       <a href="solution-2378.html">
        2378. Choose Edges to Maximize Score in a Tree
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       You are given a
       <strong>
        weighted
       </strong>
       tree consisting of
       <code>
        n
       </code>
       nodes numbered from
       <code>
        0
       </code>
       to
       <code>
        n - 1
       </code>
       .
      </p>
      <p>
       The tree is
       <strong>
        rooted
       </strong>
       at node
       <code>
        0
       </code>
       and represented with a
       <strong>
        2D
       </strong>
       array
       <code>
        edges
       </code>
       of size
       <code>
        n
       </code>
       where
       <code>
        edges[i] = [par
        <sub>
         i
        </sub>
        , weight
        <sub>
         i
        </sub>
        ]
       </code>
       indicates that node
       <code>
        par
        <sub>
         i
        </sub>
       </code>
       is the
       <strong>
        parent
       </strong>
       of node
       <code>
        i
       </code>
       , and the edge between them has a weight equal to
       <code>
        weight
        <sub>
         i
        </sub>
       </code>
       . Since the root does
       <strong>
        not
       </strong>
       have a parent, you have
       <code>
        edges[0] = [-1, -1]
       </code>
       .
      </p>
      <p>
       Choose some edges from the tree such that no two chosen edges are
       <strong>
        adjacent
       </strong>
       and the
       <strong>
        sum
       </strong>
       of the weights of the chosen edges is maximized.
      </p>
      <p>
       Return
       <em>
        the
        <strong>
         maximum
        </strong>
        sum of the chosen edges
       </em>
       .
      </p>
      <p>
       <strong>
        Note
       </strong>
       :
      </p>
      <ul>
       <li>
        You are allowed to
        <strong>
         not
        </strong>
        choose any edges in the tree, the sum of weights in this case will be
        <code>
         0
        </code>
        .
       </li>
       <li>
        Two edges
        <code>
         Edge
         <sub>
          1
         </sub>
        </code>
        and
        <code>
         Edge
         <sub>
          2
         </sub>
        </code>
        in the tree are
        <strong>
         adjacent
        </strong>
        if they have a
        <strong>
         common
        </strong>
        node.
        <ul>
         <li>
          In other words, they are adjacent if
          <code>
           Edge
           <sub>
            1
           </sub>
          </code>
          connects nodes
          <code>
           a
          </code>
          and
          <code>
           b
          </code>
          and
          <code>
           Edge
           <sub>
            2
           </sub>
          </code>
          connects nodes
          <code>
           b
          </code>
          and
          <code>
           c
          </code>
          .
         </li>
        </ul>
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2300-2399/2378.Choose%20Edges%20to%20Maximize%20Score%20in%20a%20Tree/images/treedrawio.png" style="width: 271px; height: 221px;"/>
      </p>
      <pre>
<strong>Input:</strong> edges = [[-1,-1],[0,5],[0,10],[2,6],[2,4]]
<strong>Output:</strong> 11
<strong>Explanation:</strong> The above diagram shows the edges that we have to choose colored in red.
The total score is 5 + 6 = 11.
It can be shown that no better score can be obtained.
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2300-2399/2378.Choose%20Edges%20to%20Maximize%20Score%20in%20a%20Tree/images/treee1293712983719827.png" style="width: 221px; height: 181px;"/>
      </p>
      <pre>
<strong>Input:</strong> edges = [[-1,-1],[0,5],[0,-6],[0,7]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> We choose the edge with weight 7.
Note that we cannot choose more than one edge because all edges are adjacent to each other.
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         n == edges.length
        </code>
       </li>
       <li>
        <code>
         1 &lt;= n &lt;= 10
         <sup>
          5
         </sup>
        </code>
       </li>
       <li>
        <code>
         edges[i].length == 2
        </code>
       </li>
       <li>
        <code>
         par
         <sub>
          0
         </sub>
         == weight
         <sub>
          0
         </sub>
         == -1
        </code>
       </li>
       <li>
        <code>
         0 &lt;= par
         <sub>
          i
         </sub>
         &lt;= n - 1
        </code>
        for all
        <code>
         i &gt;= 1
        </code>
        .
       </li>
       <li>
        <code>
         par
         <sub>
          i
         </sub>
         != i
        </code>
       </li>
       <li>
        <code>
         -10
         <sup>
          6
         </sup>
         &lt;= weight
         <sub>
          i
         </sub>
         &lt;= 10
         <sup>
          6
         </sup>
        </code>
        for all
        <code>
         i &gt;= 1
        </code>
        .
       </li>
       <li>
        <code>
         edges
        </code>
        represents a valid tree.
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <ul class="uk-tab" data-uk-switcher="{connect:'#85b328a8-1c3a-452f-b23b-e95524d71e67'}">
       <li class="uk-active">
        <a href="solution-2378.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-2378.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-2378.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-2378.html">
         Go
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="85b328a8-1c3a-452f-b23b-e95524d71e67">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;[]</span> <span class="n">g</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">maxScore</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">List</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">setAll</span><span class="o">(</span><span class="n">g</span><span class="o">,</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">edges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">w</span> <span class="o">=</span> <span class="n">edges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="n">g</span><span class="o">[</span><span class="n">p</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">i</span><span class="o">,</span> <span class="n">w</span><span class="o">});</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">)[</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">long</span><span class="o">[]</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nxt</span> <span class="o">:</span> <span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">nxt</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">w</span> <span class="o">=</span> <span class="n">nxt</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="kt">long</span><span class="o">[]</span> <span class="n">s</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
            <span class="n">a</span> <span class="o">+=</span> <span class="n">s</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="n">b</span> <span class="o">+=</span> <span class="n">s</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">s</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">s</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">w</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">b</span> <span class="o">+=</span> <span class="n">t</span><span class="o">;</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[]</span> <span class="o">{</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">maxScore</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">g</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">w</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">g</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">using</span> <span class="n">ll</span> <span class="o">=</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">pll</span> <span class="o">=</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">ll</span><span class="p">,</span> <span class="n">ll</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="n">pll</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pll</span> <span class="p">{</span>
            <span class="n">ll</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">w</span><span class="p">]</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
                <span class="n">a</span> <span class="o">+=</span> <span class="n">y</span><span class="p">;</span>
                <span class="n">b</span> <span class="o">+=</span> <span class="n">y</span><span class="p">;</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">w</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">b</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">make_pair</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
        <span class="p">};</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">second</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxScore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="n">a</span> <span class="o">+=</span> <span class="n">y</span>
                <span class="n">b</span> <span class="o">+=</span> <span class="n">y</span>
                <span class="n">t</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">+=</span> <span class="n">t</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">g</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">maxScore</span><span class="p">(</span><span class="n">edges</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
	<span class="n">g</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][][</span><span class="m">2</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">p</span><span class="p">,</span> <span class="n">w</span> <span class="o">:=</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="m">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="m">1</span><span class="p">]</span>
		<span class="n">g</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">w</span><span class="p">})</span>
	<span class="p">}</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="kt">int</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span>
		<span class="k">var</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span> <span class="kt">int</span>
		<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="n">j</span><span class="p">,</span> <span class="n">w</span> <span class="o">:=</span> <span class="n">e</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="m">1</span><span class="p">]</span>
			<span class="n">s</span> <span class="o">:=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
			<span class="n">a</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="m">1</span><span class="p">]</span>
			<span class="n">b</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="m">1</span><span class="p">]</span>
			<span class="n">t</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="o">-</span><span class="n">s</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="o">+</span><span class="n">w</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="n">b</span> <span class="o">+=</span> <span class="n">t</span>
		<span class="k">return</span> <span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kt">int64</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="m">0</span><span class="p">)[</span><span class="m">1</span><span class="p">])</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-2378.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
