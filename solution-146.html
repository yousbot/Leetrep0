<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-146.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-146.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>146 - LRU Cache</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 146. LRU Cache Description Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class: LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-146.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-146.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-146.html" rel="stylesheet"/>
   <link href="solution-146.html" rel="stylesheet"/>
   <link href="solution-146.html" rel="stylesheet"/>
   <link href="solution-146.html" rel="stylesheet"/>
   <link href="solution-146.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="146 - LRU Cache" property="og:title"/>
   <meta content="Leetcode 146. LRU Cache Description Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class: LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. The functions get and put must each run in O(1) average time complexity. &amp;nbsp; Example 1: Input [&amp;quot;LRUCache&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;get&amp;quot;] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] Output [null, null, null, 1, null, -1, null, -1, 3, 4] Explanation LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // cache is {1=1} lRUCache.put(2, 2); // cache is {1=1, 2=2} lRUCache.get(1); // return 1 lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3} lRUCache.get(2); // returns -1 (not found) lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3} lRUCache.get(1); // return -1 (not found) lRUCache.get(3); // return 3 lRUCache.get(4); // return 4 &amp;nbsp; Constraints: 1 &amp;lt;= capacity &amp;lt;= 3000 0 &amp;lt;= key &amp;lt;= 104 0 &amp;lt;= value &amp;lt;= 105 At most 2 * 105 calls will be made to get and put. Solutions Create a class MyNode, which contains data fields int key, int value, Node prev and Node next. That is, each node of type MyNode has a key and a value, and have references to its previous node and the next node. In class LRUCache, data fields include int capacity that stores the capacity of the cache, Map&amp;lt;Integer, MyNode&amp;gt; map that maps each key to its node, MyNode head and Node tail that represents the head node and the tail node respectively. For Least Recently Used cache, the most recently used node is the head node and the least recently used node is the tail node. In the constructor, initialize capacity with the given capacity. In get(key), if key is not in map, then key is not in the cache, so return -1. If key is in map, obtain the node and its value, remove the node and set the node to be the head, and return value. In put(key, value), if map contains key, then obtain the node and update its value, remove the node, and set the node to be the head. If map does not contain key, then create a new node using key and value, and set the new node to be the head. If the size of map is greater than or equal to capacity, then remove the node tail and remove the corresponding entry in map. Add a new entry of the new node into the map. Two supplementary methods are needed. Method remove(MyNode node). Obtain MyNodeâs..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-04-24T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-04-24-146-LRU-Cache/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-146.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="146 - LRU Cache" property="twitter:title"/>
   <meta content="Leetcode 146. LRU Cache Description Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class: LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. The functions get and put must each run in O(1) average time complexity. &amp;nbsp; Example 1: Input [&amp;quot;LRUCache&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;get&amp;quot;] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] Output [null, null, null, 1, null, -1, null, -1, 3, 4] Explanation LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // cache is {1=1} lRUCache.put(2, 2); // cache is {1=1, 2=2} lRUCache.get(1); // return 1 lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3} lRUCache.get(2); // returns -1 (not found) lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3} lRUCache.get(1); // return -1 (not found) lRUCache.get(3); // return 3 lRUCache.get(4); // return 4 &amp;nbsp; Constraints: 1 &amp;lt;= capacity &amp;lt;= 3000 0 &amp;lt;= key &amp;lt;= 104 0 &amp;lt;= value &amp;lt;= 105 At most 2 * 105 calls will be made to get and put. Solutions Create a class MyNode, which contains data fields int key, int value, Node prev and Node next. That is, each node of type MyNode has a key and a value, and have references to its previous node and the next node. In class LRUCache, data fields include int capacity that stores the capacity of the cache, Map&amp;lt;Integer, MyNode&amp;gt; map that maps each key to its node, MyNode head and Node tail that represents the head node and the tail node respectively. For Least Recently Used cache, the most recently used node is the head node and the least recently used node is the tail node. In the constructor, initialize capacity with the given capacity. In get(key), if key is not in map, then key is not in the cache, so return -1. If key is in map, obtain the node and its value, remove the node and set the node to be the head, and return value. In put(key, value), if map contains key, then obtain the node and update its value, remove the node, and set the node to be the head. If map does not contain key, then create a new node using key and value, and set the new node to be the head. If the size of map is greater than or equal to capacity, then remove the node tail and remove the corresponding entry in map. Add a new entry of the new node into the map. Two supplementary methods are needed. Method remove(MyNode node). Obtain MyNodeâs..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    146 - LRU Cache | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="146 - LRU Cache" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-146.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-04-24-146-LRU-Cache/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-04-24T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"146 - LRU Cache","dateModified":"2016-04-24T00:00:00-07:00","datePublished":"2016-04-24T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-04-24-146-LRU-Cache/"},"url":"https://leetcode.ca/2016-04-24-146-LRU-Cache/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="146-lru-cache">
       <a href="solution-146.html">
        146. LRU Cache
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Design a data structure that follows the constraints of a
       <strong>
        <a href="solution-146.html" target="_blank">
         Least Recently Used (LRU) cache
        </a>
       </strong>
       .
      </p>
      <p>
       Implement the
       <code>
        LRUCache
       </code>
       class:
      </p>
      <ul>
       <li>
        <code>
         LRUCache(int capacity)
        </code>
        Initialize the LRU cache with
        <strong>
         positive
        </strong>
        size
        <code>
         capacity
        </code>
        .
       </li>
       <li>
        <code>
         int get(int key)
        </code>
        Return the value of the
        <code>
         key
        </code>
        if the key exists, otherwise return
        <code>
         -1
        </code>
        .
       </li>
       <li>
        <code>
         void put(int key, int value)
        </code>
        Update the value of the
        <code>
         key
        </code>
        if the
        <code>
         key
        </code>
        exists. Otherwise, add the
        <code>
         key-value
        </code>
        pair to the cache. If the number of keys exceeds the
        <code>
         capacity
        </code>
        from this operation,
        <strong>
         evict
        </strong>
        the least recently used key.
       </li>
      </ul>
      <p>
       The functions
       <code>
        get
       </code>
       and
       <code>
        put
       </code>
       must each run in
       <code>
        O(1)
       </code>
       average time complexity.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input</strong>
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
<strong>Output</strong>
[null, null, null, 1, null, -1, null, -1, 3, 4]

<strong>Explanation</strong>
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= capacity &lt;= 3000
        </code>
       </li>
       <li>
        <code>
         0 &lt;= key &lt;= 10
         <sup>
          4
         </sup>
        </code>
       </li>
       <li>
        <code>
         0 &lt;= value &lt;= 10
         <sup>
          5
         </sup>
        </code>
       </li>
       <li>
        At most
        <code>
         2 * 10
         <sup>
          5
         </sup>
        </code>
        calls will be made to
        <code>
         get
        </code>
        and
        <code>
         put
        </code>
        .
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       Create a class
       <code class="language-plaintext highlighter-rouge">
        MyNode
       </code>
       , which contains data fields
       <code class="language-plaintext highlighter-rouge">
        int key
       </code>
       ,
       <code class="language-plaintext highlighter-rouge">
        int value
       </code>
       ,
       <code class="language-plaintext highlighter-rouge">
        Node prev
       </code>
       and
       <code class="language-plaintext highlighter-rouge">
        Node next
       </code>
       . That is, each node of type
       <code class="language-plaintext highlighter-rouge">
        MyNode
       </code>
       has a key and a value, and have references to its previous node and the next node.
      </p>
      <p>
       In class
       <code class="language-plaintext highlighter-rouge">
        LRUCache
       </code>
       , data fields include
       <code class="language-plaintext highlighter-rouge">
        int capacity
       </code>
       that stores the capacity of the cache,
       <code class="language-plaintext highlighter-rouge">
        Map&lt;Integer, MyNode&gt; map
       </code>
       that maps each key to its node,
       <code class="language-plaintext highlighter-rouge">
        MyNode head
       </code>
       and
       <code class="language-plaintext highlighter-rouge">
        Node tail
       </code>
       that represents the head node and the tail node respectively. For Least Recently Used cache, the most recently used node is the head node and the least recently used node is the tail node.
      </p>
      <p>
       In the constructor, initialize
       <code class="language-plaintext highlighter-rouge">
        capacity
       </code>
       with the given
       <code class="language-plaintext highlighter-rouge">
        capacity
       </code>
       .
      </p>
      <p>
       In
       <code class="language-plaintext highlighter-rouge">
        get(key)
       </code>
       , if
       <code class="language-plaintext highlighter-rouge">
        key
       </code>
       is not in
       <code class="language-plaintext highlighter-rouge">
        map
       </code>
       , then
       <code class="language-plaintext highlighter-rouge">
        key
       </code>
       is not in the cache, so return -1. If
       <code class="language-plaintext highlighter-rouge">
        key
       </code>
       is in
       <code class="language-plaintext highlighter-rouge">
        map
       </code>
       , obtain the node and its
       <code class="language-plaintext highlighter-rouge">
        value
       </code>
       , remove the node and set the node to be the head, and return
       <code class="language-plaintext highlighter-rouge">
        value
       </code>
       .
      </p>
      <p>
       In
       <code class="language-plaintext highlighter-rouge">
        put(key, value)
       </code>
       , if
       <code class="language-plaintext highlighter-rouge">
        map
       </code>
       contains
       <code class="language-plaintext highlighter-rouge">
        key
       </code>
       , then obtain the node and update its
       <code class="language-plaintext highlighter-rouge">
        value
       </code>
       , remove the node, and set the node to be the head. If
       <code class="language-plaintext highlighter-rouge">
        map
       </code>
       does not contain
       <code class="language-plaintext highlighter-rouge">
        key
       </code>
       , then create a new node using
       <code class="language-plaintext highlighter-rouge">
        key
       </code>
       and
       <code class="language-plaintext highlighter-rouge">
        value
       </code>
       , and set the new node to be the head. If the size of
       <code class="language-plaintext highlighter-rouge">
        map
       </code>
       is greater than or equal to
       <code class="language-plaintext highlighter-rouge">
        capacity
       </code>
       , then remove the node
       <code class="language-plaintext highlighter-rouge">
        tail
       </code>
       and remove the corresponding entry in
       <code class="language-plaintext highlighter-rouge">
        map
       </code>
       . Add a new entry of the new node into the map.
      </p>
      <p>
       Two supplementary methods are needed.
      </p>
      <ol>
       <li>
        Method
        <code class="language-plaintext highlighter-rouge">
         remove(MyNode node)
        </code>
        . Obtain
        <code class="language-plaintext highlighter-rouge">
         MyNode
        </code>
        âs previous node and next node, and update their references to other nodes accordingly. If
        <code class="language-plaintext highlighter-rouge">
         MyNode
        </code>
        is
        <code class="language-plaintext highlighter-rouge">
         head
        </code>
        or
        <code class="language-plaintext highlighter-rouge">
         tail
        </code>
        , then update
        <code class="language-plaintext highlighter-rouge">
         head
        </code>
        or
        <code class="language-plaintext highlighter-rouge">
         tail
        </code>
        accordingly.
       </li>
       <li>
        Method
        <code class="language-plaintext highlighter-rouge">
         setHead(MyNode node)
        </code>
        . Set
        <code class="language-plaintext highlighter-rouge">
         MyNode
        </code>
        to be the new head and set the previous headâs reference accordingly. If
        <code class="language-plaintext highlighter-rouge">
         tail
        </code>
        is
        <code class="language-plaintext highlighter-rouge">
         null
        </code>
        , then update
        <code class="language-plaintext highlighter-rouge">
         tail
        </code>
        as well.
       </li>
      </ol>
      <ul class="uk-tab" data-uk-switcher="{connect:'#9adf408c-c46f-4682-bf80-560a2d39e0e5'}">
       <li class="uk-active">
        <a href="solution-146.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-146.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-146.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-146.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-146.html">
         TypeScript
        </a>
       </li>
       <li>
        <a href="solution-146.html">
         C#
        </a>
       </li>
       <li>
        <a href="solution-146.html">
         RenderScript
        </a>
       </li>
       <li>
        <a href="solution-146.html">
         Javascript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="9adf408c-c46f-4682-bf80-560a2d39e0e5">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">key</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="n">prev</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span>

    <span class="nc">Node</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="nc">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">LRUCache</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&gt;</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
        <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
        <span class="n">tail</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">cache</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="n">moveToHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="n">moveToHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
            <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">node</span><span class="o">);</span>
            <span class="n">addToHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="o">++</span><span class="n">size</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">removeTail</span><span class="o">();</span>
                <span class="n">cache</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
                <span class="o">--</span><span class="n">size</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">moveToHead</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">removeNode</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="n">addToHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">removeNode</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">node</span><span class="o">.</span><span class="na">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">addToHead</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">removeTail</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
        <span class="n">removeNode</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>

    <span class="n">Node</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">k</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">v</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">prev</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">next</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">k</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">v</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">prev</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">next</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">LRUCache</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">LRUCache</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">cap</span><span class="p">(</span><span class="n">capacity</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
        <span class="n">tail</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">key</span><span class="p">))</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
        <span class="n">moveToHead</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">put</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
            <span class="n">moveToHead</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="n">addToHead</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
            <span class="o">++</span><span class="n">size</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">removeTail</span><span class="p">();</span>
                <span class="n">cache</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">);</span>
                <span class="o">--</span><span class="n">size</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Node</span><span class="o">*&gt;</span> <span class="n">cache</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">tail</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cap</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">moveToHead</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">removeNode</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="n">addToHead</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">removeNode</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">addToHead</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Node</span><span class="o">*</span> <span class="n">removeTail</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">tail</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
        <span class="n">removeNode</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj-&gt;get(key);
 * obj-&gt;put(key,value);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>


<span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># key ==&gt; Node(val)
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">Node</span><span class="p">()</span> <span class="c1"># dummy node
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">Node</span><span class="p">()</span> <span class="c1"># dummy node
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="c1"># note: key setup
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">move_to_head</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">move_to_head</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add_to_head</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span><span class="p">:</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">remove_tail</span><span class="p">()</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">cache</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tail</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">size</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">move_to_head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">add_to_head</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">node</span><span class="p">.</span><span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">prev</span>

    <span class="k">def</span> <span class="nf">add_to_head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">node</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">node</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">remove_tail</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>


<span class="c1"># Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
</span>
<span class="c1">############
</span>
<span class="s">'''
example:

&gt;&gt;&gt; od = collections.OrderedDict()
&gt;&gt;&gt;
&gt;&gt;&gt; od[1]=1
&gt;&gt;&gt; od[2]=2
&gt;&gt;&gt; od[3]=3
&gt;&gt;&gt;
&gt;&gt;&gt; od
OrderedDict([(1, 1), (2, 2), (3, 3)])
&gt;&gt;&gt; od.move_to_end(1)
&gt;&gt;&gt; od
OrderedDict([(2, 2), (3, 3), (1, 1)])
&gt;&gt;&gt;
&gt;&gt;&gt; od.get(1)
1
&gt;&gt;&gt; od.popitem()
(1, 1)
&gt;&gt;&gt; od
OrderedDict([(2, 2), (3, 3)])
&gt;&gt;&gt;
&gt;&gt;&gt; od[1]=1
&gt;&gt;&gt; od
OrderedDict([(2, 2), (3, 3), (1, 1)])
&gt;&gt;&gt;
&gt;&gt;&gt; od.popitem(last=False)
(2, 2)
&gt;&gt;&gt; od
OrderedDict([(3, 3), (1, 1)])

'''</span>

<span class="kn">import</span> <span class="nn">collections</span>

<span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s">'int'</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">collections</span><span class="p">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">remain</span> <span class="o">=</span> <span class="n">capacity</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="s">'int'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s">'int'</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cache</span><span class="p">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="c1"># meaning end is the most recently used
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="s">'int'</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s">'int'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s">'None'</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">remain</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">remain</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">cache</span><span class="p">.</span><span class="n">popitem</span><span class="p">(</span><span class="n">last</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># pop start position
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">cache</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> <span class="c1"># add to end of dict, meaning most recently used
</span>

<span class="c1">############
</span>
<span class="c1">### below solution with no ordered-dict
</span><span class="k">class</span> <span class="nc">DLinkedNode</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>


<span class="k">class</span> <span class="nc">DLinkedList</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">DLinkedNode</span><span class="p">()</span> <span class="c1"># dummy head, its next is real head
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">DLinkedNode</span><span class="p">()</span> <span class="c1"># dummy tail, its prev is real tail
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>

    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span> <span class="c1"># add to head
</span>        <span class="n">node</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">,</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">remove_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">node</span><span class="p">.</span><span class="n">prev</span><span class="p">.</span><span class="nb">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">prev</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span>

    <span class="k">def</span> <span class="nf">remove_tail</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">remove_node</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span><span class="p">)</span> <span class="c1"># dummy tail's prev is real tail
</span>
    <span class="k">def</span> <span class="nf">move_to_head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="c1"># def __repr__(self):
</span>    <span class="c1">#     ans = []
</span>    <span class="c1">#     h = self.head
</span>    <span class="c1">#     while h:
</span>    <span class="c1">#         ans.append(str(h.val))
</span>    <span class="c1">#         h = h.next
</span>    <span class="c1">#     return '&lt;DLinkedList: {}&gt;'.format('-&gt;'.join(ans))
</span>
<span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">nodes_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cache_list</span> <span class="o">=</span> <span class="n">DLinkedList</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">nodes_map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">cache_list</span><span class="p">.</span><span class="n">move_to_head</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">nodes_map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rm_key</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">cache_list</span><span class="p">.</span><span class="n">remove_tail</span><span class="p">()</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">nodes_map</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="n">rm_key</span><span class="p">)</span> <span class="c1"># note api
</span>            <span class="n">new_node</span> <span class="o">=</span> <span class="n">DLinkedNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">nodes_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">cache_list</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">cache_list</span><span class="p">.</span><span class="n">move_to_head</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">value</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">type</span> <span class="n">node</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">key</span><span class="p">,</span> <span class="n">val</span>   <span class="kt">int</span>
	<span class="n">prev</span><span class="p">,</span> <span class="n">next</span> <span class="o">*</span><span class="n">node</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">LRUCache</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">capacity</span>   <span class="kt">int</span>
	<span class="n">cache</span>      <span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="n">node</span>
	<span class="n">head</span><span class="p">,</span> <span class="n">tail</span> <span class="o">*</span><span class="n">node</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Constructor</span><span class="p">(</span><span class="n">capacity</span> <span class="kt">int</span><span class="p">)</span> <span class="n">LRUCache</span> <span class="p">{</span>
	<span class="n">head</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
	<span class="n">tail</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
	<span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">tail</span>
	<span class="n">tail</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head</span>
	<span class="k">return</span> <span class="n">LRUCache</span><span class="p">{</span>
		<span class="n">capacity</span><span class="o">:</span> <span class="n">capacity</span><span class="p">,</span>
		<span class="n">cache</span><span class="o">:</span>    <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">capacity</span><span class="p">),</span>
		<span class="n">head</span><span class="o">:</span>     <span class="n">head</span><span class="p">,</span>
		<span class="n">tail</span><span class="o">:</span>     <span class="n">tail</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">LRUCache</span><span class="p">)</span> <span class="n">Get</span><span class="p">(</span><span class="n">key</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">n</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">this</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
	<span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="m">1</span>
	<span class="p">}</span>
	<span class="n">this</span><span class="o">.</span><span class="n">moveToFront</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">val</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">LRUCache</span><span class="p">)</span> <span class="n">Put</span><span class="p">(</span><span class="n">key</span> <span class="kt">int</span><span class="p">,</span> <span class="n">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">n</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">this</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
	<span class="k">if</span> <span class="n">ok</span> <span class="p">{</span>
		<span class="n">n</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">value</span>
		<span class="n">this</span><span class="o">.</span><span class="n">moveToFront</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span> <span class="o">==</span> <span class="n">this</span><span class="o">.</span><span class="n">capacity</span> <span class="p">{</span>
		<span class="n">back</span> <span class="o">:=</span> <span class="n">this</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">prev</span>
		<span class="n">this</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">back</span><span class="p">)</span>
		<span class="nb">delete</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">cache</span><span class="p">,</span> <span class="n">back</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">n</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="p">{</span><span class="n">key</span><span class="o">:</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="o">:</span> <span class="n">value</span><span class="p">}</span>
	<span class="n">this</span><span class="o">.</span><span class="n">pushFront</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
	<span class="n">this</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">LRUCache</span><span class="p">)</span> <span class="n">moveToFront</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">this</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
	<span class="n">this</span><span class="o">.</span><span class="n">pushFront</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">LRUCache</span><span class="p">)</span> <span class="n">remove</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">n</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">next</span>
	<span class="n">n</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">prev</span>
	<span class="n">n</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="no">nil</span>
	<span class="n">n</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">LRUCache</span><span class="p">)</span> <span class="n">pushFront</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">n</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">head</span>
	<span class="n">n</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">next</span>
	<span class="n">this</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">n</span>
	<span class="n">this</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">n</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nx">LRUCache</span> <span class="p">{</span>
    <span class="nl">capacity</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">map</span><span class="p">:</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="kr">number</span><span class="p">,</span> <span class="kr">number</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">capacity</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">capacity</span> <span class="o">=</span> <span class="nx">capacity</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">get</span><span class="p">(</span><span class="nx">key</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">val</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span><span class="o">!</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">);</span>
            <span class="k">return</span> <span class="nx">val</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">put</span><span class="p">(</span><span class="nx">key</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">value</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">capacity</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="nx">keys</span><span class="p">().</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">LRUCache</span> <span class="p">{</span>
    <span class="k">class</span> <span class="nc">Node</span> <span class="p">{</span>
        <span class="k">public</span> <span class="n">Node</span> <span class="n">Prev</span><span class="p">;</span>
        <span class="k">public</span> <span class="n">Node</span> <span class="n">Next</span><span class="p">;</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">Key</span><span class="p">;</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">Val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="n">Node</span> <span class="n">head</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Node</span><span class="p">();</span>
    <span class="k">private</span> <span class="n">Node</span> <span class="n">tail</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Node</span><span class="p">();</span>
    <span class="k">private</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Node</span><span class="p">&gt;</span> <span class="n">cache</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Node</span><span class="p">&gt;();</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
    <span class="k">private</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">LRUCache</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">capacity</span> <span class="p">=</span> <span class="n">capacity</span><span class="p">;</span>
        <span class="n">head</span><span class="p">.</span><span class="n">Next</span> <span class="p">=</span> <span class="n">tail</span><span class="p">;</span>
        <span class="n">tail</span><span class="p">.</span><span class="n">Prev</span> <span class="p">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">public</span> <span class="kt">int</span> <span class="nf">Get</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Node</span> <span class="n">node</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">out</span> <span class="n">node</span><span class="p">))</span> <span class="p">{</span>
            <span class="nf">moveToHead</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">Val</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Put</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Node</span> <span class="n">node</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">out</span> <span class="n">node</span><span class="p">))</span> <span class="p">{</span>
            <span class="nf">moveToHead</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
            <span class="n">node</span><span class="p">.</span><span class="n">Val</span> <span class="p">=</span> <span class="n">Val</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">node</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Node</span><span class="p">()</span> <span class="p">{</span> <span class="n">Key</span> <span class="p">=</span> <span class="n">key</span><span class="p">,</span> <span class="n">Val</span> <span class="p">=</span> <span class="n">Val</span> <span class="p">};</span>
            <span class="n">cache</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
            <span class="nf">addToHead</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(++</span><span class="n">size</span> <span class="p">&gt;</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">node</span> <span class="p">=</span> <span class="nf">removeTail</span><span class="p">();</span>
                <span class="n">cache</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Key</span><span class="p">);</span>
                <span class="p">--</span><span class="n">size</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">moveToHead</span><span class="p">(</span><span class="n">Node</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">removeNode</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="nf">addToHead</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">removeNode</span><span class="p">(</span><span class="n">Node</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span><span class="p">.</span><span class="n">Prev</span><span class="p">.</span><span class="n">Next</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">Next</span><span class="p">;</span>
        <span class="n">node</span><span class="p">.</span><span class="n">Next</span><span class="p">.</span><span class="n">Prev</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">Prev</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">addToHead</span><span class="p">(</span><span class="n">Node</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span><span class="p">.</span><span class="n">Next</span> <span class="p">=</span> <span class="n">head</span><span class="p">.</span><span class="n">Next</span><span class="p">;</span>
        <span class="n">node</span><span class="p">.</span><span class="n">Prev</span> <span class="p">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">head</span><span class="p">.</span><span class="n">Next</span> <span class="p">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="n">node</span><span class="p">.</span><span class="n">Next</span><span class="p">.</span><span class="n">Prev</span> <span class="p">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="n">Node</span> <span class="nf">removeTail</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Node</span> <span class="n">node</span> <span class="p">=</span> <span class="n">tail</span><span class="p">.</span><span class="n">Prev</span><span class="p">;</span>
        <span class="nf">removeNode</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.Get(key);
 * obj.Put(key,Val);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-rs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">key</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">prev</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="nd">#[inline]</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">,</span>
            <span class="n">value</span><span class="p">,</span>
            <span class="n">prev</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="n">next</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">LRUCache</span> <span class="p">{</span>
    <span class="n">capacity</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">cache</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="n">head</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="n">tail</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="cd">/**
 * `&amp;self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&amp;mut self` instead.
 */</span>
<span class="k">impl</span> <span class="n">LRUCache</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">capacity</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">capacity</span><span class="p">:</span> <span class="n">capacity</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">,</span>
            <span class="n">cache</span><span class="p">:</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
            <span class="n">head</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="n">tail</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
                <span class="k">self</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="p">);</span>
                <span class="k">self</span><span class="nf">.push_front</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="n">node</span><span class="nf">.borrow</span><span class="p">()</span><span class="py">.value</span><span class="p">;</span>
                <span class="n">value</span>
            <span class="p">}</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">put</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
                <span class="n">node</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
                <span class="k">self</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="p">);</span>
                <span class="k">self</span><span class="nf">.push_front</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Node</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)));</span>
                <span class="k">self</span><span class="py">.cache</span><span class="nf">.insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="p">));</span>
                <span class="k">self</span><span class="nf">.push_front</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="p">);</span>
                <span class="k">if</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">self</span><span class="py">.capacity</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">back_key</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.pop_back</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">()</span><span class="py">.key</span><span class="p">;</span>
                    <span class="k">self</span><span class="py">.cache</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">back_key</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">push_front</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.head</span><span class="nf">.take</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">head</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.prev</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
                <span class="n">node</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.prev</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
                <span class="n">node</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.next</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
                <span class="k">self</span><span class="py">.head</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.head</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
                <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">remove</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">match</span> <span class="p">(</span><span class="n">node</span><span class="nf">.borrow</span><span class="p">()</span><span class="py">.prev</span><span class="nf">.as_ref</span><span class="p">(),</span> <span class="n">node</span><span class="nf">.borrow</span><span class="p">()</span><span class="py">.next</span><span class="nf">.as_ref</span><span class="p">())</span> <span class="p">{</span>
            <span class="p">(</span><span class="nb">None</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.head</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
                <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="p">(</span><span class="nb">None</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">next</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.head</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">next</span><span class="p">));</span>
                <span class="n">next</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.prev</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">prev</span><span class="p">),</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">prev</span><span class="p">));</span>
                <span class="n">prev</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.next</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">prev</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="n">next</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">next</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.prev</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">prev</span><span class="p">));</span>
                <span class="n">prev</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.next</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">next</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">pop_back</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.take</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tail</span><span class="p">);</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span><span class="cd">/**
 * Your LRUCache object will be instantiated and called as such:
 * let obj = LRUCache::new(capacity);
 * let ret_1: i32 = obj.get(key);
 * obj.put(key, value);
 */</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-js highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * @param {number} capacity
 */</span>
<span class="kd">var</span> <span class="nx">LRUCache</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">capacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">capacity</span> <span class="o">=</span> <span class="nx">capacity</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">tail</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**
 * @param {number} key
 * @return {number}
 */</span>
<span class="nx">LRUCache</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">get</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">removeNode</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">addToHead</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">val</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */</span>
<span class="nx">LRUCache</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">put</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">removeNode</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">addToHead</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">node</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">addToHead</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">capacity</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">nodeToRemove</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nx">prev</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">nodeToRemove</span><span class="p">.</span><span class="nx">key</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">removeNode</span><span class="p">(</span><span class="nx">nodeToRemove</span><span class="p">);</span>
            <span class="o">--</span><span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="nx">LRUCache</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">removeNode</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">prev</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">prev</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">LRUCache</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">addToHead</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**
 * @constructor
 * @param {number} key
 * @param {number} val
 */</span>
<span class="kd">function</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">key</span> <span class="o">=</span> <span class="nx">key</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-146.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
