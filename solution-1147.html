<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-1147.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-1147.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>1147 - Longest Chunked Palindrome Decomposition</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 1147. Longest Chunked Palindrome Decomposition Description You are given a string text. You should split it to k substrings (subtext1, subtext2, ..., subtextk) such that: subtexti is a non-empty string. The concatenation of all the substrings is equal to text (i.e., subtext1 + subtext2 +...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-1147.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-1147.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-1147.html" rel="stylesheet"/>
   <link href="solution-1147.html" rel="stylesheet"/>
   <link href="solution-1147.html" rel="stylesheet"/>
   <link href="solution-1147.html" rel="stylesheet"/>
   <link href="solution-1147.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="1147 - Longest Chunked Palindrome Decomposition" property="og:title"/>
   <meta content="Leetcode 1147. Longest Chunked Palindrome Decomposition Description You are given a string text. You should split it to k substrings (subtext1, subtext2, ..., subtextk) such that: subtexti is a non-empty string. The concatenation of all the substrings is equal to text (i.e., subtext1 + subtext2 + ... + subtextk == text). subtexti == subtextk - i + 1 for all valid values of i (i.e., 1 &amp;lt;= i &amp;lt;= k). Return the largest possible value of k. &amp;nbsp; Example 1: Input: text = &amp;quot;ghiabcdefhelloadamhelloabcdefghi&amp;quot; Output: 7 Explanation: We can split the string on &amp;quot;(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)&amp;quot;. Example 2: Input: text = &amp;quot;merchant&amp;quot; Output: 1 Explanation: We can split the string on &amp;quot;(merchant)&amp;quot;. Example 3: Input: text = &amp;quot;antaprezatepzapreanta&amp;quot; Output: 11 Explanation: We can split the string on &amp;quot;(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a)&amp;quot;. &amp;nbsp; Constraints: 1 &amp;lt;= text.length &amp;lt;= 1000 text consists only of lowercase English characters. Solutions Solution 1: Greedy + Two Pointers We can start from both ends of the string, looking for the shortest, identical, and non-overlapping prefixes and suffixes: If such prefixes and suffixes cannot be found, then the entire string is treated as a segmented palindrome, and the answer is incremented by $1$; If such prefixes and suffixes are found, then this prefix and suffix are treated as a segmented palindrome, and the answer is incremented by $2$, then continue to find the prefixes and suffixes of the remaining string. The proof of the above greedy strategy is as follows: Suppose there is a prefix $A_1$ and a suffix $A_2$ that meet the conditions, and there is a prefix $B_1$ and a suffix $B_4$ that meet the conditions. Since $A_1 = A_2$ and $B_1=B_4$, then $B_3=B_1=B_4=B_2$, and $C_1 = C_2$. Therefore, if we greedily split $B_1$ and $B_4$, then the remaining $C_1$ and $C_2$, and $B_2$ and $B_3$ can also be successfully split. Therefore, we should greedily choose the shortest identical prefix and suffix to split, so that in the remaining string, more segmented palindromes may be split. The time complexity is $O(n^2)$, and the space complexity is $O(n)$ or $O(1)$. Here, $n$ is the length of the string. Solution 2: String Hash String hash is to map a string of any length to a non-negative integer, and its collision probability is almost $0$. String hash is used to calculate the hash value of a string and quickly determine whether two strings are equal. Therefore, based on Solution 1, we can use the method of string hash to compare whether two strings are equal in $O(1)$ time. The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string. Java C++ Python Go TypeScript class Solution { public int longestDecomposition(String text) { int n = text.length(); if (n &amp;lt; 2) { return n; } for (int i = 1; i &amp;lt;= n &amp;gt;&amp;gt; 1; ++i) { if (text.substring(0, i).equals(text.substring(n - i))) { return 2 + longestDecomposition(text.substring(i, n - i)); } } return 1; } } class Solution { public: int longestDecomposition(string..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2019-01-20T00:00:00-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2019-01-20-1147-Longest-Chunked-Palindrome-Decomposition/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-1147.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="1147 - Longest Chunked Palindrome Decomposition" property="twitter:title"/>
   <meta content="Leetcode 1147. Longest Chunked Palindrome Decomposition Description You are given a string text. You should split it to k substrings (subtext1, subtext2, ..., subtextk) such that: subtexti is a non-empty string. The concatenation of all the substrings is equal to text (i.e., subtext1 + subtext2 + ... + subtextk == text). subtexti == subtextk - i + 1 for all valid values of i (i.e., 1 &amp;lt;= i &amp;lt;= k). Return the largest possible value of k. &amp;nbsp; Example 1: Input: text = &amp;quot;ghiabcdefhelloadamhelloabcdefghi&amp;quot; Output: 7 Explanation: We can split the string on &amp;quot;(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)&amp;quot;. Example 2: Input: text = &amp;quot;merchant&amp;quot; Output: 1 Explanation: We can split the string on &amp;quot;(merchant)&amp;quot;. Example 3: Input: text = &amp;quot;antaprezatepzapreanta&amp;quot; Output: 11 Explanation: We can split the string on &amp;quot;(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a)&amp;quot;. &amp;nbsp; Constraints: 1 &amp;lt;= text.length &amp;lt;= 1000 text consists only of lowercase English characters. Solutions Solution 1: Greedy + Two Pointers We can start from both ends of the string, looking for the shortest, identical, and non-overlapping prefixes and suffixes: If such prefixes and suffixes cannot be found, then the entire string is treated as a segmented palindrome, and the answer is incremented by $1$; If such prefixes and suffixes are found, then this prefix and suffix are treated as a segmented palindrome, and the answer is incremented by $2$, then continue to find the prefixes and suffixes of the remaining string. The proof of the above greedy strategy is as follows: Suppose there is a prefix $A_1$ and a suffix $A_2$ that meet the conditions, and there is a prefix $B_1$ and a suffix $B_4$ that meet the conditions. Since $A_1 = A_2$ and $B_1=B_4$, then $B_3=B_1=B_4=B_2$, and $C_1 = C_2$. Therefore, if we greedily split $B_1$ and $B_4$, then the remaining $C_1$ and $C_2$, and $B_2$ and $B_3$ can also be successfully split. Therefore, we should greedily choose the shortest identical prefix and suffix to split, so that in the remaining string, more segmented palindromes may be split. The time complexity is $O(n^2)$, and the space complexity is $O(n)$ or $O(1)$. Here, $n$ is the length of the string. Solution 2: String Hash String hash is to map a string of any length to a non-negative integer, and its collision probability is almost $0$. String hash is used to calculate the hash value of a string and quickly determine whether two strings are equal. Therefore, based on Solution 1, we can use the method of string hash to compare whether two strings are equal in $O(1)$ time. The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string. Java C++ Python Go TypeScript class Solution { public int longestDecomposition(String text) { int n = text.length(); if (n &amp;lt; 2) { return n; } for (int i = 1; i &amp;lt;= n &amp;gt;&amp;gt; 1; ++i) { if (text.substring(0, i).equals(text.substring(n - i))) { return 2 + longestDecomposition(text.substring(i, n - i)); } } return 1; } } class Solution { public: int longestDecomposition(string..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    1147 - Longest Chunked Palindrome Decomposition | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="1147 - Longest Chunked Palindrome Decomposition" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-1147.html" rel="canonical">
          <meta content="https://leetcode.ca/2019-01-20-1147-Longest-Chunked-Palindrome-Decomposition/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2019-01-20T00:00:00-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"1147 - Longest Chunked Palindrome Decomposition","dateModified":"2019-01-20T00:00:00-08:00","datePublished":"2019-01-20T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2019-01-20-1147-Longest-Chunked-Palindrome-Decomposition/"},"url":"https://leetcode.ca/2019-01-20-1147-Longest-Chunked-Palindrome-Decomposition/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="1147-longest-chunked-palindrome-decomposition">
       <a href="solution-1147.html">
        1147. Longest Chunked Palindrome Decomposition
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       You are given a string
       <code>
        text
       </code>
       . You should split it to k substrings
       <code>
        (subtext
        <sub>
         1
        </sub>
        , subtext
        <sub>
         2
        </sub>
        , ..., subtext
        <sub>
         k
        </sub>
        )
       </code>
       such that:
      </p>
      <ul>
       <li>
        <code>
         subtext
         <sub>
          i
         </sub>
        </code>
        is a
        <strong>
         non-empty
        </strong>
        string.
       </li>
       <li>
        The concatenation of all the substrings is equal to
        <code>
         text
        </code>
        (i.e.,
        <code>
         subtext
         <sub>
          1
         </sub>
         + subtext
         <sub>
          2
         </sub>
         + ... + subtext
         <sub>
          k
         </sub>
         == text
        </code>
        ).
       </li>
       <li>
        <code>
         subtext
         <sub>
          i
         </sub>
         == subtext
         <sub>
          k - i + 1
         </sub>
        </code>
        for all valid values of
        <code>
         i
        </code>
        (i.e.,
        <code>
         1 &lt;= i &lt;= k
        </code>
        ).
       </li>
      </ul>
      <p>
       Return the largest possible value of
       <code>
        k
       </code>
       .
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> text = "ghiabcdefhelloadamhelloabcdefghi"
<strong>Output:</strong> 7
<strong>Explanation:</strong> We can split the string on "(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)".
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> text = "merchant"
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can split the string on "(merchant)".
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> text = "antaprezatepzapreanta"
<strong>Output:</strong> 11
<strong>Explanation:</strong> We can split the string on "(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a)".
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= text.length &lt;= 1000
        </code>
       </li>
       <li>
        <code>
         text
        </code>
        consists only of lowercase English characters.
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       <strong>
        Solution 1: Greedy + Two Pointers
       </strong>
      </p>
      <p>
       We can start from both ends of the string, looking for the shortest, identical, and non-overlapping prefixes and suffixes:
      </p>
      <ul>
       <li>
        If such prefixes and suffixes cannot be found, then the entire string is treated as a segmented palindrome, and the answer is incremented by $1$;
       </li>
       <li>
        If such prefixes and suffixes are found, then this prefix and suffix are treated as a segmented palindrome, and the answer is incremented by $2$, then continue to find the prefixes and suffixes of the remaining string.
       </li>
      </ul>
      <p>
       The proof of the above greedy strategy is as follows:
      </p>
      <p>
       Suppose there is a prefix $A_1$ and a suffix $A_2$ that meet the conditions, and there is a prefix $B_1$ and a suffix $B_4$ that meet the conditions. Since $A_1 = A_2$ and $B_1=B_4$, then $B_3=B_1=B_4=B_2$, and $C_1 = C_2$. Therefore, if we greedily split $B_1$ and $B_4$, then the remaining $C_1$ and $C_2$, and $B_2$ and $B_3$ can also be successfully split. Therefore, we should greedily choose the shortest identical prefix and suffix to split, so that in the remaining string, more segmented palindromes may be split.
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1100-1199/1147.Longest%20Chunked%20Palindrome%20Decomposition/images/demo.png" style="width: 300px;"/>
      </p>
      <p>
       The time complexity is $O(n^2)$, and the space complexity is $O(n)$ or $O(1)$. Here, $n$ is the length of the string.
      </p>
      <p>
       <strong>
        Solution 2: String Hash
       </strong>
      </p>
      <p>
       <strong>
        String hash
       </strong>
       is to map a string of any length to a non-negative integer, and its collision probability is almost $0$. String hash is used to calculate the hash value of a string and quickly determine whether two strings are equal.
      </p>
      <p>
       Therefore, based on Solution 1, we can use the method of string hash to compare whether two strings are equal in $O(1)$ time.
      </p>
      <p>
       The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#925ce80a-09ba-43f7-9c1f-4bfb18426733'}">
       <li class="uk-active">
        <a href="solution-1147.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-1147.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-1147.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-1147.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-1147.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="925ce80a-09ba-43f7-9c1f-4bfb18426733">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestDecomposition</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">text</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="n">text</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">longestDecomposition</span><span class="o">(</span><span class="n">text</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">longestDecomposition</span><span class="p">(</span><span class="n">string</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">text</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">text</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">longestDecomposition</span><span class="p">(</span><span class="n">text</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="n">i</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestDecomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">text</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">text</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">:]:</span>
                <span class="k">return</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">longestDecomposition</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="o">-</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="mi">1</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">longestDecomposition</span><span class="p">(</span><span class="n">text</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="m">2</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">n</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">&gt;&gt;</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="o">:</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">text</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">:</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="m">2</span> <span class="o">+</span> <span class="n">longestDecomposition</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="o">:</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="m">1</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">function</span> <span class="nx">longestDecomposition</span><span class="p">(</span><span class="nx">text</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">n</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="nx">text</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">text</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="o">===</span> <span class="nx">text</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="nx">i</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">2</span> <span class="o">+</span> <span class="nx">longestDecomposition</span><span class="p">(</span><span class="nx">text</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">n</span> <span class="o">-</span> <span class="nx">i</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-1147.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
