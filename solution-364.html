<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-364.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-364.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>364 - Nested List Weight Sum II</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 364. Nested List Weight Sum II Description You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. The depth of an integer is the number of lists that...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-364.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-364.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-364.html" rel="stylesheet"/>
   <link href="solution-364.html" rel="stylesheet"/>
   <link href="solution-364.html" rel="stylesheet"/>
   <link href="solution-364.html" rel="stylesheet"/>
   <link href="solution-364.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="364 - Nested List Weight Sum II" property="og:title"/>
   <meta content="Leetcode 364. Nested List Weight Sum II Description You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer&amp;#39;s value set to its depth. Let maxDepth be the maximum depth of any integer. The weight of an integer is maxDepth - (the depth of the integer) + 1. Return the sum of each integer in nestedList multiplied by its weight. &amp;nbsp; Example 1: Input: nestedList = [[1,1],2,[1,1]] Output: 8 Explanation: Four 1&amp;#39;s with a weight of 1, one 2 with a weight of 2. 1*1 + 1*1 + 2*2 + 1*1 + 1*1 = 8 Example 2: Input: nestedList = [1,[4,[6]]] Output: 17 Explanation: One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1. 1*3 + 4*2 + 6*1 = 17 &amp;nbsp; Constraints: 1 &amp;lt;= nestedList.length &amp;lt;= 50 The values of the integers in the nested list is in the range [-100, 100]. The maximum depth of any integer is less than or equal to 50. Solutions - 1, two passes Straightforward solution is 2 passes 1st pass to depth first then calculate Solutions - 2, one pass And moreover, below is another way of solving it via only 1-pass. Explanation of the 1-pass Approach The solution uses an iterative approach to traverse the nested list level by level, starting from the outermost level (level 1) and moving inward. It keeps track of two sums: unweighted: The cumulative sum of all integers encountered so far, regardless of their depth. weighted: The weighted sum, which is recalculated at each level to reflect the increasing weight of previously encountered integers as the traversal goes deeper. Initialization: If the input list is empty, the function immediately returns 0. This check is technically redundant due to Pythonâs treatment of empty lists as falsy values, which would naturally terminate the loop. Iterative Traversal: The solution iteratively traverses the nested list. At each iteration, it processes one level of the list. Accumulating unweighted Sum: For each element a in the current level (nestedList), if a is an integer, its value is added to unweighted. This sum accumulates values from all levels processed so far but does not account for their depth. Preparing for Next Level: If a is not an integer but another nested list, the elements of this list are added to next_level, preparing them for processing in the next iteration. Updating weighted Sum: After processing each level, weighted is increased by unweighted. This step is crucial because it effectively adds the unweighted sum repeatedly, once for each level of depth, thereby inversely weighting the depth. Deeper integers have already contributed to unweighted in earlier iterations, so they are counted multiple times in weighted, reflecting their deeper level. Moving to the Next Level: The list..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-11-28T00:00:00-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-11-28-364-Nested-List-Weight-Sum-II/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-364.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="364 - Nested List Weight Sum II" property="twitter:title"/>
   <meta content="Leetcode 364. Nested List Weight Sum II Description You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer&amp;#39;s value set to its depth. Let maxDepth be the maximum depth of any integer. The weight of an integer is maxDepth - (the depth of the integer) + 1. Return the sum of each integer in nestedList multiplied by its weight. &amp;nbsp; Example 1: Input: nestedList = [[1,1],2,[1,1]] Output: 8 Explanation: Four 1&amp;#39;s with a weight of 1, one 2 with a weight of 2. 1*1 + 1*1 + 2*2 + 1*1 + 1*1 = 8 Example 2: Input: nestedList = [1,[4,[6]]] Output: 17 Explanation: One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1. 1*3 + 4*2 + 6*1 = 17 &amp;nbsp; Constraints: 1 &amp;lt;= nestedList.length &amp;lt;= 50 The values of the integers in the nested list is in the range [-100, 100]. The maximum depth of any integer is less than or equal to 50. Solutions - 1, two passes Straightforward solution is 2 passes 1st pass to depth first then calculate Solutions - 2, one pass And moreover, below is another way of solving it via only 1-pass. Explanation of the 1-pass Approach The solution uses an iterative approach to traverse the nested list level by level, starting from the outermost level (level 1) and moving inward. It keeps track of two sums: unweighted: The cumulative sum of all integers encountered so far, regardless of their depth. weighted: The weighted sum, which is recalculated at each level to reflect the increasing weight of previously encountered integers as the traversal goes deeper. Initialization: If the input list is empty, the function immediately returns 0. This check is technically redundant due to Pythonâs treatment of empty lists as falsy values, which would naturally terminate the loop. Iterative Traversal: The solution iteratively traverses the nested list. At each iteration, it processes one level of the list. Accumulating unweighted Sum: For each element a in the current level (nestedList), if a is an integer, its value is added to unweighted. This sum accumulates values from all levels processed so far but does not account for their depth. Preparing for Next Level: If a is not an integer but another nested list, the elements of this list are added to next_level, preparing them for processing in the next iteration. Updating weighted Sum: After processing each level, weighted is increased by unweighted. This step is crucial because it effectively adds the unweighted sum repeatedly, once for each level of depth, thereby inversely weighting the depth. Deeper integers have already contributed to unweighted in earlier iterations, so they are counted multiple times in weighted, reflecting their deeper level. Moving to the Next Level: The list..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    364 - Nested List Weight Sum II | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="364 - Nested List Weight Sum II" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-364.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-11-28-364-Nested-List-Weight-Sum-II/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-11-28T00:00:00-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"364 - Nested List Weight Sum II","dateModified":"2016-11-28T00:00:00-08:00","datePublished":"2016-11-28T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-11-28-364-Nested-List-Weight-Sum-II/"},"url":"https://leetcode.ca/2016-11-28-364-Nested-List-Weight-Sum-II/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="364-nested-list-weight-sum-ii">
       <a href="solution-364.html">
        364. Nested List Weight Sum II
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       You are given a nested list of integers
       <code>
        nestedList
       </code>
       . Each element is either an integer or a list whose elements may also be integers or other lists.
      </p>
      <p>
       The
       <strong>
        depth
       </strong>
       of an integer is the number of lists that it is inside of. For example, the nested list
       <code>
        [1,[2,2],[[3],2],1]
       </code>
       has each integer's value set to its
       <strong>
        depth
       </strong>
       . Let
       <code>
        maxDepth
       </code>
       be the
       <strong>
        maximum depth
       </strong>
       of any integer.
      </p>
      <p>
       The
       <strong>
        weight
       </strong>
       of an integer is
       <code>
        maxDepth - (the depth of the integer) + 1
       </code>
       .
      </p>
      <p>
       Return
       <em>
        the sum of each integer in
       </em>
       <code>
        nestedList
       </code>
       <em>
        multiplied by its
        <strong>
         weight
        </strong>
       </em>
       .
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0300-0399/0364.Nested%20List%20Weight%20Sum%20II/images/nestedlistweightsumiiex1.png" style="width: 426px; height: 181px;"/>
      </p>
      <pre>
<strong>Input:</strong> nestedList = [[1,1],2,[1,1]]
<strong>Output:</strong> 8
<strong>Explanation:</strong> Four 1's with a weight of 1, one 2 with a weight of 2.
1*1 + 1*1 + 2*2 + 1*1 + 1*1 = 8
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0300-0399/0364.Nested%20List%20Weight%20Sum%20II/images/nestedlistweightsumiiex2.png" style="width: 349px; height: 192px;"/>
      </p>
      <pre>
<strong>Input:</strong> nestedList = [1,[4,[6]]]
<strong>Output:</strong> 17
<strong>Explanation:</strong> One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1.
1*3 + 4*2 + 6*1 = 17
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= nestedList.length &lt;= 50
        </code>
       </li>
       <li>
        The values of the integers in the nested list is in the range
        <code>
         [-100, 100]
        </code>
        .
       </li>
       <li>
        The maximum
        <strong>
         depth
        </strong>
        of any integer is less than or equal to
        <code>
         50
        </code>
        .
       </li>
      </ul>
      <h2 id="solutions---1-two-passes">
       Solutions - 1, two passes
      </h2>
      <p>
       Straightforward solution is 2 passes
      </p>
      <ul>
       <li>
        1st pass to depth first
       </li>
       <li>
        then calculate
       </li>
      </ul>
      <h2 id="solutions---2-one-pass">
       Solutions - 2, one pass
      </h2>
      <p>
       And moreover, below is another way of solving it via only
       <code class="language-plaintext highlighter-rouge">
        1-pass
       </code>
       .
      </p>
      <h3 id="explanation-of-the-1-pass-approach">
       Explanation of the
       <code class="language-plaintext highlighter-rouge">
        1-pass
       </code>
       Approach
      </h3>
      <p>
       The solution uses an iterative approach to traverse the nested list level by level, starting from the outermost level (level 1) and moving inward. It keeps track of two sums:
      </p>
      <ul>
       <li>
        <code class="language-plaintext highlighter-rouge">
         unweighted
        </code>
        : The cumulative sum of all integers encountered so far, regardless of their depth.
       </li>
       <li>
        <code class="language-plaintext highlighter-rouge">
         weighted
        </code>
        : The weighted sum, which is recalculated at each level to reflect the increasing weight of previously encountered integers as the traversal goes deeper.
       </li>
      </ul>
      <ol>
       <li>
        <p>
         <strong>
          Initialization
         </strong>
         : If the input list is empty, the function immediately returns
         <code class="language-plaintext highlighter-rouge">
          0
         </code>
         . This check is technically redundant due to Pythonâs treatment of empty lists as falsy values, which would naturally terminate the loop.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Iterative Traversal
         </strong>
         : The solution iteratively traverses the nested list. At each iteration, it processes one level of the list.
        </p>
        <ul>
         <li>
          <p>
           <strong>
            Accumulating
            <code class="language-plaintext highlighter-rouge">
             unweighted
            </code>
            Sum
           </strong>
           : For each element
           <code class="language-plaintext highlighter-rouge">
            a
           </code>
           in the current level (
           <code class="language-plaintext highlighter-rouge">
            nestedList
           </code>
           ), if
           <code class="language-plaintext highlighter-rouge">
            a
           </code>
           is an integer, its value is added to
           <code class="language-plaintext highlighter-rouge">
            unweighted
           </code>
           . This sum accumulates values from all levels processed so far but does not account for their depth.
          </p>
         </li>
         <li>
          <p>
           <strong>
            Preparing for Next Level
           </strong>
           : If
           <code class="language-plaintext highlighter-rouge">
            a
           </code>
           is not an integer but another nested list, the elements of this list are added to
           <code class="language-plaintext highlighter-rouge">
            next_level
           </code>
           , preparing them for processing in the next iteration.
          </p>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          Updating
          <code class="language-plaintext highlighter-rouge">
           weighted
          </code>
          Sum
         </strong>
         : After processing each level,
         <code class="language-plaintext highlighter-rouge">
          weighted
         </code>
         is increased by
         <code class="language-plaintext highlighter-rouge">
          unweighted
         </code>
         . This step is crucial because it effectively adds the
         <code class="language-plaintext highlighter-rouge">
          unweighted
         </code>
         sum repeatedly, once for each level of depth, thereby inversely weighting the depth. Deeper integers have already contributed to
         <code class="language-plaintext highlighter-rouge">
          unweighted
         </code>
         in earlier iterations, so they are counted multiple times in
         <code class="language-plaintext highlighter-rouge">
          weighted
         </code>
         , reflecting their deeper level.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Moving to the Next Level
         </strong>
         : The list to be processed in the next iteration is updated to
         <code class="language-plaintext highlighter-rouge">
          next_level
         </code>
         , moving the traversal one level deeper into the nested list structure.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Returning the Result
         </strong>
         : Once all levels have been processed and there are no more elements to traverse, the
         <code class="language-plaintext highlighter-rouge">
          weighted
         </code>
         sum represents the inverse depth sum of the original nested list, and it is returned as the result.
        </p>
       </li>
      </ol>
      <h3 id="example">
       Example
      </h3>
      <p>
       Consider the nested list
       <code class="language-plaintext highlighter-rouge">
        [[1,1],2,[1,1]]
       </code>
       . The inverse depth sum is calculated as follows:
      </p>
      <ul>
       <li>
        At the outermost level, the sum of integers is
        <code class="language-plaintext highlighter-rouge">
         2
        </code>
        (only the integer
        <code class="language-plaintext highlighter-rouge">
         2
        </code>
        is at this level). This value is added to
        <code class="language-plaintext highlighter-rouge">
         weighted
        </code>
        . So
        <code class="language-plaintext highlighter-rouge">
         weighted=2
        </code>
        and
        <code class="language-plaintext highlighter-rouge">
         unweighted=2
        </code>
       </li>
       <li>
        At the next level, the sum of integers is
        <code class="language-plaintext highlighter-rouge">
         4
        </code>
        (from the four
        <code class="language-plaintext highlighter-rouge">
         1
        </code>
        s in the nested lists). This sum is added to
        <code class="language-plaintext highlighter-rouge">
         unweighted
        </code>
        making it
        <code class="language-plaintext highlighter-rouge">
         6
        </code>
        (once for this level and once from the previous levelâs
        <code class="language-plaintext highlighter-rouge">
         unweighted
        </code>
        sum
        <code class="language-plaintext highlighter-rouge">
         2
        </code>
        ).
       </li>
      </ul>
      <p>
       The final
       <code class="language-plaintext highlighter-rouge">
        weighted
       </code>
       sum is
       <code class="language-plaintext highlighter-rouge">
        weighted + unweighted
       </code>
       , i.e.
       <code class="language-plaintext highlighter-rouge">
        2 + 6 = 8
       </code>
       , which is the inverse depth sum of the nested list.
      </p>
      <p>
       This approach efficiently calculates the inverse depth sum without needing to explicitly track the depth of each integer, leveraging the iterative re-accumulation of
       <code class="language-plaintext highlighter-rouge">
        unweighted
       </code>
       sums to achieve the correct weighting.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#77ce9d48-0ae7-4bc6-9abe-f8eadaad06e3'}">
       <li class="uk-active">
        <a href="solution-364.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-364.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-364.html">
         Javascript
        </a>
       </li>
       <li>
        <a href="solution-364.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-364.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-364.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="77ce9d48-0ae7-4bc6-9abe-f8eadaad06e3">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * public interface NestedInteger {
 *     // Constructor initializes an empty nested list.
 *     public NestedInteger();
 *
 *     // Constructor initializes a single integer.
 *     public NestedInteger(int value);
 *
 *     // @return true if this NestedInteger holds a single integer, rather than a nested list.
 *     public boolean isInteger();
 *
 *     // @return the single integer that this NestedInteger holds, if it holds a single integer
 *     // Return null if this NestedInteger holds a nested list
 *     public Integer getInteger();
 *
 *     // Set this NestedInteger to hold a single integer.
 *     public void setInteger(int value);
 *
 *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.
 *     public void add(NestedInteger ni);
 *
 *     // @return the nested list that this NestedInteger holds, if it holds a nested list
 *     // Return empty list if this NestedInteger holds a single integer
 *     public List&lt;NestedInteger&gt; getList();
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">depthSumInverse</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;</span> <span class="n">nestedList</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">maxDepth</span><span class="o">(</span><span class="n">nestedList</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">nestedList</span><span class="o">,</span> <span class="n">depth</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">maxDepth</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;</span> <span class="n">nestedList</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">NestedInteger</span> <span class="n">item</span> <span class="o">:</span> <span class="n">nestedList</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">isInteger</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">depth</span><span class="o">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">maxDepth</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">getList</span><span class="o">()));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">depth</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">NestedInteger</span><span class="o">&gt;</span> <span class="n">nestedList</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">depthSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">NestedInteger</span> <span class="n">item</span> <span class="o">:</span> <span class="n">nestedList</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">isInteger</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">depthSum</span> <span class="o">+=</span> <span class="n">item</span><span class="o">.</span><span class="na">getInteger</span><span class="o">()</span> <span class="o">*</span> <span class="n">depth</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">depthSum</span> <span class="o">+=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">getList</span><span class="o">(),</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">depthSum</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># """
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# """
# class NestedInteger:
#    def __init__(self, value=None):
#        """
#        If value is not specified, initializes an empty list.
#        Otherwise initializes a single integer equal to value.
#        """
#
#    def isInteger(self):
#        """
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        """
#
#    def add(self, elem):
#        """
#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
#        :rtype void
#        """
#
#    def setInteger(self, value):
#        """
#        Set this NestedInteger to hold a single integer equal to value.
#        :rtype void
#        """
#
#    def getInteger(self):
#        """
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        """
#
#    def getList(self):
#        """
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        """
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">depthSumInverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nestedList</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">NestedInteger</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">max_depth</span><span class="p">(</span><span class="n">nestedList</span><span class="p">):</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">nestedList</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">item</span><span class="p">.</span><span class="n">isInteger</span><span class="p">():</span>
                    <span class="k">continue</span>
                <span class="n">depth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">getList</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">depth</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">nestedList</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">):</span>
            <span class="n">depth_sum</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">nestedList</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">item</span><span class="p">.</span><span class="n">isInteger</span><span class="p">():</span>
                    <span class="n">depth_sum</span> <span class="o">+=</span> <span class="n">item</span><span class="p">.</span><span class="n">getInteger</span><span class="p">()</span> <span class="o">*</span> <span class="n">max_depth</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">depth_sum</span> <span class="o">+=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">getList</span><span class="p">(),</span> <span class="n">max_depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">depth_sum</span>

        <span class="n">depth</span> <span class="o">=</span> <span class="n">max_depth</span><span class="p">(</span><span class="n">nestedList</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">nestedList</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span>

<span class="c1">############
</span>
<span class="k">class</span> <span class="nc">Solution_onePass</span><span class="p">:</span> <span class="c1"># iterative
</span>    <span class="k">def</span> <span class="nf">depthSumInverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nestedList</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">NestedInteger</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nestedList</span><span class="p">:</span>
        <span class="c1"># can remove this check, an empty list in Python is considered "falsy"
</span>        <span class="c1"># and the loop will exit when it reaches the end of the list
</span>            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># weighted is like previous round result
</span>        <span class="n">unweighted</span> <span class="o">=</span> <span class="n">weighted</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">nestedList</span><span class="p">:</span>
            <span class="n">next_level</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">nestedList</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">a</span><span class="p">.</span><span class="n">isInteger</span><span class="p">():</span>
                    <span class="n">unweighted</span> <span class="o">+=</span> <span class="n">a</span><span class="p">.</span><span class="n">getInteger</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">next_level</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">getList</span><span class="p">())</span>
            <span class="n">weighted</span> <span class="o">+=</span> <span class="n">unweighted</span>
            <span class="n">nestedList</span> <span class="o">=</span> <span class="n">next_level</span>
        <span class="k">return</span> <span class="n">weighted</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-js highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * function NestedInteger() {
 *
 *     Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     @return {boolean}
 *     this.isInteger = function() {
 *         ...
 *     };
 *
 *     Return the single integer that this NestedInteger holds, if it holds a single integer
 *     Return null if this NestedInteger holds a nested list
 *     @return {integer}
 *     this.getInteger = function() {
 *         ...
 *     };
 *
 *     Set this NestedInteger to hold a single integer equal to value.
 *     @return {void}
 *     this.setInteger = function(value) {
 *         ...
 *     };
 *
 *     Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
 *     @return {void}
 *     this.add = function(elem) {
 *         ...
 *     };
 *
 *     Return the nested list that this NestedInteger holds, if it holds a nested list
 *     Return null if this NestedInteger holds a single integer
 *     @return {NestedInteger[]}
 *     this.getList = function() {
 *         ...
 *     };
 * };
 */</span>
<span class="cm">/**
 * @param {NestedInteger[]} nestedList
 * @return {number}
 */</span>
<span class="kd">var</span> <span class="nx">depthSumInverse</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">nestedList</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">maxDepth</span> <span class="o">=</span> <span class="nx">nestedList</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">depth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">nestedList</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nx">depth</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">maxDepth</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">getList</span><span class="p">()));</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">depth</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">nestedList</span><span class="p">,</span> <span class="nx">depth</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">depthSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">nestedList</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">())</span> <span class="p">{</span>
                <span class="nx">depthSum</span> <span class="o">+=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">getInteger</span><span class="p">()</span> <span class="o">*</span> <span class="nx">depth</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">depthSum</span> <span class="o">+=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">getList</span><span class="p">(),</span> <span class="nx">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">depthSum</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kd">const</span> <span class="nx">depth</span> <span class="o">=</span> <span class="nx">maxDepth</span><span class="p">(</span><span class="nx">nestedList</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">nestedList</span><span class="p">,</span> <span class="nx">depth</span><span class="p">);</span>
<span class="p">};</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * class NestedInteger {
 *   public:
 *     // Constructor initializes an empty nested list.
 *     NestedInteger();
 *
 *     // Constructor initializes a single integer.
 *     NestedInteger(int value);
 *
 *     // Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     bool isInteger() const;
 *
 *     // Return the single integer that this NestedInteger holds, if it holds a single integer
 *     // The result is undefined if this NestedInteger holds a nested list
 *     int getInteger() const;
 *
 *     // Set this NestedInteger to hold a single integer.
 *     void setInteger(int value);
 *
 *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.
 *     void add(const NestedInteger &amp;ni);
 *
 *     // Return the nested list that this NestedInteger holds, if it holds a nested list
 *     // The result is undefined if this NestedInteger holds a single integer
 *     const vector&lt;NestedInteger&gt; &amp;getList() const;
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">depthSumInverse</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">NestedInteger</span><span class="o">&gt;&amp;</span> <span class="n">nestedList</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">maxDepth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ws</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">NestedInteger</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">NestedInteger</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">maxDepth</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxDepth</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">isInteger</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">ws</span> <span class="o">+=</span> <span class="n">x</span><span class="p">.</span><span class="n">getInteger</span><span class="p">()</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="n">x</span><span class="p">.</span><span class="n">getInteger</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">y</span> <span class="o">:</span> <span class="n">x</span><span class="p">.</span><span class="n">getList</span><span class="p">())</span> <span class="p">{</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">};</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nestedList</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">maxDepth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span> <span class="o">-</span> <span class="n">ws</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * type NestedInteger struct {
 * }
 *
 * // Return true if this NestedInteger holds a single integer, rather than a nested list.
 * func (n NestedInteger) IsInteger() bool {}
 *
 * // Return the single integer that this NestedInteger holds, if it holds a single integer
 * // The result is undefined if this NestedInteger holds a nested list
 * // So before calling this method, you should have a check
 * func (n NestedInteger) GetInteger() int {}
 *
 * // Set this NestedInteger to hold a single integer.
 * func (n *NestedInteger) SetInteger(value int) {}
 *
 * // Set this NestedInteger to hold a nested list and adds a nested integer to it.
 * func (n *NestedInteger) Add(elem NestedInteger) {}
 *
 * // Return the nested list that this NestedInteger holds, if it holds a nested list
 * // The list length is zero if this NestedInteger holds a single integer
 * // You can access NestedInteger's List element directly if you want to modify it
 * func (n NestedInteger) GetList() []*NestedInteger {}
 */</span>
<span class="k">func</span> <span class="n">depthSumInverse</span><span class="p">(</span><span class="n">nestedList</span> <span class="p">[]</span><span class="o">*</span><span class="n">NestedInteger</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">maxDepth</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">s</span> <span class="kt">int</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="o">*</span><span class="n">NestedInteger</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span><span class="n">NestedInteger</span><span class="p">,</span> <span class="n">d</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">maxDepth</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxDepth</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">IsInteger</span><span class="p">()</span> <span class="p">{</span>
			<span class="n">ws</span> <span class="o">+=</span> <span class="n">x</span><span class="o">.</span><span class="n">GetInteger</span><span class="p">()</span> <span class="o">*</span> <span class="n">d</span>
			<span class="n">s</span> <span class="o">+=</span> <span class="n">x</span><span class="o">.</span><span class="n">GetInteger</span><span class="p">()</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">x</span><span class="o">.</span><span class="n">GetList</span><span class="p">()</span> <span class="p">{</span>
				<span class="n">dfs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">d</span><span class="o">+</span><span class="m">1</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">nestedList</span> <span class="p">{</span>
		<span class="n">dfs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">maxDepth</span><span class="o">+</span><span class="m">1</span><span class="p">)</span><span class="o">*</span><span class="n">s</span> <span class="o">-</span> <span class="n">ws</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * class NestedInteger {
 *     If value is provided, then it holds a single integer
 *     Otherwise it holds an empty nested list
 *     constructor(value?: number) {
 *         ...
 *     };
 *
 *     Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     isInteger(): boolean {
 *         ...
 *     };
 *
 *     Return the single integer that this NestedInteger holds, if it holds a single integer
 *     Return null if this NestedInteger holds a nested list
 *     getInteger(): number | null {
 *         ...
 *     };
 *
 *     Set this NestedInteger to hold a single integer equal to value.
 *     setInteger(value: number) {
 *         ...
 *     };
 *
 *     Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
 *     add(elem: NestedInteger) {
 *         ...
 *     };
 *
 *     Return the nested list that this NestedInteger holds,
 *     or an empty list if this NestedInteger holds a single integer
 *     getList(): NestedInteger[] {
 *         ...
 *     };
 * };
 */</span>

<span class="kd">function</span> <span class="nx">depthSumInverse</span><span class="p">(</span><span class="nx">nestedList</span><span class="p">:</span> <span class="nx">NestedInteger</span><span class="p">[]):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="p">[</span><span class="nx">maxDepth</span><span class="p">,</span> <span class="nx">ws</span><span class="p">,</span> <span class="nx">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>
    <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">NestedInteger</span><span class="p">,</span> <span class="nx">d</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">maxDepth</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">maxDepth</span><span class="p">,</span> <span class="nx">d</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">())</span> <span class="p">{</span>
            <span class="nx">ws</span> <span class="o">+=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">getInteger</span><span class="p">()</span> <span class="o">*</span> <span class="nx">d</span><span class="p">;</span>
            <span class="nx">s</span> <span class="o">+=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">getInteger</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">y</span> <span class="k">of</span> <span class="nx">x</span><span class="p">.</span><span class="nx">getList</span><span class="p">())</span> <span class="p">{</span>
                <span class="nx">dfs</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">x</span> <span class="k">of</span> <span class="nx">nestedList</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">dfs</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="nx">maxDepth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nx">s</span> <span class="o">-</span> <span class="nx">ws</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-364.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
