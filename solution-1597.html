<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-1597.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-1597.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>1597 - Build Binary Expression Tree From Infix Expression</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode Question Formatted question description: https://leetcode.ca/all/1597.html A binary expression tree is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to operands (numbers), and internal...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-1597.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-1597.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-1597.html" rel="stylesheet"/>
   <link href="solution-1597.html" rel="stylesheet"/>
   <link href="solution-1597.html" rel="stylesheet"/>
   <link href="solution-1597.html" rel="stylesheet"/>
   <link href="solution-1597.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="1597 - Build Binary Expression Tree From Infix Expression" property="og:title"/>
   <meta content="Leetcode Question Formatted question description: https://leetcode.ca/all/1597.html A binary expression tree is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to operands (numbers), and internal nodes (nodes with 2 children) correspond to the operators &amp;#39;+&amp;#39; (addition), &amp;#39;-&amp;#39; (subtraction), &amp;#39;*&amp;#39; (multiplication), and &amp;#39;/&amp;#39; (division). For each internal node with operator o, the infix expression it represents is (A o B), where A is the expression the left subtree represents and B is the expression the right subtree represents. You are given a string s, an infix expression containing operands, the operators described above, and parentheses &amp;#39;(&amp;#39; and &amp;#39;)&amp;#39;. Return any valid binary expression tree, whose in-order traversal reproduces s after omitting the parenthesis from it. Please note that order of operations applies in s. That is, expressions in parentheses are evaluated first, and multiplication and division happen before addition and subtraction. Operands must also appear in the same order in both s and the in-order traversal of the tree. &amp;nbsp; Example 1: Input: s = &amp;quot;3*4-2*5&amp;quot; Output: [-,*,*,3,4,2,5] Explanation: The tree above is the only valid tree whose inorder traversal produces s. Example 2: Input: s = &amp;quot;2-3/(5*2)+1&amp;quot; Output: [+,-,1,2,/,null,null,null,null,3,*,null,null,5,2] Explanation: The inorder traversal of the tree above is 2-3/5*2+1 which is the same as s without the parenthesis. The tree also produces the correct result and its operands are in the same order as they appear in s. The tree below is also a valid binary expression tree with the same inorder traversal as s, but it not a valid answer because it does not evaluate to the same value. The third tree below is also not valid. Although it produces the same result and is equivalent to the above trees, its inorder traversal does not produce s and its operands are not in the same order as s. Example 3: Input: s = &amp;quot;1+2+3+4+5&amp;quot; Output: [+,+,5,+,4,null,null,+,3,null,null,1,2] Explanation: The tree [+,+,5,+,+,null,null,1,2,3,4] is also one of many other valid trees. &amp;nbsp; Constraints: 1 &amp;lt;= s.length &amp;lt;= 100 s consists of digits and the characters &amp;#39;+&amp;#39;, &amp;#39;-&amp;#39;, &amp;#39;*&amp;#39;, and &amp;#39;/&amp;#39;. Operands in s are exactly 1 digit. It is guaranteed that s is a valid expression. Algorithm To parse an arithmetic expression and construct a binary expression tree, you can follow these steps: Define Operator Priorities: Assign priorities to each operator: consider the left parenthesis as having a priority of 1, addition and subtraction as 2, and multiplication and division as 3. Manage Stacks for Symbols and Nodes: Use a symbol stack where operators are arranged with increasing priority from bottom to top. Also, maintain a Node stack to store the nodes of the expression tree. Traverse the Expression s: Left Parenthesis: Upon encountering a left parenthesis, push it onto the symbol stack. Number: When a number is encountered, create a new leaf node and push it onto the Node stack. Right Parenthesis: If a right parenthesis..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2020-04-14T22:21:01-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2020-04-14-1597-Build-Binary-Expression-Tree-From-Infix-Expression/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-1597.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="1597 - Build Binary Expression Tree From Infix Expression" property="twitter:title"/>
   <meta content="Leetcode Question Formatted question description: https://leetcode.ca/all/1597.html A binary expression tree is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to operands (numbers), and internal nodes (nodes with 2 children) correspond to the operators &amp;#39;+&amp;#39; (addition), &amp;#39;-&amp;#39; (subtraction), &amp;#39;*&amp;#39; (multiplication), and &amp;#39;/&amp;#39; (division). For each internal node with operator o, the infix expression it represents is (A o B), where A is the expression the left subtree represents and B is the expression the right subtree represents. You are given a string s, an infix expression containing operands, the operators described above, and parentheses &amp;#39;(&amp;#39; and &amp;#39;)&amp;#39;. Return any valid binary expression tree, whose in-order traversal reproduces s after omitting the parenthesis from it. Please note that order of operations applies in s. That is, expressions in parentheses are evaluated first, and multiplication and division happen before addition and subtraction. Operands must also appear in the same order in both s and the in-order traversal of the tree. &amp;nbsp; Example 1: Input: s = &amp;quot;3*4-2*5&amp;quot; Output: [-,*,*,3,4,2,5] Explanation: The tree above is the only valid tree whose inorder traversal produces s. Example 2: Input: s = &amp;quot;2-3/(5*2)+1&amp;quot; Output: [+,-,1,2,/,null,null,null,null,3,*,null,null,5,2] Explanation: The inorder traversal of the tree above is 2-3/5*2+1 which is the same as s without the parenthesis. The tree also produces the correct result and its operands are in the same order as they appear in s. The tree below is also a valid binary expression tree with the same inorder traversal as s, but it not a valid answer because it does not evaluate to the same value. The third tree below is also not valid. Although it produces the same result and is equivalent to the above trees, its inorder traversal does not produce s and its operands are not in the same order as s. Example 3: Input: s = &amp;quot;1+2+3+4+5&amp;quot; Output: [+,+,5,+,4,null,null,+,3,null,null,1,2] Explanation: The tree [+,+,5,+,+,null,null,1,2,3,4] is also one of many other valid trees. &amp;nbsp; Constraints: 1 &amp;lt;= s.length &amp;lt;= 100 s consists of digits and the characters &amp;#39;+&amp;#39;, &amp;#39;-&amp;#39;, &amp;#39;*&amp;#39;, and &amp;#39;/&amp;#39;. Operands in s are exactly 1 digit. It is guaranteed that s is a valid expression. Algorithm To parse an arithmetic expression and construct a binary expression tree, you can follow these steps: Define Operator Priorities: Assign priorities to each operator: consider the left parenthesis as having a priority of 1, addition and subtraction as 2, and multiplication and division as 3. Manage Stacks for Symbols and Nodes: Use a symbol stack where operators are arranged with increasing priority from bottom to top. Also, maintain a Node stack to store the nodes of the expression tree. Traverse the Expression s: Left Parenthesis: Upon encountering a left parenthesis, push it onto the symbol stack. Number: When a number is encountered, create a new leaf node and push it onto the Node stack. Right Parenthesis: If a right parenthesis..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    1597 - Build Binary Expression Tree From Infix Expression | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="1597 - Build Binary Expression Tree From Infix Expression" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-1597.html" rel="canonical">
          <meta content="https://leetcode.ca/2020-04-14-1597-Build-Binary-Expression-Tree-From-Infix-Expression/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2020-04-14T22:21:01-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"1597 - Build Binary Expression Tree From Infix Expression","dateModified":"2020-04-14T22:21:01-07:00","datePublished":"2020-04-14T22:21:01-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2020-04-14-1597-Build-Binary-Expression-Tree-From-Infix-Expression/"},"url":"https://leetcode.ca/2020-04-14-1597-Build-Binary-Expression-Tree-From-Infix-Expression/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="question">
       Question
      </h1>
      <p>
       Formatted question description:
       <a href="solution-1597.html">
        https://leetcode.ca/all/1597.html
       </a>
      </p>
      <p>
       A
       <strong>
        <a href="solution-1597.html" target="_blank">
         binary expression tree
        </a>
       </strong>
       is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to operands (numbers), and internal nodes (nodes with 2 children) correspond to the operators
       <code>
        '+'
       </code>
       (addition),
       <code>
        '-'
       </code>
       (subtraction),
       <code>
        '*'
       </code>
       (multiplication), and
       <code>
        '/'
       </code>
       (division).
      </p>
      <p>
       For each internal node with operator
       <code>
        o
       </code>
       , the
       <a href="solution-1597.html" target="_blank">
        <strong>
         infix expression
        </strong>
       </a>
       it represents is
       <code>
        (A o B)
       </code>
       , where
       <code>
        A
       </code>
       is the expression the left subtree represents and
       <code>
        B
       </code>
       is the expression the right subtree represents.
      </p>
      <p>
       You are given a string
       <code>
        s
       </code>
       , an
       <strong>
        infix expression
       </strong>
       containing operands, the operators described above, and parentheses
       <code>
        '('
       </code>
       and
       <code>
        ')'
       </code>
       .
      </p>
      <p>
       Return
       <em>
        any valid
        <strong>
         binary expression tree
        </strong>
        , whose
        <strong>
         <a href="solution-1597.html" target="_blank">
          in-order traversal
         </a>
        </strong>
        reproduces
       </em>
       <code>
        s
       </code>
       <em>
        after omitting the parenthesis from it.
       </em>
      </p>
      <p>
       <strong>
        Please note that order of operations applies in
       </strong>
       <code>
        s
       </code>
       <strong>
        .
       </strong>
       That is, expressions in parentheses are evaluated first, and multiplication and division happen before addition and subtraction.
      </p>
      <p>
       Operands must also appear in the
       <strong>
        same order
       </strong>
       in both
       <code>
        s
       </code>
       and the in-order traversal of the tree.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1597.Build%20Binary%20Expression%20Tree%20From%20Infix%20Expression/images/ex1-4.png" style="width: 250px; height: 161px;"/>
      </p>
      <pre>
<strong>Input:</strong> s = "3*4-2*5"
<strong>Output:</strong> [-,*,*,3,4,2,5]
<strong>Explanation:</strong> The tree above is the only valid tree whose inorder traversal produces s.
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1597.Build%20Binary%20Expression%20Tree%20From%20Infix%20Expression/images/ex1-2.png" style="width: 150px; height: 210px;"/>
      </p>
      <pre>
<strong>Input:</strong> s = "2-3/(5*2)+1"
<strong>Output:</strong> [+,-,1,2,/,null,null,null,null,3,*,null,null,5,2]
<strong>Explanation:</strong> The inorder traversal of the tree above is 2-3/5*2+1 which is the same as s without the parenthesis. The tree also produces the correct result and its operands are in the same order as they appear in s.
The tree below is also a valid binary expression tree with the same inorder traversal as s, but it not a valid answer because it does not evaluate to the same value.
<img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1597.Build%20Binary%20Expression%20Tree%20From%20Infix%20Expression/images/ex1-1.png" style="width: 201px; height: 281px;"/>
The third tree below is also not valid. Although it produces the same result and is equivalent to the above trees, its inorder traversal does not produce s and its operands are not in the same order as s.
<img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1597.Build%20Binary%20Expression%20Tree%20From%20Infix%20Expression/images/ex1-3.png" style="width: 281px; height: 281px;"/>
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> s = "1+2+3+4+5"
<strong>Output:</strong> [+,+,5,+,4,null,null,+,3,null,null,1,2]
<strong>Explanation:</strong> The tree [+,+,5,+,+,null,null,1,2,3,4] is also one of many other valid trees.
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= s.length &lt;= 100
        </code>
       </li>
       <li>
        <code>
         s
        </code>
        consists of digits and the characters
        <code>
         '+'
        </code>
        ,
        <code>
         '-'
        </code>
        ,
        <code>
         '*'
        </code>
        , and
        <code>
         '/'
        </code>
        .
       </li>
       <li>
        Operands in
        <code>
         s
        </code>
        are
        <strong>
         exactly
        </strong>
        1 digit.
       </li>
       <li>
        It is guaranteed that
        <code>
         s
        </code>
        is a valid expression.
       </li>
      </ul>
      <h1 id="algorithm">
       Algorithm
      </h1>
      <p>
       To parse an arithmetic expression and construct a binary expression tree, you can follow these steps:
      </p>
      <ol>
       <li>
        <strong>
         Define Operator Priorities:
        </strong>
        <ul>
         <li>
          Assign priorities to each operator: consider the left parenthesis as having a priority of
          <code class="language-plaintext highlighter-rouge">
           1
          </code>
          , addition and subtraction as
          <code class="language-plaintext highlighter-rouge">
           2
          </code>
          , and multiplication and division as
          <code class="language-plaintext highlighter-rouge">
           3
          </code>
          .
         </li>
        </ul>
       </li>
       <li>
        <strong>
         Manage Stacks for Symbols and Nodes:
        </strong>
        <ul>
         <li>
          Use a symbol stack where operators are arranged with increasing priority from bottom to top. Also, maintain a
          <code class="language-plaintext highlighter-rouge">
           Node
          </code>
          stack to store the nodes of the expression tree.
         </li>
        </ul>
       </li>
       <li>
        <strong>
         Traverse the Expression
         <code class="language-plaintext highlighter-rouge">
          s
         </code>
         :
        </strong>
        <ul>
         <li>
          <strong>
           Left Parenthesis:
          </strong>
          Upon encountering a left parenthesis, push it onto the symbol stack.
         </li>
         <li>
          <strong>
           Number:
          </strong>
          When a number is encountered, create a new leaf node and push it onto the Node stack.
         </li>
         <li>
          <strong>
           Right Parenthesis:
          </strong>
          If a right parenthesis is encountered, check the symbol stackâs top for a left parenthesis. If you find a different operator, perform the following:
          <ul>
           <li>
            Pop two nodes from the Node stack, assigning them as right and left children (note: the right child is popped first).
           </li>
           <li>
            Pop an operator from the symbol stack to use as the treeâs root.
           </li>
           <li>
            Connect the children to the root, and then push the root onto the Node stack.
           </li>
           <li>
            Continue this process until a left parenthesis is found and popped.
           </li>
          </ul>
         </li>
         <li>
          <strong>
           Operator Encounter:
          </strong>
          If you encounter an operator, compare its priority with that of the operator at the top of the symbol stack. If the stackâs operator has higher or equal priority:
          <ul>
           <li>
            Pop two nodes for the children and an operator for the root as described above, then connect and push back the root.
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <strong>
         Finalize the Tree:
        </strong>
        <ul>
         <li>
          If the Node stack has more than one node, continue the pop and connect operations until only one node remains, which will be the tree root.
         </li>
        </ul>
       </li>
      </ol>
      <p>
       The remaining node in the Node stack is the root of the expression tree.
      </p>
      <h1 id="code">
       Code
      </h1>
      <ul class="uk-tab" data-uk-switcher="{connect:'#8f91e5d2-9ec3-4dfc-9a32-1f391e5e937c'}">
       <li class="uk-active">
        <a href="solution-1597.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-1597.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-1597.html">
         Python
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="8f91e5d2-9ec3-4dfc-9a32-1f391e5e937c">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Build_Binary_Expression_Tree_From_Infix_Expression</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">prio</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">expTree</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>

            <span class="n">prio</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'('</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">prio</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'+'</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
            <span class="n">prio</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'-'</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
            <span class="n">prio</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'*'</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
            <span class="n">prio</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'/'</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>

            <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">ops</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
            <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">'('</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">ops</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">ch</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">ch</span><span class="o">));</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">')'</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">while</span> <span class="o">(</span><span class="n">ops</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">!=</span> <span class="sc">'('</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">combine</span><span class="o">(</span><span class="n">ops</span><span class="o">,</span> <span class="n">stack</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="c1">// pop left '('</span>
                    <span class="n">ops</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// @note: must be &gt;=, for test case "1+2+3+4+5"</span>
                    <span class="k">while</span> <span class="o">(!</span><span class="n">ops</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">prio</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ops</span><span class="o">.</span><span class="na">peek</span><span class="o">())</span> <span class="o">&gt;=</span> <span class="n">prio</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ch</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">combine</span><span class="o">(</span><span class="n">ops</span><span class="o">,</span> <span class="n">stack</span><span class="o">);</span>
                    <span class="o">}</span>

                    <span class="n">ops</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">while</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">combine</span><span class="o">(</span><span class="n">ops</span><span class="o">,</span> <span class="n">stack</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="kd">private</span> <span class="kt">void</span> <span class="nf">combine</span><span class="o">(</span><span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">ops</span><span class="o">,</span> <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Node</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">ops</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
            <span class="c1">// right first, then left</span>
            <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>

            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">val</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">char</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">expTree</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">nodes</span><span class="p">;</span>  <span class="c1">// Stores nodes (new Node(val))</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">ops</span><span class="p">;</span>     <span class="c1">// Stores operators and parentheses</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">nodes</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ops</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">')'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">ops</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">'('</span><span class="p">)</span>
          <span class="n">nodes</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">buildNode</span><span class="p">(</span><span class="n">pop</span><span class="p">(</span><span class="n">ops</span><span class="p">),</span> <span class="n">pop</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">pop</span><span class="p">(</span><span class="n">nodes</span><span class="p">)));</span>
        <span class="n">ops</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>  <span class="c1">// Remove '('</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'+'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'-'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'*'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'/'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ops</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">compare</span><span class="p">(</span><span class="n">ops</span><span class="p">.</span><span class="n">top</span><span class="p">(),</span> <span class="n">c</span><span class="p">))</span>
          <span class="n">nodes</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">buildNode</span><span class="p">(</span><span class="n">pop</span><span class="p">(</span><span class="n">ops</span><span class="p">),</span> <span class="n">pop</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">pop</span><span class="p">(</span><span class="n">nodes</span><span class="p">)));</span>
        <span class="n">ops</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
      <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ops</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
      <span class="n">nodes</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">buildNode</span><span class="p">(</span><span class="n">pop</span><span class="p">(</span><span class="n">ops</span><span class="p">),</span> <span class="n">pop</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">pop</span><span class="p">(</span><span class="n">nodes</span><span class="p">)));</span>

    <span class="k">return</span> <span class="n">nodes</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">buildNode</span><span class="p">(</span><span class="kt">char</span> <span class="n">op</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">right</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">left</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Returns true if op1 is a operator and priority(op1) &gt;= priority(op2)</span>
  <span class="kt">bool</span> <span class="n">compare</span><span class="p">(</span><span class="kt">char</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">char</span> <span class="n">op2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">op1</span> <span class="o">==</span> <span class="sc">'('</span> <span class="o">||</span> <span class="n">op1</span> <span class="o">==</span> <span class="sc">')'</span><span class="p">)</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">op1</span> <span class="o">==</span> <span class="sc">'*'</span> <span class="o">||</span> <span class="n">op1</span> <span class="o">==</span> <span class="sc">'/'</span> <span class="o">||</span> <span class="n">op2</span> <span class="o">==</span> <span class="sc">'+'</span> <span class="o">||</span> <span class="n">op2</span> <span class="o">==</span> <span class="sc">'-'</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">char</span> <span class="n">pop</span><span class="p">(</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&amp;</span> <span class="n">ops</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="n">op</span> <span class="o">=</span> <span class="n">ops</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
    <span class="n">ops</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">op</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Node</span><span class="o">*</span> <span class="n">pop</span><span class="p">(</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;&amp;</span> <span class="n">nodes</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
    <span class="n">nodes</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-python highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="s">'''
1. é¢ç®ä¿¡æ¯ï¼æ°å­åªæä¸ä½æ°
2. charç´æ¥ænodeãè¿ç®ç¬¦æåcombine()åænode
'''</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">'('</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s">'+'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="s">'-'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="s">'*'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
            <span class="s">'/'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">expTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s">'Node'</span><span class="p">:</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># not Node yet
</span>        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># already Node
</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">'('</span><span class="p">:</span>
                <span class="n">ops</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ch</span><span class="p">.</span><span class="n">isdigit</span><span class="p">():</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span> <span class="c1"># assumption: only single digit for each node
</span>            <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">')'</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">ops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'('</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">combine</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>
                <span class="n">ops</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># pop left '('
</span>            <span class="k">else</span><span class="p">:</span> <span class="c1"># then operator
</span>                <span class="c1"># @note: must be &gt;=, for test case "1+2+3+4+5"
</span>                <span class="k">while</span> <span class="n">ops</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">priority</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="p">.</span><span class="n">priority</span><span class="p">[</span><span class="n">ch</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">combine</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>

                <span class="n">ops</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># eg input, '1+2'
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">combine</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">stack</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">ops</span><span class="p">.</span><span class="n">pop</span><span class="p">())</span>
        <span class="c1"># right first, then left, since it's a stack
</span>        <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>

<span class="c1">################
</span>
<span class="s">'''
The solution uses two main functions: buildTree and infixToPostfix.
* The buildTree function takes an infix expression as input, converts it to postfix using the infixToPostfix function, and then builds the binary expression tree using a stack.
* The infixToPostfix function converts the infix expression to postfix using the shunting yard algorithm.

The TreeNode class is defined to represent nodes in the binary expression tree. Each node has a value, left child, and right child. The precedence dictionary is used to determine the precedence of operators in the expression.

'''</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="s">''</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">precedence</span> <span class="o">=</span> <span class="p">{</span><span class="s">'+'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'-'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'*'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'/'</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">buildTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
        <span class="n">postfix</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">infixToPostfix</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">postfix</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span><span class="p">.</span><span class="n">isdigit</span><span class="p">():</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="c1"># converts infix to postfix
</span>    <span class="k">def</span> <span class="nf">infixToPostfix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">):</span>
        <span class="n">postfix</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">operator_stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">expression</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">isdigit</span><span class="p">():</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span> <span class="ow">and</span> <span class="n">expression</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">isdigit</span><span class="p">():</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">postfix</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">expression</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">elif</span> <span class="n">expression</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">precedence</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">operator_stack</span> <span class="ow">and</span> <span class="n">operator_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'('</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">precedence</span><span class="p">[</span><span class="n">operator_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="p">.</span><span class="n">precedence</span><span class="p">[</span><span class="n">expression</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                    <span class="n">postfix</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">operator_stack</span><span class="p">.</span><span class="n">pop</span><span class="p">())</span>
                <span class="n">operator_stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">expression</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">expression</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">'('</span><span class="p">:</span>
                <span class="n">operator_stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">expression</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">expression</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">')'</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">operator_stack</span> <span class="ow">and</span> <span class="n">operator_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'('</span><span class="p">:</span>
                    <span class="n">postfix</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">operator_stack</span><span class="p">.</span><span class="n">pop</span><span class="p">())</span>
                <span class="n">operator_stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">operator_stack</span><span class="p">:</span>
            <span class="n">postfix</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">operator_stack</span><span class="p">.</span><span class="n">pop</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">postfix</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-1597.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
