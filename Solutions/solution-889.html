<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-889.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-889.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>889 - Construct Binary Tree from Preorder and Postorder Traversal</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode Formatted question description: https://leetcode.ca/all/889.html 889. Construct Binary Tree from Preorder and Postorder Traversal Level Medium Description Return any binary tree that matches the given preorder and postorder traversals. Values in the traversals pre and post are distinct positive integers. Example 1: Input: pre = [1,2,4,5,3,6,7],...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-889.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-889.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-889.html" rel="stylesheet"/>
   <link href="solution-889.html" rel="stylesheet"/>
   <link href="solution-889.html" rel="stylesheet"/>
   <link href="solution-889.html" rel="stylesheet"/>
   <link href="solution-889.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="889 - Construct Binary Tree from Preorder and Postorder Traversal" property="og:title"/>
   <meta content='Leetcode Formatted question description: https://leetcode.ca/all/889.html 889. Construct Binary Tree from Preorder and Postorder Traversal Level Medium Description Return any binary tree that matches the given preorder and postorder traversals. Values in the traversals pre and post are distinct positive integers. Example 1: Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1] Output: [1,2,3,4,5,6,7] Note: 1 &amp;lt;= pre.length == post.length &amp;lt;= 30 pre[] and post[] are both permutations of 1, 2, ..., pre.length. It is guaranteed an answer exists. If there exists multiple answers, you can return any of them. Solution The preorder traversal visits the binary tree in such an order: root, left subtree, and right subtree. For each subtree, the nodes are also visited in the order of preorder traversal. The postorder traversal visits the binary tree in such an order: left subtree, right subtree, and root. For each subtree, the nodes are also visited in the order of postorder traversal. This problem can be solved using recursion. Base cases are when the number of nodes is 0 or 1. If the number of nodes is 0, then return null. If the number of nodes is 1, then create the root using the value of the node, and return the root. If the number of nodes is greater than 1, suppose the left child always exist. The element pre[1] is the value of the left child of the root. Find the value pre[1] in post, which is the last node to be visited in the left subtree in postorder traversal, and the number of nodes in the left subtree can be obtained. The number of nodes in the right subtree can be obtained as well. Then use the subarrays of pre and post to create the left subtree and the right subtree respectively. Finally, return the root. Java C++ Python Go TypeScript public class Construct_Binary_Tree_from_Preorder_and_Postorder_Traversal { /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { /* preorder -&amp;gt; [1] [2,4,5] [3,6,7] postorder -&amp;gt; [4,5,2] [6,7,3] [root] */ public TreeNode constructFromPrePost(int[] pre, int[] post) { return helper(pre, 0, pre.length - 1, post, 0, post.length - 1); } // preL å preR åå«è¡¨ç¤ºå·¦å­æ åºé´çå¼å¤´åç»å°¾ä½ç½® // postL å postR è¡¨ç¤ºå³å­æ åºé´çå¼å¤´åç»å°¾ä½ç½® TreeNode helper(int[] pre, int preL, int preR, int[] post, int postL, int postR) { if (preL &amp;gt; preR || postL &amp;gt; postR) { return null; } // root node TreeNode node = new TreeNode(pre[preL]); if (preL == preR) { // leaf node return node; } // æ¾å·¦å­æ çæ ¹ç»ç¹(pre[preL + 1) å¨ post[] ä¸­çä½ç½® // pre[preL + 1 here "+1" to skip above root node int idx = -1; for (idx = postL; idx &amp;lt;= postR; ++idx) { if (pre[preL + 1] == post[idx]) { break; } } // left sub tree length: (idx - postL) // right sub tree length: node.left = helper(pre, preL + 1, preL + 1 + (idx - postL), post, postL,...' property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2018-05-07T22:21:01-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2018-05-07-889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-889.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="889 - Construct Binary Tree from Preorder and Postorder Traversal" property="twitter:title"/>
   <meta content='Leetcode Formatted question description: https://leetcode.ca/all/889.html 889. Construct Binary Tree from Preorder and Postorder Traversal Level Medium Description Return any binary tree that matches the given preorder and postorder traversals. Values in the traversals pre and post are distinct positive integers. Example 1: Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1] Output: [1,2,3,4,5,6,7] Note: 1 &amp;lt;= pre.length == post.length &amp;lt;= 30 pre[] and post[] are both permutations of 1, 2, ..., pre.length. It is guaranteed an answer exists. If there exists multiple answers, you can return any of them. Solution The preorder traversal visits the binary tree in such an order: root, left subtree, and right subtree. For each subtree, the nodes are also visited in the order of preorder traversal. The postorder traversal visits the binary tree in such an order: left subtree, right subtree, and root. For each subtree, the nodes are also visited in the order of postorder traversal. This problem can be solved using recursion. Base cases are when the number of nodes is 0 or 1. If the number of nodes is 0, then return null. If the number of nodes is 1, then create the root using the value of the node, and return the root. If the number of nodes is greater than 1, suppose the left child always exist. The element pre[1] is the value of the left child of the root. Find the value pre[1] in post, which is the last node to be visited in the left subtree in postorder traversal, and the number of nodes in the left subtree can be obtained. The number of nodes in the right subtree can be obtained as well. Then use the subarrays of pre and post to create the left subtree and the right subtree respectively. Finally, return the root. Java C++ Python Go TypeScript public class Construct_Binary_Tree_from_Preorder_and_Postorder_Traversal { /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { /* preorder -&amp;gt; [1] [2,4,5] [3,6,7] postorder -&amp;gt; [4,5,2] [6,7,3] [root] */ public TreeNode constructFromPrePost(int[] pre, int[] post) { return helper(pre, 0, pre.length - 1, post, 0, post.length - 1); } // preL å preR åå«è¡¨ç¤ºå·¦å­æ åºé´çå¼å¤´åç»å°¾ä½ç½® // postL å postR è¡¨ç¤ºå³å­æ åºé´çå¼å¤´åç»å°¾ä½ç½® TreeNode helper(int[] pre, int preL, int preR, int[] post, int postL, int postR) { if (preL &amp;gt; preR || postL &amp;gt; postR) { return null; } // root node TreeNode node = new TreeNode(pre[preL]); if (preL == preR) { // leaf node return node; } // æ¾å·¦å­æ çæ ¹ç»ç¹(pre[preL + 1) å¨ post[] ä¸­çä½ç½® // pre[preL + 1 here "+1" to skip above root node int idx = -1; for (idx = postL; idx &amp;lt;= postR; ++idx) { if (pre[preL + 1] == post[idx]) { break; } } // left sub tree length: (idx - postL) // right sub tree length: node.left = helper(pre, preL + 1, preL + 1 + (idx - postL), post, postL,...' property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    889 - Construct Binary Tree from Preorder and Postorder Traversal | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="889 - Construct Binary Tree from Preorder and Postorder Traversal" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-889.html" rel="canonical">
          <meta content="https://leetcode.ca/2018-05-07-889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2018-05-07T22:21:01-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"889 - Construct Binary Tree from Preorder and Postorder Traversal","dateModified":"2018-05-07T22:21:01-07:00","datePublished":"2018-05-07T22:21:01-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2018-05-07-889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal/"},"url":"https://leetcode.ca/2018-05-07-889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <p>
       Formatted question description:
       <a href="solution-889.html">
        https://leetcode.ca/all/889.html
       </a>
      </p>
      <h1 id="889-construct-binary-tree-from-preorder-and-postorder-traversal">
       889. Construct Binary Tree from Preorder and Postorder Traversal
      </h1>
      <h2 id="level">
       Level
      </h2>
      <p>
       Medium
      </p>
      <h2 id="description">
       Description
      </h2>
      <p>
       Return any binary tree that matches the given preorder and postorder traversals.
      </p>
      <p>
       Values in the traversals
       <code class="language-plaintext highlighter-rouge">
        pre
       </code>
       and
       <code class="language-plaintext highlighter-rouge">
        post
       </code>
       are distinct positive integers.
      </p>
      <p>
       <strong>
        Example 1:
       </strong>
      </p>
      <p>
       <strong>
        Input:
       </strong>
       pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]
      </p>
      <p>
       <strong>
        Output:
       </strong>
       [1,2,3,4,5,6,7]
      </p>
      <p>
       <strong>
        Note:
       </strong>
      </p>
      <ul>
       <li>
        <code class="language-plaintext highlighter-rouge">
         1 &lt;= pre.length == post.length &lt;= 30
        </code>
       </li>
       <li>
        <code class="language-plaintext highlighter-rouge">
         pre[]
        </code>
        and
        <code class="language-plaintext highlighter-rouge">
         post[]
        </code>
        are both permutations of
        <code class="language-plaintext highlighter-rouge">
         1, 2, ..., pre.length
        </code>
        .
       </li>
       <li>
        It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.
       </li>
      </ul>
      <h2 id="solution">
       Solution
      </h2>
      <p>
       The preorder traversal visits the binary tree in such an order: root, left subtree, and right subtree. For each subtree, the nodes are also visited in the order of preorder traversal.
      </p>
      <p>
       The postorder traversal visits the binary tree in such an order: left subtree, right subtree, and root. For each subtree, the nodes are also visited in the order of postorder traversal.
      </p>
      <p>
       This problem can be solved using recursion. Base cases are when the number of nodes is 0 or 1. If the number of nodes is 0, then return
       <code class="language-plaintext highlighter-rouge">
        null
       </code>
       . If the number of nodes is 1, then create the root using the value of the node, and return the root.
      </p>
      <p>
       If the number of nodes is greater than 1, suppose the left child always exist. The element
       <code class="language-plaintext highlighter-rouge">
        pre[1]
       </code>
       is the value of the left child of the root. Find the value
       <code class="language-plaintext highlighter-rouge">
        pre[1]
       </code>
       in
       <code class="language-plaintext highlighter-rouge">
        post
       </code>
       , which is the last node to be visited in the left subtree in postorder traversal, and the number of nodes in the left subtree can be obtained. The number of nodes in the right subtree can be obtained as well. Then use the subarrays of
       <code class="language-plaintext highlighter-rouge">
        pre
       </code>
       and
       <code class="language-plaintext highlighter-rouge">
        post
       </code>
       to create the left subtree and the right subtree respectively. Finally, return the root.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#f299fd4d-8a68-469d-aece-4f0a76edfce4'}">
       <li class="uk-active">
        <a href="solution-889.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-889.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-889.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-889.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-889.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="f299fd4d-8a68-469d-aece-4f0a76edfce4">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Construct_Binary_Tree_from_Preorder_and_Postorder_Traversal</span> <span class="o">{</span>
    <span class="cm">/**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode(int x) { val = x; }
     * }
     */</span>

    <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

        <span class="cm">/*
            preorder -&gt; [1] [2,4,5] [3,6,7]
            postorder -&gt; [4,5,2] [6,7,3] [root]
         */</span>
        <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">constructFromPrePost</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">pre</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">post</span><span class="o">)</span> <span class="o">{</span>

            <span class="k">return</span> <span class="nf">helper</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">pre</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">post</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">post</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// preL å preR åå«è¡¨ç¤ºå·¦å­æ åºé´çå¼å¤´åç»å°¾ä½ç½®</span>
        <span class="c1">// postL å postR è¡¨ç¤ºå³å­æ åºé´çå¼å¤´åç»å°¾ä½ç½®</span>
        <span class="nc">TreeNode</span> <span class="nf">helper</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">pre</span><span class="o">,</span> <span class="kt">int</span> <span class="n">preL</span><span class="o">,</span> <span class="kt">int</span> <span class="n">preR</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">post</span><span class="o">,</span> <span class="kt">int</span> <span class="n">postL</span><span class="o">,</span> <span class="kt">int</span> <span class="n">postR</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">preL</span> <span class="o">&gt;</span> <span class="n">preR</span> <span class="o">||</span> <span class="n">postL</span> <span class="o">&gt;</span> <span class="n">postR</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// root node</span>
            <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">pre</span><span class="o">[</span><span class="n">preL</span><span class="o">]);</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">preL</span> <span class="o">==</span> <span class="n">preR</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// leaf node</span>
                <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// æ¾å·¦å­æ çæ ¹ç»ç¹(pre[preL + 1)  å¨ post[] ä¸­çä½ç½®</span>
            <span class="c1">// pre[preL + 1 here "+1" to skip above root node</span>
            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">idx</span> <span class="o">=</span> <span class="n">postL</span><span class="o">;</span> <span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">postR</span><span class="o">;</span> <span class="o">++</span><span class="n">idx</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">pre</span><span class="o">[</span><span class="n">preL</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">post</span><span class="o">[</span><span class="n">idx</span><span class="o">])</span> <span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// left sub tree length: (idx - postL)</span>
            <span class="c1">// right sub tree length:</span>
            <span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">helper</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="n">preL</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">preL</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">(</span><span class="n">idx</span> <span class="o">-</span> <span class="n">postL</span><span class="o">),</span> <span class="n">post</span><span class="o">,</span> <span class="n">postL</span><span class="o">,</span> <span class="n">idx</span><span class="o">);</span>
            <span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">helper</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="n">preL</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">(</span><span class="n">idx</span> <span class="o">-</span> <span class="n">postL</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">preR</span><span class="o">,</span> <span class="n">post</span><span class="o">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">postR</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// postR - 1 to skip root</span>

            <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">//////</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">constructFromPrePost</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">pre</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">post</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">TreeNode</span><span class="o">(</span><span class="n">pre</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="nc">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">pre</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
            <span class="kt">int</span> <span class="n">leftChild</span> <span class="o">=</span> <span class="n">pre</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">leftCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">post</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">leftChild</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">leftCount</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">constructFromPrePost</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">leftCount</span><span class="o">),</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">post</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">leftCount</span><span class="o">));</span>
            <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">constructFromPrePost</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">leftCount</span><span class="o">,</span> <span class="n">length</span><span class="o">),</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">post</span><span class="o">,</span> <span class="n">leftCount</span><span class="o">,</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1">// OJ: https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/</span>
<span class="c1">// Time: O(N^2)</span>
<span class="c1">// Space: O(N)</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">construct</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">pre</span><span class="p">,</span> <span class="kt">int</span> <span class="n">preBegin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">preEnd</span><span class="p">,</span>
                       <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">post</span><span class="p">,</span> <span class="kt">int</span> <span class="n">postBegin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">postEnd</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">preBegin</span> <span class="o">&gt;=</span> <span class="n">preEnd</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="n">preBegin</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">preBegin</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">preEnd</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">leftVal</span> <span class="o">=</span> <span class="n">pre</span><span class="p">[</span><span class="n">preBegin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">postMid</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">postBegin</span><span class="p">,</span> <span class="n">post</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">postEnd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">leftVal</span><span class="p">)</span> <span class="o">-</span> <span class="n">post</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
            <span class="kt">int</span> <span class="n">postLeftLength</span> <span class="o">=</span> <span class="n">postMid</span> <span class="o">-</span> <span class="n">postBegin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">construct</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">preBegin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">preBegin</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">postLeftLength</span><span class="p">,</span>
                                   <span class="n">post</span><span class="p">,</span> <span class="n">postBegin</span><span class="p">,</span> <span class="n">postMid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">construct</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">preBegin</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">postLeftLength</span><span class="p">,</span> <span class="n">preEnd</span><span class="p">,</span>
                                   <span class="n">post</span><span class="p">,</span> <span class="n">postMid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">postEnd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">constructFromPrePost</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">pre</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">post</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">construct</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pre</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">post</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">post</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-python highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
</span>
<span class="s">'''
&gt;&gt;&gt; a = [1,2,3,4,5]
&gt;&gt;&gt; a[0:2]
[1, 2]

so right index is exclusive
'''</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">constructFromPrePost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">post</span><span class="p">):</span>
        <span class="s">"""
        :type pre: List[int]
        :type post: List[int]
        :rtype: TreeNode
        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pre</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">post</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">pre</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">post</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">constructFromPrePost</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">idx</span><span class="p">],</span> <span class="n">post</span><span class="p">[:</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">constructFromPrePost</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="n">idx</span><span class="p">:],</span> <span class="n">post</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">root</span>

<span class="c1">############
</span>
<span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">constructFromPrePost</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">preorder</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">postorder</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">preorder</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">postorder</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">preorder</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">constructFromPrePost</span><span class="p">(</span>
                    <span class="n">preorder</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">postorder</span><span class="p">[:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">constructFromPrePost</span><span class="p">(</span>
                    <span class="n">preorder</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:],</span> <span class="n">postorder</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">root</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */</span>
<span class="k">func</span> <span class="n">constructFromPrePost</span><span class="p">(</span><span class="n">preorder</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">postorder</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">TreeNode</span> <span class="p">{</span>
	<span class="n">postMap</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">postorder</span> <span class="p">{</span>
		<span class="n">postMap</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
	<span class="p">}</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="n">prel</span><span class="p">,</span> <span class="n">prer</span><span class="p">,</span> <span class="n">postl</span><span class="p">,</span> <span class="n">postr</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">TreeNode</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">prel</span><span class="p">,</span> <span class="n">prer</span><span class="p">,</span> <span class="n">postl</span><span class="p">,</span> <span class="n">postr</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">TreeNode</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">prel</span> <span class="o">&gt;</span> <span class="n">prer</span> <span class="p">{</span>
			<span class="k">return</span> <span class="no">nil</span>
		<span class="p">}</span>
		<span class="n">root</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">TreeNode</span><span class="p">{</span><span class="n">Val</span><span class="o">:</span> <span class="n">preorder</span><span class="p">[</span><span class="n">prel</span><span class="p">]}</span>
		<span class="k">if</span> <span class="n">prel</span> <span class="o">==</span> <span class="n">prer</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">root</span>
		<span class="p">}</span>
		<span class="n">leftRootIndex</span> <span class="o">:=</span> <span class="n">postMap</span><span class="p">[</span><span class="n">preorder</span><span class="p">[</span><span class="n">prel</span><span class="o">+</span><span class="m">1</span><span class="p">]]</span>
		<span class="n">leftLength</span> <span class="o">:=</span> <span class="n">leftRootIndex</span> <span class="o">-</span> <span class="n">postl</span> <span class="o">+</span> <span class="m">1</span>
		<span class="n">root</span><span class="o">.</span><span class="n">Left</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">prel</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">prel</span><span class="o">+</span><span class="n">leftLength</span><span class="p">,</span> <span class="n">postl</span><span class="p">,</span> <span class="n">leftRootIndex</span><span class="p">)</span>
		<span class="n">root</span><span class="o">.</span><span class="n">Right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">prel</span><span class="o">+</span><span class="n">leftLength</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">prer</span><span class="p">,</span> <span class="n">leftRootIndex</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">postr</span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">root</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">preorder</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">postorder</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>

<span class="kd">function</span> <span class="nx">constructFromPrePost</span><span class="p">(</span><span class="nx">preorder</span><span class="p">:</span> <span class="kr">number</span><span class="p">[],</span> <span class="nx">postorder</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]):</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">pos</span><span class="p">:</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="kr">number</span><span class="p">,</span> <span class="kr">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">postorder</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">pos</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">postorder</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">c</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">d</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">a</span> <span class="o">&gt;</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kd">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TreeNode</span><span class="p">(</span><span class="nx">preorder</span><span class="p">[</span><span class="nx">a</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">a</span> <span class="o">===</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">root</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kd">const</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">pos</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">preorder</span><span class="p">[</span><span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span><span class="o">!</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">-</span> <span class="nx">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">root</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
        <span class="nx">root</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">root</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-889.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
