<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-642.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-642.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>642 - Design Search Autocomplete System</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 642. Design Search Autocomplete System Description Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character &amp;#39;#&amp;#39;). You are given a string array sentences and an integer array times both of...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-642.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-642.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-642.html" rel="stylesheet"/>
   <link href="solution-642.html" rel="stylesheet"/>
   <link href="solution-642.html" rel="stylesheet"/>
   <link href="solution-642.html" rel="stylesheet"/>
   <link href="solution-642.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="642 - Design Search Autocomplete System" property="og:title"/>
   <meta content="Leetcode 642. Design Search Autocomplete System Description Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character &amp;#39;#&amp;#39;). You are given a string array sentences and an integer array times both of length n where sentences[i] is a previously typed sentence and times[i] is the corresponding number of times the sentence was typed. For each input character except &amp;#39;#&amp;#39;, return the top 3 historical hot sentences that have the same prefix as the part of the sentence already typed. Here are the specific rules: The hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before. The returned top 3 hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same hot degree, use ASCII-code order (smaller one appears first). If less than 3 hot sentences exist, return as many as you can. When the input is a special character, it means the sentence ends, and in this case, you need to return an empty list. Implement the AutocompleteSystem class: AutocompleteSystem(String[] sentences, int[] times) Initializes the object with the sentences and times arrays. List&amp;lt;String&amp;gt; input(char c) This indicates that the user typed the character c. Returns an empty array [] if c == &amp;#39;#&amp;#39; and stores the inputted sentence in the system. Returns the top 3 historical hot sentences that have the same prefix as the part of the sentence already typed. If there are fewer than 3 matches, return them all. &amp;nbsp; Example 1: Input [&amp;quot;AutocompleteSystem&amp;quot;, &amp;quot;input&amp;quot;, &amp;quot;input&amp;quot;, &amp;quot;input&amp;quot;, &amp;quot;input&amp;quot;] [[[&amp;quot;i love you&amp;quot;, &amp;quot;island&amp;quot;, &amp;quot;iroman&amp;quot;, &amp;quot;i love leetcode&amp;quot;], [5, 3, 2, 2]], [&amp;quot;i&amp;quot;], [&amp;quot; &amp;quot;], [&amp;quot;a&amp;quot;], [&amp;quot;#&amp;quot;]] Output [null, [&amp;quot;i love you&amp;quot;, &amp;quot;island&amp;quot;, &amp;quot;i love leetcode&amp;quot;], [&amp;quot;i love you&amp;quot;, &amp;quot;i love leetcode&amp;quot;], [], []] Explanation AutocompleteSystem obj = new AutocompleteSystem([&amp;quot;i love you&amp;quot;, &amp;quot;island&amp;quot;, &amp;quot;iroman&amp;quot;, &amp;quot;i love leetcode&amp;quot;], [5, 3, 2, 2]); obj.input(&amp;quot;i&amp;quot;); // return [&amp;quot;i love you&amp;quot;, &amp;quot;island&amp;quot;, &amp;quot;i love leetcode&amp;quot;]. There are four sentences that have prefix &amp;quot;i&amp;quot;. Among them, &amp;quot;ironman&amp;quot; and &amp;quot;i love leetcode&amp;quot; have same hot degree. Since &amp;#39; &amp;#39; has ASCII code 32 and &amp;#39;r&amp;#39; has ASCII code 114, &amp;quot;i love leetcode&amp;quot; should be in front of &amp;quot;ironman&amp;quot;. Also we only need to output top 3 hot sentences, so &amp;quot;ironman&amp;quot; will be ignored. obj.input(&amp;quot; &amp;quot;); // return [&amp;quot;i love you&amp;quot;, &amp;quot;i love leetcode&amp;quot;]. There are only two sentences that have prefix &amp;quot;i &amp;quot;. obj.input(&amp;quot;a&amp;quot;); // return []. There are no sentences that have prefix &amp;quot;i a&amp;quot;. obj.input(&amp;quot;#&amp;quot;); // return []. The user finished the input, the sentence &amp;quot;i a&amp;quot; should be saved as a historical sentence in system. And the following input will be counted as a new search. &amp;nbsp; Constraints: n == sentences.length n == times.length 1 &amp;lt;= n &amp;lt;= 100 1 &amp;lt;= sentences[i].length &amp;lt;= 100 1 &amp;lt;= times[i] &amp;lt;= 50 c is a lowercase English letter, a hash &amp;#39;#&amp;#39;, or space &amp;#39; &amp;#39;. Each tested sentence will..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2017-09-02T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2017-09-02-642-Design-Search-Autocomplete-System/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-642.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="642 - Design Search Autocomplete System" property="twitter:title"/>
   <meta content="Leetcode 642. Design Search Autocomplete System Description Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character &amp;#39;#&amp;#39;). You are given a string array sentences and an integer array times both of length n where sentences[i] is a previously typed sentence and times[i] is the corresponding number of times the sentence was typed. For each input character except &amp;#39;#&amp;#39;, return the top 3 historical hot sentences that have the same prefix as the part of the sentence already typed. Here are the specific rules: The hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before. The returned top 3 hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same hot degree, use ASCII-code order (smaller one appears first). If less than 3 hot sentences exist, return as many as you can. When the input is a special character, it means the sentence ends, and in this case, you need to return an empty list. Implement the AutocompleteSystem class: AutocompleteSystem(String[] sentences, int[] times) Initializes the object with the sentences and times arrays. List&amp;lt;String&amp;gt; input(char c) This indicates that the user typed the character c. Returns an empty array [] if c == &amp;#39;#&amp;#39; and stores the inputted sentence in the system. Returns the top 3 historical hot sentences that have the same prefix as the part of the sentence already typed. If there are fewer than 3 matches, return them all. &amp;nbsp; Example 1: Input [&amp;quot;AutocompleteSystem&amp;quot;, &amp;quot;input&amp;quot;, &amp;quot;input&amp;quot;, &amp;quot;input&amp;quot;, &amp;quot;input&amp;quot;] [[[&amp;quot;i love you&amp;quot;, &amp;quot;island&amp;quot;, &amp;quot;iroman&amp;quot;, &amp;quot;i love leetcode&amp;quot;], [5, 3, 2, 2]], [&amp;quot;i&amp;quot;], [&amp;quot; &amp;quot;], [&amp;quot;a&amp;quot;], [&amp;quot;#&amp;quot;]] Output [null, [&amp;quot;i love you&amp;quot;, &amp;quot;island&amp;quot;, &amp;quot;i love leetcode&amp;quot;], [&amp;quot;i love you&amp;quot;, &amp;quot;i love leetcode&amp;quot;], [], []] Explanation AutocompleteSystem obj = new AutocompleteSystem([&amp;quot;i love you&amp;quot;, &amp;quot;island&amp;quot;, &amp;quot;iroman&amp;quot;, &amp;quot;i love leetcode&amp;quot;], [5, 3, 2, 2]); obj.input(&amp;quot;i&amp;quot;); // return [&amp;quot;i love you&amp;quot;, &amp;quot;island&amp;quot;, &amp;quot;i love leetcode&amp;quot;]. There are four sentences that have prefix &amp;quot;i&amp;quot;. Among them, &amp;quot;ironman&amp;quot; and &amp;quot;i love leetcode&amp;quot; have same hot degree. Since &amp;#39; &amp;#39; has ASCII code 32 and &amp;#39;r&amp;#39; has ASCII code 114, &amp;quot;i love leetcode&amp;quot; should be in front of &amp;quot;ironman&amp;quot;. Also we only need to output top 3 hot sentences, so &amp;quot;ironman&amp;quot; will be ignored. obj.input(&amp;quot; &amp;quot;); // return [&amp;quot;i love you&amp;quot;, &amp;quot;i love leetcode&amp;quot;]. There are only two sentences that have prefix &amp;quot;i &amp;quot;. obj.input(&amp;quot;a&amp;quot;); // return []. There are no sentences that have prefix &amp;quot;i a&amp;quot;. obj.input(&amp;quot;#&amp;quot;); // return []. The user finished the input, the sentence &amp;quot;i a&amp;quot; should be saved as a historical sentence in system. And the following input will be counted as a new search. &amp;nbsp; Constraints: n == sentences.length n == times.length 1 &amp;lt;= n &amp;lt;= 100 1 &amp;lt;= sentences[i].length &amp;lt;= 100 1 &amp;lt;= times[i] &amp;lt;= 50 c is a lowercase English letter, a hash &amp;#39;#&amp;#39;, or space &amp;#39; &amp;#39;. Each tested sentence will..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    642 - Design Search Autocomplete System | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="642 - Design Search Autocomplete System" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-642.html" rel="canonical">
          <meta content="https://leetcode.ca/2017-09-02-642-Design-Search-Autocomplete-System/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2017-09-02T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"642 - Design Search Autocomplete System","dateModified":"2017-09-02T00:00:00-07:00","datePublished":"2017-09-02T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2017-09-02-642-Design-Search-Autocomplete-System/"},"url":"https://leetcode.ca/2017-09-02-642-Design-Search-Autocomplete-System/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="642-design-search-autocomplete-system">
       <a href="solution-642.html">
        642. Design Search Autocomplete System
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character
       <code>
        '#'
       </code>
       ).
      </p>
      <p>
       You are given a string array
       <code>
        sentences
       </code>
       and an integer array
       <code>
        times
       </code>
       both of length
       <code>
        n
       </code>
       where
       <code>
        sentences[i]
       </code>
       is a previously typed sentence and
       <code>
        times[i]
       </code>
       is the corresponding number of times the sentence was typed. For each input character except
       <code>
        '#'
       </code>
       , return the top
       <code>
        3
       </code>
       historical hot sentences that have the same prefix as the part of the sentence already typed.
      </p>
      <p>
       Here are the specific rules:
      </p>
      <ul>
       <li>
        The hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before.
       </li>
       <li>
        The returned top
        <code>
         3
        </code>
        hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same hot degree, use ASCII-code order (smaller one appears first).
       </li>
       <li>
        If less than
        <code>
         3
        </code>
        hot sentences exist, return as many as you can.
       </li>
       <li>
        When the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.
       </li>
      </ul>
      <p>
       Implement the
       <code>
        AutocompleteSystem
       </code>
       class:
      </p>
      <ul>
       <li>
        <code>
         AutocompleteSystem(String[] sentences, int[] times)
        </code>
        Initializes the object with the
        <code>
         sentences
        </code>
        and
        <code>
         times
        </code>
        arrays.
       </li>
       <li>
        <code>
         List&lt;String&gt; input(char c)
        </code>
        This indicates that the user typed the character
        <code>
         c
        </code>
        .
        <ul>
         <li>
          Returns an empty array
          <code>
           []
          </code>
          if
          <code>
           c == '#'
          </code>
          and stores the inputted sentence in the system.
         </li>
         <li>
          Returns the top
          <code>
           3
          </code>
          historical hot sentences that have the same prefix as the part of the sentence already typed. If there are fewer than
          <code>
           3
          </code>
          matches, return them all.
         </li>
        </ul>
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input</strong>
["AutocompleteSystem", "input", "input", "input", "input"]
[[["i love you", "island", "iroman", "i love leetcode"], [5, 3, 2, 2]], ["i"], [" "], ["a"], ["#"]]
<strong>Output</strong>
[null, ["i love you", "island", "i love leetcode"], ["i love you", "i love leetcode"], [], []]

<strong>Explanation</strong>
AutocompleteSystem obj = new AutocompleteSystem(["i love you", "island", "iroman", "i love leetcode"], [5, 3, 2, 2]);
obj.input("i"); // return ["i love you", "island", "i love leetcode"]. There are four sentences that have prefix "i". Among them, "ironman" and "i love leetcode" have same hot degree. Since ' ' has ASCII code 32 and 'r' has ASCII code 114, "i love leetcode" should be in front of "ironman". Also we only need to output top 3 hot sentences, so "ironman" will be ignored.
obj.input(" "); // return ["i love you", "i love leetcode"]. There are only two sentences that have prefix "i ".
obj.input("a"); // return []. There are no sentences that have prefix "i a".
obj.input("#"); // return []. The user finished the input, the sentence "i a" should be saved as a historical sentence in system. And the following input will be counted as a new search.
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         n == sentences.length
        </code>
       </li>
       <li>
        <code>
         n == times.length
        </code>
       </li>
       <li>
        <code>
         1 &lt;= n &lt;= 100
        </code>
       </li>
       <li>
        <code>
         1 &lt;= sentences[i].length &lt;= 100
        </code>
       </li>
       <li>
        <code>
         1 &lt;= times[i] &lt;= 50
        </code>
       </li>
       <li>
        <code>
         c
        </code>
        is a lowercase English letter, a hash
        <code>
         '#'
        </code>
        , or space
        <code>
         ' '
        </code>
        .
       </li>
       <li>
        Each tested sentence will be a sequence of characters
        <code>
         c
        </code>
        that end with the character
        <code>
         '#'
        </code>
        .
       </li>
       <li>
        Each tested sentence will have a length in the range
        <code>
         [1, 200]
        </code>
        .
       </li>
       <li>
        The words in each input sentence are separated by single spaces.
       </li>
       <li>
        At most
        <code>
         5000
        </code>
        calls will be made to
        <code>
         input
        </code>
        .
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <h4 id="thinking-direction">
       Thinking direction
      </h4>
      <ul>
       <li>
        For text search, there is no doubt that you need to use
        <code class="language-plaintext highlighter-rouge">
         Prefix tree
        </code>
        ,
        <code class="language-plaintext highlighter-rouge">
         trie
        </code>
        .
       </li>
      </ul>
      <h5 id="find-all-possible-wordleaf-two-options">
       Find all possible word/leaf, two options:
      </h5>
      <ul>
       <li>
        After Trie is built, do prefix search, then
        <code class="language-plaintext highlighter-rouge">
         DFS
        </code>
        /
        <code class="language-plaintext highlighter-rouge">
         BFS
        </code>
        return all leaf items. [high runtime complexity]
       </li>
       <li>
        Store all possible words in
        <code class="language-plaintext highlighter-rouge">
         TrieNode
        </code>
        . [high space usage]
       </li>
       <li>
        in memory space should not be a big problem, so we can choose to store all possible words
       </li>
      </ul>
      <h5 id="given-k-words-find-top-k-frequent-items-minheap-must-be-used-but-there-are-two-options">
       Given k words, find top k frequent items. MinHeap must be used, but there are two options:
      </h5>
      <ul>
       <li>
        Store
        <code class="language-plaintext highlighter-rouge">
         MinHeap
        </code>
        with
        <code class="language-plaintext highlighter-rouge">
         TrieNode
        </code>
        : Because it will continue to search for new entries, the same prefix (especially at higher level) will be searched multiple times.
       </li>
       <li>
        [complexity: need to update
        <code class="language-plaintext highlighter-rouge">
         heaps
        </code>
        across all visited TrieNodes once new sentence is completed]
       </li>
       <li>
        Compute MinHeap on the fly: Of course, we canât come to a DFS every time, otherwise it will be very slow, so we must store a list of possible candidates in TrieNode.
       </li>
       <li>
        The
        <code class="language-plaintext highlighter-rouge">
         Map&lt;String, freq&gt;
        </code>
        in
        <code class="language-plaintext highlighter-rouge">
         Top K Frequent Words
        </code>
        is used here, so O(m) is actually very convenient to construct min-heap.
       </li>
      </ul>
      <h5 id="train-the-system">
       Train the system
      </h5>
      <ul>
       <li>
        Every time an entry is marked after
        <code class="language-plaintext highlighter-rouge">
         #
        </code>
        to be added into search history. Then
        <code class="language-plaintext highlighter-rouge">
         insert it into trie
        </code>
        .
       </li>
       <li>
        This one can be done after meeting
        <code class="language-plaintext highlighter-rouge">
         #
        </code>
        at the end, very concise
       </li>
      </ul>
      <p>
       The problem is very long, but not too difficult, it can be solved with Trie, but you need to pay attention:
      </p>
      <ul>
       <li>
        In
        <code class="language-plaintext highlighter-rouge">
         input()
        </code>
        , you need to read and write, but note that it must be read and then written, otherwise the sentence just inserted in will be detected
       </li>
       <li>
        When encounteringâ#â, return to empty list
       </li>
       <li>
        To return the sentences stored in Trie, one approach is to add a member variable str to Trie to store the str formed on the path from root to curr. Another approach is to pass str as a parameter to child when querying. This topic uses the latter idea.
       </li>
       <li>
        In dfs trie, you must now add root to the result set, and then traverse the children! Otherwise, the root at the bottom of the stack will be missed. This is very important. Trieâs queries must be written like this.
       </li>
       <li>
        In
        <code class="language-plaintext highlighter-rouge">
         findTopK()
        </code>
        , you can use PriorityQueue to do it, you can also use List to do and then sort.
       </li>
      </ul>
      <ul class="uk-tab" data-uk-switcher="{connect:'#151734a3-117d-4f7c-8e71-dbe88acfc86d'}">
       <li class="uk-active">
        <a href="solution-642.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-642.html">
         Python
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="151734a3-117d-4f7c-8e71-dbe88acfc86d">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Trie</span> <span class="o">{</span>
    <span class="nc">Trie</span><span class="o">[]</span> <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Trie</span><span class="o">[</span><span class="mi">27</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">v</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">w</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>

    <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="nc">String</span> <span class="n">w</span><span class="o">,</span> <span class="kt">int</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">w</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">' '</span> <span class="o">?</span> <span class="mi">26</span> <span class="o">:</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Trie</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">node</span><span class="o">.</span><span class="na">v</span> <span class="o">+=</span> <span class="n">t</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nc">Trie</span> <span class="nf">search</span><span class="o">(</span><span class="nc">String</span> <span class="n">pref</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">pref</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">' '</span> <span class="o">?</span> <span class="mi">26</span> <span class="o">:</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">AutocompleteSystem</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Trie</span> <span class="n">trie</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Trie</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nc">StringBuilder</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

    <span class="kd">public</span> <span class="nf">AutocompleteSystem</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">sentences</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">times</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">sentences</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">trie</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">times</span><span class="o">[</span><span class="n">i</span><span class="o">++]);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">input</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'#'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">trie</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">toString</span><span class="o">(),</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">t</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="n">trie</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Trie</span><span class="o">&gt;</span> <span class="n">q</span>
            <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">v</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="na">v</span> <span class="o">?</span> <span class="n">b</span><span class="o">.</span><span class="na">w</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">w</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span><span class="o">.</span><span class="na">v</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="na">v</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">().</span><span class="na">w</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">Trie</span> <span class="n">node</span><span class="o">,</span> <span class="nc">PriorityQueue</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Trie</span> <span class="n">nxt</span> <span class="o">:</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">nxt</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Your AutocompleteSystem object will be instantiated and called as such:
 * AutocompleteSystem obj = new AutocompleteSystem(sentences, times);
 * List&lt;String&gt; param_1 = obj.input(c);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 26+1, extra 1 for space ' ' node
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">27</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="s">''</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">w</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">26</span> <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s">' '</span> <span class="k">else</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">node</span><span class="p">.</span><span class="n">v</span> <span class="o">+=</span> <span class="n">t</span>
        <span class="n">node</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">w</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pref</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">pref</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">26</span> <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s">' '</span> <span class="k">else</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">node</span>


<span class="k">class</span> <span class="nc">AutocompleteSystem</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentences</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">times</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">trie</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sentences</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">trie</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># target
</span>
    <span class="k">def</span> <span class="nf">input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">v</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">.</span><span class="n">v</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">w</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">nxt</span> <span class="ow">in</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">nxt</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s">'#'</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">t</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">trie</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">t</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">trie</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">t</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">res</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[:</span><span class="mi">3</span><span class="p">]]</span>


<span class="c1"># Your AutocompleteSystem object will be instantiated and called as such:
# obj = AutocompleteSystem(sentences, times)
# param_1 = obj.input(c)
</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-642.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
