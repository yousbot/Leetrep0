<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-426.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-426.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>426 - Convert Binary Search Tree to Sorted Doubly Linked List</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 426. Convert Binary Search Tree to Sorted Doubly Linked List Description Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in place. You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list....">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-426.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-426.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-426.html" rel="stylesheet"/>
   <link href="solution-426.html" rel="stylesheet"/>
   <link href="solution-426.html" rel="stylesheet"/>
   <link href="solution-426.html" rel="stylesheet"/>
   <link href="solution-426.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="426 - Convert Binary Search Tree to Sorted Doubly Linked List" property="og:title"/>
   <meta content="Leetcode 426. Convert Binary Search Tree to Sorted Doubly Linked List Description Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in place. You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element. We want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list. &amp;nbsp; Example 1: Input: root = [4,2,5,1,3] Output: [1,2,3,4,5] Explanation: The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship. Example 2: Input: root = [2,1,3] Output: [1,2,3] &amp;nbsp; Constraints: The number of nodes in the tree is in the range [0, 2000]. -1000 &amp;lt;= Node.val &amp;lt;= 1000 All the values of the tree are unique. Solutions Java C++ Python Go Javascript /* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node() {} public Node(int _val) { val = _val; } public Node(int _val,Node _left,Node _right) { val = _val; left = _left; right = _right; } }; */ class Solution { private Node prev; private Node head; public Node treeToDoublyList(Node root) { if (root == null) { return null; } prev = null; head = null; dfs(root); prev.right = head; head.left = prev; return head; } private void dfs(Node root) { if (root == null) { return; } dfs(root.left); if (prev != null) { prev.right = root; root.left = prev; } else { head = root; } prev = root; dfs(root.right); } } /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node() {} Node(int _val) { val = _val; left = NULL; right = NULL; } Node(int _val, Node* _left, Node* _right) { val = _val; left = _left; right = _right; } }; */ class Solution { public: Node* prev; Node* head; Node* treeToDoublyList(Node* root) { if (!root) return nullptr; prev = nullptr; head = nullptr; dfs(root); prev-&amp;gt;right = head; head-&amp;gt;left = prev; return head; } void dfs(Node* root) { if (!root) return; dfs(root-&amp;gt;left); if (prev) { prev-&amp;gt;right = root; root-&amp;gt;left = prev; } else head = root; prev = root; dfs(root-&amp;gt;right); } }; &quot;&quot;&quot; # Definition for a Node. class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right &quot;&quot;&quot; class Solution: def treeToDoublyList(self, root: 'Optional[Node]') -&amp;gt; 'Optional[Node]': def dfs(root): if root is None: return nonlocal prev, head dfs(root.left) if prev: prev.right = root root.left = prev else: head = root prev = root dfs(root.right) if root is None: return None head = prev = None dfs(root) prev.right =..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2017-01-29T00:00:00-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2017-01-29-426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-426.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="426 - Convert Binary Search Tree to Sorted Doubly Linked List" property="twitter:title"/>
   <meta content="Leetcode 426. Convert Binary Search Tree to Sorted Doubly Linked List Description Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in place. You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element. We want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list. &amp;nbsp; Example 1: Input: root = [4,2,5,1,3] Output: [1,2,3,4,5] Explanation: The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship. Example 2: Input: root = [2,1,3] Output: [1,2,3] &amp;nbsp; Constraints: The number of nodes in the tree is in the range [0, 2000]. -1000 &amp;lt;= Node.val &amp;lt;= 1000 All the values of the tree are unique. Solutions Java C++ Python Go Javascript /* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node() {} public Node(int _val) { val = _val; } public Node(int _val,Node _left,Node _right) { val = _val; left = _left; right = _right; } }; */ class Solution { private Node prev; private Node head; public Node treeToDoublyList(Node root) { if (root == null) { return null; } prev = null; head = null; dfs(root); prev.right = head; head.left = prev; return head; } private void dfs(Node root) { if (root == null) { return; } dfs(root.left); if (prev != null) { prev.right = root; root.left = prev; } else { head = root; } prev = root; dfs(root.right); } } /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node() {} Node(int _val) { val = _val; left = NULL; right = NULL; } Node(int _val, Node* _left, Node* _right) { val = _val; left = _left; right = _right; } }; */ class Solution { public: Node* prev; Node* head; Node* treeToDoublyList(Node* root) { if (!root) return nullptr; prev = nullptr; head = nullptr; dfs(root); prev-&amp;gt;right = head; head-&amp;gt;left = prev; return head; } void dfs(Node* root) { if (!root) return; dfs(root-&amp;gt;left); if (prev) { prev-&amp;gt;right = root; root-&amp;gt;left = prev; } else head = root; prev = root; dfs(root-&amp;gt;right); } }; &quot;&quot;&quot; # Definition for a Node. class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right &quot;&quot;&quot; class Solution: def treeToDoublyList(self, root: 'Optional[Node]') -&amp;gt; 'Optional[Node]': def dfs(root): if root is None: return nonlocal prev, head dfs(root.left) if prev: prev.right = root root.left = prev else: head = root prev = root dfs(root.right) if root is None: return None head = prev = None dfs(root) prev.right =..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    426 - Convert Binary Search Tree to Sorted Doubly Linked List | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="426 - Convert Binary Search Tree to Sorted Doubly Linked List" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-426.html" rel="canonical">
          <meta content="https://leetcode.ca/2017-01-29-426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2017-01-29T00:00:00-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"426 - Convert Binary Search Tree to Sorted Doubly Linked List","dateModified":"2017-01-29T00:00:00-08:00","datePublished":"2017-01-29T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2017-01-29-426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List/"},"url":"https://leetcode.ca/2017-01-29-426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="426-convert-binary-search-tree-to-sorted-doubly-linked-list">
       <a href="solution-426.html">
        426. Convert Binary Search Tree to Sorted Doubly Linked List
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Convert a
       <strong>
        Binary Search Tree
       </strong>
       to a sorted
       <strong>
        Circular Doubly-Linked List
       </strong>
       in place.
      </p>
      <p>
       You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.
      </p>
      <p>
       We want to do the transformation
       <strong>
        in place
       </strong>
       . After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0426.Convert%20Binary%20Search%20Tree%20to%20Sorted%20Doubly%20Linked%20List/images/bstdlloriginalbst.png" style="width: 100%; max-width: 300px;"/>
      </p>
      <pre>
<strong>Input:</strong> root = [4,2,5,1,3]

<img src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0426.Convert%20Binary%20Search%20Tree%20to%20Sorted%20Doubly%20Linked%20List/images/bstdllreturndll.png" style="width: 100%; max-width: 450px;"/>
<strong>Output:</strong> [1,2,3,4,5]

<strong>Explanation:</strong> The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.
<img src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0426.Convert%20Binary%20Search%20Tree%20to%20Sorted%20Doubly%20Linked%20List/images/bstdllreturnbst.png" style="width: 100%; max-width: 450px;"/>
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> root = [2,1,3]
<strong>Output:</strong> [1,2,3]
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the tree is in the range
        <code>
         [0, 2000]
        </code>
        .
       </li>
       <li>
        <code>
         -1000 &lt;= Node.val &lt;= 1000
        </code>
       </li>
       <li>
        All the values of the tree are
        <strong>
         unique
        </strong>
        .
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <ul class="uk-tab" data-uk-switcher="{connect:'#0fa081ae-1ba8-464c-9c92-9ece346b81b6'}">
       <li class="uk-active">
        <a href="solution-426.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-426.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-426.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-426.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-426.html">
         Javascript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="0fa081ae-1ba8-464c-9c92-9ece346b81b6">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">prev</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">head</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">treeToDoublyList</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="n">prev</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">head</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">prev</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
            <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;

    Node() {}

    Node(int _val) {
        val = _val;
        left = NULL;
        right = NULL;
    }

    Node(int _val, Node* _left, Node* _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>

    <span class="n">Node</span><span class="o">*</span> <span class="n">treeToDoublyList</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="n">prev</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">prev</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
            <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="s">"""
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
"""</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">treeToDoublyList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="s">'Optional[Node]'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s">'Optional[Node]'</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">nonlocal</span> <span class="n">prev</span><span class="p">,</span> <span class="n">head</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">prev</span><span class="p">:</span>
                <span class="n">prev</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">root</span>
                <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">prev</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">root</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">root</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="n">prev</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">head</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">prev</span>
        <span class="k">return</span> <span class="n">head</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Left *Node
 *     Right *Node
 * }
 */</span>

<span class="k">func</span> <span class="n">treeToDoublyList</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="o">*</span><span class="n">Node</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">root</span>
	<span class="p">}</span>
	<span class="k">var</span> <span class="n">prev</span><span class="p">,</span> <span class="n">head</span> <span class="o">*</span><span class="n">Node</span>

	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">prev</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">prev</span><span class="o">.</span><span class="n">Right</span> <span class="o">=</span> <span class="n">root</span>
			<span class="n">root</span><span class="o">.</span><span class="n">Left</span> <span class="o">=</span> <span class="n">prev</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">head</span> <span class="o">=</span> <span class="n">root</span>
		<span class="p">}</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">root</span>
		<span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
	<span class="n">prev</span><span class="o">.</span><span class="n">Right</span> <span class="o">=</span> <span class="n">head</span>
	<span class="n">head</span><span class="o">.</span><span class="n">Left</span> <span class="o">=</span> <span class="n">prev</span>
	<span class="k">return</span> <span class="n">head</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-js highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * // Definition for a Node.
 * function Node(val, left, right) {
 *      this.val = val;
 *      this.left = left;
 *      this.right = right;
 *  };
 */</span>

<span class="cm">/**
 * @param {Node} root
 * @return {Node}
 */</span>
<span class="kd">var</span> <span class="nx">treeToDoublyList</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">root</span><span class="p">)</span> <span class="k">return</span> <span class="nx">root</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">head</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">prev</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">prev</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">root</span><span class="p">;</span>
            <span class="nx">root</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">prev</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">head</span> <span class="o">=</span> <span class="nx">root</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">prev</span> <span class="o">=</span> <span class="nx">root</span><span class="p">;</span>
        <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
    <span class="nx">prev</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">head</span><span class="p">;</span>
    <span class="nx">head</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">prev</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">head</span><span class="p">;</span>
<span class="p">};</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-426.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
