<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-865.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-865.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>865 - Smallest Subtree with all the Deepest Nodes</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 865. Smallest Subtree with all the Deepest Nodes Description Given the root of a binary tree, the depth of each node is the shortest distance to the root. Return the smallest subtree such that it contains all the deepest nodes in the original tree. A...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-865.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-865.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-865.html" rel="stylesheet"/>
   <link href="solution-865.html" rel="stylesheet"/>
   <link href="solution-865.html" rel="stylesheet"/>
   <link href="solution-865.html" rel="stylesheet"/>
   <link href="solution-865.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="865 - Smallest Subtree with all the Deepest Nodes" property="og:title"/>
   <meta content="Leetcode 865. Smallest Subtree with all the Deepest Nodes Description Given the root of a binary tree, the depth of each node is the shortest distance to the root. Return the smallest subtree such that it contains all the deepest nodes in the original tree. A node is called the deepest if it has the largest depth possible among any node in the entire tree. The subtree of a node is a tree consisting of that node, plus the set of all descendants of that node. &amp;nbsp; Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4] Output: [2,7,4] Explanation: We return the node with value 2, colored in yellow in the diagram. The nodes coloured in blue are the deepest nodes of the tree. Notice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it. Example 2: Input: root = [1] Output: [1] Explanation: The root is the deepest node in the tree. Example 3: Input: root = [0,1,3,null,2] Output: [2] Explanation: The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest. &amp;nbsp; Constraints: The number of nodes in the tree will be in the range [1, 500]. 0 &amp;lt;= Node.val &amp;lt;= 500 The values of the nodes in the tree are unique. &amp;nbsp; Note: This question is the same as 1123: https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/ Solutions Java C++ Python Go TypeScript /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode subtreeWithAllDeepest(TreeNode root) { return dfs(root).getKey(); } private Pair&amp;lt;TreeNode, Integer&amp;gt; dfs(TreeNode root) { if (root == null) { return new Pair&amp;lt;&amp;gt;(null, 0); } Pair&amp;lt;TreeNode, Integer&amp;gt; l = dfs(root.left); Pair&amp;lt;TreeNode, Integer&amp;gt; r = dfs(root.right); int d1 = l.getValue(), d2 = r.getValue(); if (d1 &amp;gt; d2) { return new Pair&amp;lt;&amp;gt;(l.getKey(), d1 + 1); } if (d1 &amp;lt; d2) { return new Pair&amp;lt;&amp;gt;(r.getKey(), d2 + 1); } return new Pair&amp;lt;&amp;gt;(root, d1 + 1); } } /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ using pti = pair&amp;lt;TreeNode*, int&amp;gt;; class Solution { public: TreeNode* subtreeWithAllDeepest(TreeNode* root) { return dfs(root).first; } pti dfs(TreeNode* root) { if (!root) return {nullptr, 0}; pti l = dfs(root-&amp;gt;left); pti r = dfs(root-&amp;gt;right); int d1 = l.second, d2 = r.second; if (d1 &amp;gt; d2) return {l.first, d1 + 1}; if (d1 &amp;lt; d2) return {r.first, d2 + 1}; return {root,..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2018-04-13T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2018-04-13-865-Smallest-Subtree-with-all-the-Deepest-Nodes/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-865.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="865 - Smallest Subtree with all the Deepest Nodes" property="twitter:title"/>
   <meta content="Leetcode 865. Smallest Subtree with all the Deepest Nodes Description Given the root of a binary tree, the depth of each node is the shortest distance to the root. Return the smallest subtree such that it contains all the deepest nodes in the original tree. A node is called the deepest if it has the largest depth possible among any node in the entire tree. The subtree of a node is a tree consisting of that node, plus the set of all descendants of that node. &amp;nbsp; Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4] Output: [2,7,4] Explanation: We return the node with value 2, colored in yellow in the diagram. The nodes coloured in blue are the deepest nodes of the tree. Notice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it. Example 2: Input: root = [1] Output: [1] Explanation: The root is the deepest node in the tree. Example 3: Input: root = [0,1,3,null,2] Output: [2] Explanation: The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest. &amp;nbsp; Constraints: The number of nodes in the tree will be in the range [1, 500]. 0 &amp;lt;= Node.val &amp;lt;= 500 The values of the nodes in the tree are unique. &amp;nbsp; Note: This question is the same as 1123: https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/ Solutions Java C++ Python Go TypeScript /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode subtreeWithAllDeepest(TreeNode root) { return dfs(root).getKey(); } private Pair&amp;lt;TreeNode, Integer&amp;gt; dfs(TreeNode root) { if (root == null) { return new Pair&amp;lt;&amp;gt;(null, 0); } Pair&amp;lt;TreeNode, Integer&amp;gt; l = dfs(root.left); Pair&amp;lt;TreeNode, Integer&amp;gt; r = dfs(root.right); int d1 = l.getValue(), d2 = r.getValue(); if (d1 &amp;gt; d2) { return new Pair&amp;lt;&amp;gt;(l.getKey(), d1 + 1); } if (d1 &amp;lt; d2) { return new Pair&amp;lt;&amp;gt;(r.getKey(), d2 + 1); } return new Pair&amp;lt;&amp;gt;(root, d1 + 1); } } /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ using pti = pair&amp;lt;TreeNode*, int&amp;gt;; class Solution { public: TreeNode* subtreeWithAllDeepest(TreeNode* root) { return dfs(root).first; } pti dfs(TreeNode* root) { if (!root) return {nullptr, 0}; pti l = dfs(root-&amp;gt;left); pti r = dfs(root-&amp;gt;right); int d1 = l.second, d2 = r.second; if (d1 &amp;gt; d2) return {l.first, d1 + 1}; if (d1 &amp;lt; d2) return {r.first, d2 + 1}; return {root,..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    865 - Smallest Subtree with all the Deepest Nodes | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="865 - Smallest Subtree with all the Deepest Nodes" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-865.html" rel="canonical">
          <meta content="https://leetcode.ca/2018-04-13-865-Smallest-Subtree-with-all-the-Deepest-Nodes/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2018-04-13T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"865 - Smallest Subtree with all the Deepest Nodes","dateModified":"2018-04-13T00:00:00-07:00","datePublished":"2018-04-13T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2018-04-13-865-Smallest-Subtree-with-all-the-Deepest-Nodes/"},"url":"https://leetcode.ca/2018-04-13-865-Smallest-Subtree-with-all-the-Deepest-Nodes/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="865-smallest-subtree-with-all-the-deepest-nodes">
       <a href="solution-865.html">
        865. Smallest Subtree with all the Deepest Nodes
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given the
       <code>
        root
       </code>
       of a binary tree, the depth of each node is
       <strong>
        the shortest distance to the root
       </strong>
       .
      </p>
      <p>
       Return
       <em>
        the smallest subtree
       </em>
       such that it contains
       <strong>
        all the deepest nodes
       </strong>
       in the original tree.
      </p>
      <p>
       A node is called
       <strong>
        the deepest
       </strong>
       if it has the largest depth possible among any node in the entire tree.
      </p>
      <p>
       The
       <strong>
        subtree
       </strong>
       of a node is a tree consisting of that node, plus the set of all descendants of that node.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0800-0899/0865.Smallest%20Subtree%20with%20all%20the%20Deepest%20Nodes/images/sketch1.png" style="width: 600px; height: 510px;"/>
      </p>
      <pre>
<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4]
<strong>Output:</strong> [2,7,4]
<strong>Explanation:</strong> We return the node with value 2, colored in yellow in the diagram.
The nodes coloured in blue are the deepest nodes of the tree.
Notice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> [1]
<strong>Explanation:</strong> The root is the deepest node in the tree.
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> root = [0,1,3,null,2]
<strong>Output:</strong> [2]
<strong>Explanation:</strong> The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest.
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the tree will be in the range
        <code>
         [1, 500]
        </code>
        .
       </li>
       <li>
        <code>
         0 &lt;= Node.val &lt;= 500
        </code>
       </li>
       <li>
        The values of the nodes in the tree are
        <strong>
         unique
        </strong>
        .
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong>
        Note:
       </strong>
       This question is the same as 1123:
       <a href="solution-865.html" target="_blank">
        https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/
       </a>
      </p>
      <h2 id="solutions">
       Solutions
      </h2>
      <ul class="uk-tab" data-uk-switcher="{connect:'#9456380b-1baf-4b52-b292-45f3d51ba162'}">
       <li class="uk-active">
        <a href="solution-865.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-865.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-865.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-865.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-865.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="9456380b-1baf-4b52-b292-45f3d51ba162">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">subtreeWithAllDeepest</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">).</span><span class="na">getKey</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="kc">null</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="na">getValue</span><span class="o">(),</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">d1</span> <span class="o">&gt;</span> <span class="n">d2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="n">l</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">d1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">d1</span> <span class="o">&lt;</span> <span class="n">d2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="n">r</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">d2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="n">root</span><span class="o">,</span> <span class="n">d1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">using</span> <span class="n">pti</span> <span class="o">=</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">subtreeWithAllDeepest</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">).</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pti</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span><span class="nb">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
        <span class="n">pti</span> <span class="n">l</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="n">pti</span> <span class="n">r</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">second</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d1</span> <span class="o">&gt;</span> <span class="n">d2</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span><span class="n">l</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">d1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">};</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d1</span> <span class="o">&lt;</span> <span class="n">d2</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span><span class="n">r</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">d2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">};</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">root</span><span class="p">,</span> <span class="n">d1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">};</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">subtreeWithAllDeepest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">0</span>
            <span class="n">l</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d1</span> <span class="o">&gt;</span> <span class="n">d2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">l</span><span class="p">,</span> <span class="n">d1</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">d1</span> <span class="o">&lt;</span> <span class="n">d2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">d2</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">root</span><span class="p">,</span> <span class="n">d1</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */</span>
<span class="k">type</span> <span class="n">pair</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">first</span>  <span class="o">*</span><span class="n">TreeNode</span>
	<span class="n">second</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">subtreeWithAllDeepest</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="n">TreeNode</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="n">pair</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="n">pair</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">pair</span><span class="p">{</span><span class="no">nil</span><span class="p">,</span> <span class="m">0</span><span class="p">}</span>
		<span class="p">}</span>
		<span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="p">),</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
		<span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">:=</span> <span class="n">l</span><span class="o">.</span><span class="n">second</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">second</span>
		<span class="k">if</span> <span class="n">d1</span> <span class="o">&gt;</span> <span class="n">d2</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">pair</span><span class="p">{</span><span class="n">l</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">d1</span> <span class="o">+</span> <span class="m">1</span><span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">d1</span> <span class="o">&lt;</span> <span class="n">d2</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">pair</span><span class="p">{</span><span class="n">r</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">d2</span> <span class="o">+</span> <span class="m">1</span><span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">pair</span><span class="p">{</span><span class="n">root</span><span class="p">,</span> <span class="n">d1</span> <span class="o">+</span> <span class="m">1</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span><span class="o">.</span><span class="n">first</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>

<span class="kd">function</span> <span class="nx">subtreeWithAllDeepest</span><span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="p">[</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="kr">number</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">null</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="kd">const</span> <span class="p">[</span><span class="nx">l</span><span class="p">,</span> <span class="nx">ld</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
        <span class="kd">const</span> <span class="p">[</span><span class="nx">r</span><span class="p">,</span> <span class="nx">rd</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">ld</span> <span class="o">&gt;</span> <span class="nx">rd</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">[</span><span class="nx">l</span><span class="p">,</span> <span class="nx">ld</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">ld</span> <span class="o">&lt;</span> <span class="nx">rd</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">[</span><span class="nx">r</span><span class="p">,</span> <span class="nx">rd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">[</span><span class="nx">root</span><span class="p">,</span> <span class="nx">ld</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-865.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
