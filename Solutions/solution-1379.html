<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-1379.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-1379.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>1379 - Find a Corresponding Node of a Binary Tree in a Clone of That Tree</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree Description Given two binary trees original and cloned and given a reference to a node target in the original tree. The cloned tree is a copy of the original tree....">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-1379.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-1379.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-1379.html" rel="stylesheet"/>
   <link href="solution-1379.html" rel="stylesheet"/>
   <link href="solution-1379.html" rel="stylesheet"/>
   <link href="solution-1379.html" rel="stylesheet"/>
   <link href="solution-1379.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="1379 - Find a Corresponding Node of a Binary Tree in a Clone of That Tree" property="og:title"/>
   <meta content="Leetcode 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree Description Given two binary trees original and cloned and given a reference to a node target in the original tree. The cloned tree is a copy of the original tree. Return a reference to the same node in the cloned tree. Note that you are not allowed to change any of the two trees or the target node and the answer must be a reference to a node in the cloned tree. &amp;nbsp; Example 1: Input: tree = [7,4,3,null,null,6,19], target = 3 Output: 3 Explanation: In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree. Example 2: Input: tree = [7], target = 7 Output: 7 Example 3: Input: tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4 Output: 4 &amp;nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. The values of the nodes of the tree are unique. target node is a node from the original tree and is not null. &amp;nbsp; Follow up: Could you solve the problem if repeated values on the tree are allowed? Solutions Solution 1: DFS We design a function $dfs(root1, root2)$, which performs DFS traversal simultaneously in trees $root1$ and $root2$. When traversing to a node, if this node happens to be $target$, then we return the corresponding node in $root2$. Otherwise, we recursively search for $target$ in the left and right subtrees of $root1$ and $root2$, and return the result that is not empty. The time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the number of nodes in the tree. Java C++ Python TypeScript C# /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { private TreeNode target; public final TreeNode getTargetCopy( final TreeNode original, final TreeNode cloned, final TreeNode target) { this.target = target; return dfs(original, cloned); } private TreeNode dfs(TreeNode root1, TreeNode root2) { if (root1 == null) { return null; } if (root1 == target) { return root2; } TreeNode res = dfs(root1.left, root2.left); return res == null ? dfs(root1.right, root2.right) : res; } } /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) { function&amp;lt;TreeNode*(TreeNode*, TreeNode*)&amp;gt; dfs = [&amp;amp;](TreeNode* root1, TreeNode* root2) -&amp;gt; TreeNode* { if (root1 == nullptr) { return nullptr; } if (root1 == target) { return root2; } TreeNode* left = dfs(root1-&amp;gt;left, root2-&amp;gt;left); return left == nullptr ? dfs(root1-&amp;gt;right, root2-&amp;gt;right) : left; }; return dfs(original, cloned); } }; # Definition for a binary tree node. #..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2019-09-09T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2019-09-09-1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-1379.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="1379 - Find a Corresponding Node of a Binary Tree in a Clone of That Tree" property="twitter:title"/>
   <meta content="Leetcode 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree Description Given two binary trees original and cloned and given a reference to a node target in the original tree. The cloned tree is a copy of the original tree. Return a reference to the same node in the cloned tree. Note that you are not allowed to change any of the two trees or the target node and the answer must be a reference to a node in the cloned tree. &amp;nbsp; Example 1: Input: tree = [7,4,3,null,null,6,19], target = 3 Output: 3 Explanation: In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree. Example 2: Input: tree = [7], target = 7 Output: 7 Example 3: Input: tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4 Output: 4 &amp;nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. The values of the nodes of the tree are unique. target node is a node from the original tree and is not null. &amp;nbsp; Follow up: Could you solve the problem if repeated values on the tree are allowed? Solutions Solution 1: DFS We design a function $dfs(root1, root2)$, which performs DFS traversal simultaneously in trees $root1$ and $root2$. When traversing to a node, if this node happens to be $target$, then we return the corresponding node in $root2$. Otherwise, we recursively search for $target$ in the left and right subtrees of $root1$ and $root2$, and return the result that is not empty. The time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the number of nodes in the tree. Java C++ Python TypeScript C# /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { private TreeNode target; public final TreeNode getTargetCopy( final TreeNode original, final TreeNode cloned, final TreeNode target) { this.target = target; return dfs(original, cloned); } private TreeNode dfs(TreeNode root1, TreeNode root2) { if (root1 == null) { return null; } if (root1 == target) { return root2; } TreeNode res = dfs(root1.left, root2.left); return res == null ? dfs(root1.right, root2.right) : res; } } /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) { function&amp;lt;TreeNode*(TreeNode*, TreeNode*)&amp;gt; dfs = [&amp;amp;](TreeNode* root1, TreeNode* root2) -&amp;gt; TreeNode* { if (root1 == nullptr) { return nullptr; } if (root1 == target) { return root2; } TreeNode* left = dfs(root1-&amp;gt;left, root2-&amp;gt;left); return left == nullptr ? dfs(root1-&amp;gt;right, root2-&amp;gt;right) : left; }; return dfs(original, cloned); } }; # Definition for a binary tree node. #..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    1379 - Find a Corresponding Node of a Binary Tree in a Clone of That Tree | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="1379 - Find a Corresponding Node of a Binary Tree in a Clone of That Tree" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-1379.html" rel="canonical">
          <meta content="https://leetcode.ca/2019-09-09-1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2019-09-09T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"1379 - Find a Corresponding Node of a Binary Tree in a Clone of That Tree","dateModified":"2019-09-09T00:00:00-07:00","datePublished":"2019-09-09T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2019-09-09-1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree/"},"url":"https://leetcode.ca/2019-09-09-1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="1379-find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree">
       <a href="solution-1379.html">
        1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given two binary trees
       <code>
        original
       </code>
       and
       <code>
        cloned
       </code>
       and given a reference to a node
       <code>
        target
       </code>
       in the original tree.
      </p>
      <p>
       The
       <code>
        cloned
       </code>
       tree is a
       <strong>
        copy of
       </strong>
       the
       <code>
        original
       </code>
       tree.
      </p>
      <p>
       Return
       <em>
        a reference to the same node
       </em>
       in the
       <code>
        cloned
       </code>
       tree.
      </p>
      <p>
       <strong>
        Note
       </strong>
       that you are
       <strong>
        not allowed
       </strong>
       to change any of the two trees or the
       <code>
        target
       </code>
       node and the answer
       <strong>
        must be
       </strong>
       a reference to a node in the
       <code>
        cloned
       </code>
       tree.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1300-1399/1379.Find%20a%20Corresponding%20Node%20of%20a%20Binary%20Tree%20in%20a%20Clone%20of%20That%20Tree/images/e1.png" style="width: 544px; height: 426px;"/>
      </p>
      <pre>
<strong>Input:</strong> tree = [7,4,3,null,null,6,19], target = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree.
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1300-1399/1379.Find%20a%20Corresponding%20Node%20of%20a%20Binary%20Tree%20in%20a%20Clone%20of%20That%20Tree/images/e2.png" style="width: 221px; height: 159px;"/>
      </p>
      <pre>
<strong>Input:</strong> tree = [7], target =  7
<strong>Output:</strong> 7
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1300-1399/1379.Find%20a%20Corresponding%20Node%20of%20a%20Binary%20Tree%20in%20a%20Clone%20of%20That%20Tree/images/e3.png" style="width: 459px; height: 486px;"/>
      </p>
      <pre>
<strong>Input:</strong> tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4
<strong>Output:</strong> 4
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the
        <code>
         tree
        </code>
        is in the range
        <code>
         [1, 10
         <sup>
          4
         </sup>
         ]
        </code>
        .
       </li>
       <li>
        The values of the nodes of the
        <code>
         tree
        </code>
        are unique.
       </li>
       <li>
        <code>
         target
        </code>
        node is a node from the
        <code>
         original
        </code>
        tree and is not
        <code>
         null
        </code>
        .
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong>
        Follow up:
       </strong>
       Could you solve the problem if repeated values on the tree are allowed?
      </p>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       <strong>
        Solution 1: DFS
       </strong>
      </p>
      <p>
       We design a function $dfs(root1, root2)$, which performs DFS traversal simultaneously in trees $root1$ and $root2$. When traversing to a node, if this node happens to be $target$, then we return the corresponding node in $root2$. Otherwise, we recursively search for $target$ in the left and right subtrees of $root1$ and $root2$, and return the result that is not empty.
      </p>
      <p>
       The time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the number of nodes in the tree.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#c3f0455d-8818-4dad-9ea2-961ab9553077'}">
       <li class="uk-active">
        <a href="solution-1379.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-1379.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-1379.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-1379.html">
         TypeScript
        </a>
       </li>
       <li>
        <a href="solution-1379.html">
         C#
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="c3f0455d-8818-4dad-9ea2-961ab9553077">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">TreeNode</span> <span class="n">target</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="nc">TreeNode</span> <span class="nf">getTargetCopy</span><span class="o">(</span>
        <span class="kd">final</span> <span class="nc">TreeNode</span> <span class="n">original</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">TreeNode</span> <span class="n">cloned</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">TreeNode</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">original</span><span class="o">,</span> <span class="n">cloned</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">TreeNode</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root1</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">root2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root1</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root1</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">root2</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">TreeNode</span> <span class="n">res</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root1</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">root2</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root1</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">root2</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">:</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">getTargetCopy</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">original</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">cloned</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root1</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root1</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">root2</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">TreeNode</span><span class="o">*</span> <span class="n">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">root2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">?</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">root2</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="o">:</span> <span class="n">left</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="n">cloned</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">getTargetCopy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">original</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">cloned</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">TreeNode</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root1</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">root2</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">root1</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="n">root1</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">root2</span>
            <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root1</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root2</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">or</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root1</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">root2</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="n">cloned</span><span class="p">)</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>

<span class="kd">function</span> <span class="nx">getTargetCopy</span><span class="p">(</span>
    <span class="nx">original</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
    <span class="nx">cloned</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
    <span class="nx">target</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
<span class="p">):</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">root1</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">root2</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">root1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">root1</span> <span class="o">===</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">root2</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root1</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">root2</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">||</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root1</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">root2</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">original</span><span class="p">,</span> <span class="nx">cloned</span><span class="p">);</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int x) { val = x; }
 * }
 */</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="k">private</span> <span class="n">TreeNode</span> <span class="n">target</span><span class="p">;</span>

    <span class="k">public</span> <span class="n">TreeNode</span> <span class="nf">GetTargetCopy</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">original</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="n">cloned</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">target</span> <span class="p">=</span> <span class="n">target</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="n">cloned</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="n">TreeNode</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">original</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="n">cloned</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">original</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">original</span> <span class="p">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">cloned</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">TreeNode</span> <span class="n">left</span> <span class="p">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">original</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">cloned</span><span class="p">.</span><span class="n">left</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">left</span> <span class="p">==</span> <span class="k">null</span> <span class="p">?</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">original</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">cloned</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="p">:</span> <span class="n">left</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-1379.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
