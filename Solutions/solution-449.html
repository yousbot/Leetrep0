<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-449.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-449.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>449 - Serialize and Deserialize BST</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 449. Serialize and Deserialize BST Description Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-449.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-449.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-449.html" rel="stylesheet"/>
   <link href="solution-449.html" rel="stylesheet"/>
   <link href="solution-449.html" rel="stylesheet"/>
   <link href="solution-449.html" rel="stylesheet"/>
   <link href="solution-449.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="449 - Serialize and Deserialize BST" property="og:title"/>
   <meta content="Leetcode 449. Serialize and Deserialize BST Description Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible. &amp;nbsp; Example 1: Input: root = [2,1,3] Output: [2,1,3] Example 2: Input: root = [] Output: [] &amp;nbsp; Constraints: The number of nodes in the tree is in the range [0, 104]. 0 &amp;lt;= Node.val &amp;lt;= 104 The input tree is guaranteed to be a binary search tree. Solutions The serialization and deserialization processes leverage the BST property that left child nodes have smaller values and right child nodes have larger values than their parent node. Hereâs a detailed explanation of how each part works: Serialization Method: serialize Starts the serialization process by calling a helper method serializeHelper with the root of the tree and an empty list sb. The helper method performs a preorder traversal (root, left, right) of the tree. For each node, it appends the nodeâs value to sb. If a node is None, the traversal simply returns without appending anything, effectively skipping null nodes. After the traversal, sb contains all the node values in preorder. The method returns a string by joining all elements in sb with commas. Method: serializeHelper A recursive function that appends the value of the current node to the list sb, then recursively calls itself for the left and right children of the current node. This results in a preorder traversal of the tree. Deserialization Method: deserialize Begins by splitting the input string data on commas, converting it into a deque q for efficient popping from the front. The deque represents the preorder traversal of the tree. Calls a helper method deserializeHelper, passing q and initial lower and upper bounds. These bounds are used to ensure the values fit within the expected range for a BST. Initially, the bounds are set to negative and positive infinity, allowing any value. Method: deserializeHelper A recursive function that builds the BST based on the preorder values in q. It checks if the current value (the front of q) falls within the expected lower and upper bounds. If it doesnât, the method returns None, indicating that the current value does not belong to the subtree being processed. If the value is within bounds, it is popped from q and used to create a new TreeNode. The method then recursively calls itself to construct the left and right subtrees, adjusting the lower and upper bounds accordingly. For the left child, the upper bound becomes the parent..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2017-02-21T00:00:00-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2017-02-21-449-Serialize-and-Deserialize-BST/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-449.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="449 - Serialize and Deserialize BST" property="twitter:title"/>
   <meta content="Leetcode 449. Serialize and Deserialize BST Description Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible. &amp;nbsp; Example 1: Input: root = [2,1,3] Output: [2,1,3] Example 2: Input: root = [] Output: [] &amp;nbsp; Constraints: The number of nodes in the tree is in the range [0, 104]. 0 &amp;lt;= Node.val &amp;lt;= 104 The input tree is guaranteed to be a binary search tree. Solutions The serialization and deserialization processes leverage the BST property that left child nodes have smaller values and right child nodes have larger values than their parent node. Hereâs a detailed explanation of how each part works: Serialization Method: serialize Starts the serialization process by calling a helper method serializeHelper with the root of the tree and an empty list sb. The helper method performs a preorder traversal (root, left, right) of the tree. For each node, it appends the nodeâs value to sb. If a node is None, the traversal simply returns without appending anything, effectively skipping null nodes. After the traversal, sb contains all the node values in preorder. The method returns a string by joining all elements in sb with commas. Method: serializeHelper A recursive function that appends the value of the current node to the list sb, then recursively calls itself for the left and right children of the current node. This results in a preorder traversal of the tree. Deserialization Method: deserialize Begins by splitting the input string data on commas, converting it into a deque q for efficient popping from the front. The deque represents the preorder traversal of the tree. Calls a helper method deserializeHelper, passing q and initial lower and upper bounds. These bounds are used to ensure the values fit within the expected range for a BST. Initially, the bounds are set to negative and positive infinity, allowing any value. Method: deserializeHelper A recursive function that builds the BST based on the preorder values in q. It checks if the current value (the front of q) falls within the expected lower and upper bounds. If it doesnât, the method returns None, indicating that the current value does not belong to the subtree being processed. If the value is within bounds, it is popped from q and used to create a new TreeNode. The method then recursively calls itself to construct the left and right subtrees, adjusting the lower and upper bounds accordingly. For the left child, the upper bound becomes the parent..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    449 - Serialize and Deserialize BST | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="449 - Serialize and Deserialize BST" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-449.html" rel="canonical">
          <meta content="https://leetcode.ca/2017-02-21-449-Serialize-and-Deserialize-BST/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2017-02-21T00:00:00-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"449 - Serialize and Deserialize BST","dateModified":"2017-02-21T00:00:00-08:00","datePublished":"2017-02-21T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2017-02-21-449-Serialize-and-Deserialize-BST/"},"url":"https://leetcode.ca/2017-02-21-449-Serialize-and-Deserialize-BST/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="449-serialize-and-deserialize-bst">
       <a href="solution-449.html">
        449. Serialize and Deserialize BST
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
      </p>
      <p>
       Design an algorithm to serialize and deserialize a
       <b>
        binary search tree
       </b>
       . There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.
      </p>
      <p>
       <b>
        The encoded string should be as compact as possible.
       </b>
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre><strong>Input:</strong> root = [2,1,3]
<strong>Output:</strong> [2,1,3]
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre><strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the tree is in the range
        <code>
         [0, 10
         <sup>
          4
         </sup>
         ]
        </code>
        .
       </li>
       <li>
        <code>
         0 &lt;= Node.val &lt;= 10
         <sup>
          4
         </sup>
        </code>
       </li>
       <li>
        The input tree is
        <strong>
         guaranteed
        </strong>
        to be a binary search tree.
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       The serialization and deserialization processes leverage the
       <code class="language-plaintext highlighter-rouge">
        BST property
       </code>
       that left child nodes have smaller values and right child nodes have larger values than their parent node. Hereâs a detailed explanation of how each part works:
      </p>
      <h3 id="serialization">
       Serialization
      </h3>
      <p>
       <strong>
        Method:
        <code class="language-plaintext highlighter-rouge">
         serialize
        </code>
       </strong>
      </p>
      <ul>
       <li>
        Starts the serialization process by calling a helper method
        <code class="language-plaintext highlighter-rouge">
         serializeHelper
        </code>
        with the root of the tree and an empty list
        <code class="language-plaintext highlighter-rouge">
         sb
        </code>
        .
       </li>
       <li>
        The helper method performs a preorder traversal (root, left, right) of the tree. For each node, it appends the nodeâs value to
        <code class="language-plaintext highlighter-rouge">
         sb
        </code>
        . If a node is
        <code class="language-plaintext highlighter-rouge">
         None
        </code>
        , the traversal simply returns without appending anything, effectively skipping null nodes.
       </li>
       <li>
        After the traversal,
        <code class="language-plaintext highlighter-rouge">
         sb
        </code>
        contains all the node values in preorder. The method returns a string by joining all elements in
        <code class="language-plaintext highlighter-rouge">
         sb
        </code>
        with commas.
       </li>
      </ul>
      <p>
       <strong>
        Method:
        <code class="language-plaintext highlighter-rouge">
         serializeHelper
        </code>
       </strong>
      </p>
      <ul>
       <li>
        A recursive function that appends the value of the current node to the list
        <code class="language-plaintext highlighter-rouge">
         sb
        </code>
        , then recursively calls itself for the left and right children of the current node. This results in a preorder traversal of the tree.
       </li>
      </ul>
      <h3 id="deserialization">
       Deserialization
      </h3>
      <p>
       <strong>
        Method:
        <code class="language-plaintext highlighter-rouge">
         deserialize
        </code>
       </strong>
      </p>
      <ul>
       <li>
        Begins by splitting the input string
        <code class="language-plaintext highlighter-rouge">
         data
        </code>
        on commas, converting it into a deque
        <code class="language-plaintext highlighter-rouge">
         q
        </code>
        for efficient popping from the front. The deque represents the preorder traversal of the tree.
       </li>
       <li>
        Calls a helper method
        <code class="language-plaintext highlighter-rouge">
         deserializeHelper
        </code>
        , passing
        <code class="language-plaintext highlighter-rouge">
         q
        </code>
        and initial
        <code class="language-plaintext highlighter-rouge">
         lower
        </code>
        and
        <code class="language-plaintext highlighter-rouge">
         upper
        </code>
        bounds. These bounds are used to ensure the values fit within the expected range for a BST. Initially, the bounds are set to negative and positive infinity, allowing any value.
       </li>
      </ul>
      <p>
       <strong>
        Method:
        <code class="language-plaintext highlighter-rouge">
         deserializeHelper
        </code>
       </strong>
      </p>
      <ul>
       <li>
        A recursive function that builds the BST based on the preorder values in
        <code class="language-plaintext highlighter-rouge">
         q
        </code>
        . It checks if the current value (the front of
        <code class="language-plaintext highlighter-rouge">
         q
        </code>
        ) falls within the expected
        <code class="language-plaintext highlighter-rouge">
         lower
        </code>
        and
        <code class="language-plaintext highlighter-rouge">
         upper
        </code>
        bounds. If it doesnât, the method returns
        <code class="language-plaintext highlighter-rouge">
         None
        </code>
        , indicating that the current value does not belong to the subtree being processed.
       </li>
       <li>
        If the value is within bounds, it is popped from
        <code class="language-plaintext highlighter-rouge">
         q
        </code>
        and used to create a new
        <code class="language-plaintext highlighter-rouge">
         TreeNode
        </code>
        . The method then recursively calls itself to construct the left and right subtrees, adjusting the
        <code class="language-plaintext highlighter-rouge">
         lower
        </code>
        and
        <code class="language-plaintext highlighter-rouge">
         upper
        </code>
        bounds accordingly. For the left child, the
        <code class="language-plaintext highlighter-rouge">
         upper
        </code>
        bound becomes the parent nodeâs value, and for the right child, the
        <code class="language-plaintext highlighter-rouge">
         lower
        </code>
        bound becomes the parent nodeâs value.
       </li>
       <li>
        This process ensures that each value is placed correctly according to BST rules, rebuilding the tree from its preorder representation.
       </li>
      </ul>
      <h3 id="example">
       Example
      </h3>
      <p>
       Consider the BST:
      </p>
      <div class="language-plaintext highlighter-rouge">
       <div class="highlight">
        <pre class="highlight"><code>    2
   / \
  1   3
</code></pre>
       </div>
      </div>
      <p>
       <strong>
        Serialization
       </strong>
       : The
       <code class="language-plaintext highlighter-rouge">
        serialize
       </code>
       method would produce the string
       <code class="language-plaintext highlighter-rouge">
        "2,1,3"
       </code>
       .
      </p>
      <p>
       <strong>
        Deserialization
       </strong>
       : Given the string
       <code class="language-plaintext highlighter-rouge">
        "2,1,3"
       </code>
       , the
       <code class="language-plaintext highlighter-rouge">
        deserialize
       </code>
       method rebuilds the original BST by ensuring that
       <code class="language-plaintext highlighter-rouge">
        1
       </code>
       is placed as the left child of
       <code class="language-plaintext highlighter-rouge">
        2
       </code>
       and
       <code class="language-plaintext highlighter-rouge">
        3
       </code>
       as the right child, based on their values.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#d85adde6-5041-401d-9c8a-67661bff1657'}">
       <li class="uk-active">
        <a href="solution-449.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-449.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-449.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-449.html">
         Go
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="d85adde6-5041-401d-9c8a-67661bff1657">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Codec</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nums</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">inf</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="o">;</span>

    <span class="c1">// Encodes a tree to a single string.</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">serialize</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">" "</span><span class="o">,</span> <span class="n">nums</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Decodes your encoded data to tree.</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">deserialize</span><span class="o">(</span><span class="nc">String</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">data</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="s">""</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">data</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">));</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(-</span><span class="n">inf</span><span class="o">,</span> <span class="n">inf</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">nums</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">));</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">TreeNode</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">mi</span><span class="o">,</span> <span class="kt">int</span> <span class="n">mx</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">mi</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">mx</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="o">++</span><span class="n">i</span><span class="o">;</span>
        <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">mi</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
        <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">mx</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Your Codec object will be instantiated and called as such:</span>
<span class="c1">// Codec ser = new Codec();</span>
<span class="c1">// Codec deser = new Codec();</span>
<span class="c1">// String tree = ser.serialize(root);</span>
<span class="c1">// TreeNode ans = deser.deserialize(tree);</span>
<span class="c1">// return ans;</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Codec</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Encodes a tree to a single string.</span>
    <span class="n">string</span> <span class="n">serialize</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s">""</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">string</span> <span class="n">data</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">data</span> <span class="o">+=</span> <span class="n">to_string</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="s">" "</span><span class="p">;</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="p">};</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="n">data</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Decodes your encoded data to tree.</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">deserialize</span><span class="p">(</span><span class="n">string</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="sc">' '</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">mi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mx</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mi</span> <span class="o">||</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mx</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
            <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">mi</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
            <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mx</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">split</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">delim</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tokens</span><span class="p">;</span>
        <span class="n">stringstream</span> <span class="n">ss</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="n">string</span> <span class="n">token</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">delim</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">tokens</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">stoi</span><span class="p">(</span><span class="n">token</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">tokens</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Your Codec object will be instantiated and called as such:</span>
<span class="c1">// Codec* ser = new Codec();</span>
<span class="c1">// Codec* deser = new Codec();</span>
<span class="c1">// string tree = ser-&gt;serialize(root);</span>
<span class="c1">// TreeNode* ans = deser-&gt;deserialize(tree);</span>
<span class="c1">// return ans;</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code>
<span class="c1"># Your Codec object will be instantiated and called as such:
# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# tree = ser.serialize(root)
# ans = deser.deserialize(tree)
# return ans
</span>
<span class="k">class</span> <span class="nc">Codec</span><span class="p">:</span>
    <span class="c1"># Encodes a tree to a single string.
</span>    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">sb</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">serializeHelper</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">sb</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">','</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">serializeHelper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">sb</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">sb</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">serializeHelper</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">sb</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">serializeHelper</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">sb</span><span class="p">)</span>

    <span class="c1"># Decodes your encoded data to tree.
</span>    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">deserializeHelper</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s">'-inf'</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">deserializeHelper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">deque</span><span class="p">,</span> <span class="n">lower</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">upper</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="c1"># here is the key, not in sub-tree range then meaning stop
</span>        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">lower</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">upper</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span> <span class="c1"># leave i-node to other tree branches
</span>        <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">deserializeHelper</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">deserializeHelper</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span>


<span class="c1">#################
</span>
<span class="k">class</span> <span class="nc">Codec</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="s">"""Encodes a tree to a single string."""</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">nums</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

        <span class="n">nums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">" "</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">nums</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="s">"""Decodes your encoded data to tree."""</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">mi</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">mx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
            <span class="k">nonlocal</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">mi</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">mx</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span> <span class="c1"># leave i-node to other tree branches
</span>            <span class="n">x</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">mi</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mx</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">root</span>

        <span class="n">nums</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">split</span><span class="p">()))</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="n">inf</span><span class="p">)</span>


<span class="c1">#################
</span>
<span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
</span>

<span class="k">class</span> <span class="nc">Codec</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="s">"""Encodes a tree to a single string."""</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">nonlocal</span> <span class="n">t</span>
            <span class="n">t</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>
            <span class="n">t</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">','</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">''</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
        <span class="s">"""Decodes your encoded data to tree."""</span>

        <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]))</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">break</span>
            <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">root</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">build</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>


<span class="c1"># Your Codec object will be instantiated and called as such:
# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# tree = ser.serialize(root)
# ans = deser.deserialize(tree)
# return ans
</span>
<span class="c1">############
</span>
<span class="c1"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
</span>
<span class="k">class</span> <span class="nc">Codec</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="s">"""Encodes a tree to a single string.
    
    :type root: TreeNode
    :rtype: str
    """</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">root</span><span class="p">)]</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
      <span class="n">pc</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
        <span class="k">continue</span>
      <span class="k">if</span> <span class="n">pc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">))</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">))</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
    <span class="k">return</span> <span class="s">","</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="s">"""Decodes your encoded data to tree.
    
    :type data: str
    :rtype: TreeNode
    """</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">None</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">","</span><span class="p">)</span>
    <span class="n">preOrder</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
    <span class="n">inOrder</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">preOrder</span><span class="p">)</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">preIdx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">inOrder</span><span class="p">)):</span>
      <span class="n">d</span><span class="p">[</span><span class="n">inOrder</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">def</span> <span class="nf">helper</span><span class="p">(</span><span class="n">preOrder</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">inOrder</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">:</span>
        <span class="n">rootVal</span> <span class="o">=</span> <span class="n">preOrder</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">preIdx</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">preIdx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">rootVal</span><span class="p">)</span>
        <span class="n">midPos</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">rootVal</span><span class="p">]</span>
        <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">preOrder</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">midPos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inOrder</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">preOrder</span><span class="p">,</span> <span class="n">midPos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">inOrder</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span>

    <span class="k">return</span> <span class="n">helper</span><span class="p">(</span><span class="n">preOrder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">inOrder</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inOrder</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

<span class="c1"># Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.deserialize(codec.serialize(root))
</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */</span>

<span class="k">type</span> <span class="n">Codec</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Constructor</span><span class="p">()</span> <span class="n">Codec</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">Codec</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c">// Serializes a tree to a single string.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Codec</span><span class="p">)</span> <span class="n">serialize</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">""</span>
	<span class="p">}</span>
	<span class="n">data</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">strings</span><span class="o">.</span><span class="n">Builder</span><span class="p">{}</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="n">data</span><span class="o">.</span><span class="n">WriteString</span><span class="p">(</span><span class="n">strconv</span><span class="o">.</span><span class="n">Itoa</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="p">))</span>
		<span class="n">data</span><span class="o">.</span><span class="n">WriteByte</span><span class="p">(</span><span class="sc">' '</span><span class="p">)</span>
		<span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span>
		<span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">String</span><span class="p">()[</span><span class="m">0</span> <span class="o">:</span> <span class="n">data</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
<span class="p">}</span>

<span class="c">// Deserializes your encoded data to tree.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Codec</span><span class="p">)</span> <span class="n">deserialize</span><span class="p">(</span><span class="n">data</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="n">TreeNode</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="s">""</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">nil</span>
	<span class="p">}</span>
	<span class="n">vals</span> <span class="o">:=</span> <span class="n">strings</span><span class="o">.</span><span class="n">Split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">" "</span><span class="p">)</span>
	<span class="n">i</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">TreeNode</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">mi</span><span class="p">,</span> <span class="n">mx</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">TreeNode</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="no">nil</span>
		<span class="p">}</span>
		<span class="n">x</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">strconv</span><span class="o">.</span><span class="n">Atoi</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
		<span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">mi</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">mx</span> <span class="p">{</span>
			<span class="k">return</span> <span class="no">nil</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">++</span>
		<span class="n">root</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">TreeNode</span><span class="p">{</span><span class="n">Val</span><span class="o">:</span> <span class="n">x</span><span class="p">}</span>
		<span class="n">root</span><span class="o">.</span><span class="n">Left</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">mi</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
		<span class="n">root</span><span class="o">.</span><span class="n">Right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mx</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">root</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">MinInt64</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">MaxInt64</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">/**
 * Your Codec object will be instantiated and called as such:
 * ser := Constructor()
 * deser := Constructor()
 * tree := ser.serialize(root)
 * ans := deser.deserialize(tree)
 * return ans
 */</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-449.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
