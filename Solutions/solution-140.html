<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-140.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-140.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>140 - Word Break II</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 140. Word Break II Description Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order. Note that the same word in...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-140.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-140.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-140.html" rel="stylesheet"/>
   <link href="solution-140.html" rel="stylesheet"/>
   <link href="solution-140.html" rel="stylesheet"/>
   <link href="solution-140.html" rel="stylesheet"/>
   <link href="solution-140.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="140 - Word Break II" property="og:title"/>
   <meta content="Leetcode 140. Word Break II Description Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order. Note that the same word in the dictionary may be reused multiple times in the segmentation. &amp;nbsp; Example 1: Input: s = &amp;quot;catsanddog&amp;quot;, wordDict = [&amp;quot;cat&amp;quot;,&amp;quot;cats&amp;quot;,&amp;quot;and&amp;quot;,&amp;quot;sand&amp;quot;,&amp;quot;dog&amp;quot;] Output: [&amp;quot;cats and dog&amp;quot;,&amp;quot;cat sand dog&amp;quot;] Example 2: Input: s = &amp;quot;pineapplepenapple&amp;quot;, wordDict = [&amp;quot;apple&amp;quot;,&amp;quot;pen&amp;quot;,&amp;quot;applepen&amp;quot;,&amp;quot;pine&amp;quot;,&amp;quot;pineapple&amp;quot;] Output: [&amp;quot;pine apple pen apple&amp;quot;,&amp;quot;pineapple pen apple&amp;quot;,&amp;quot;pine applepen apple&amp;quot;] Explanation: Note that you are allowed to reuse a dictionary word. Example 3: Input: s = &amp;quot;catsandog&amp;quot;, wordDict = [&amp;quot;cats&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;sand&amp;quot;,&amp;quot;and&amp;quot;,&amp;quot;cat&amp;quot;] Output: [] &amp;nbsp; Constraints: 1 &amp;lt;= s.length &amp;lt;= 20 1 &amp;lt;= wordDict.length &amp;lt;= 1000 1 &amp;lt;= wordDict[i].length &amp;lt;= 10 s and wordDict[i] consist of only lowercase English letters. All the strings of wordDict are unique. Input is generated in a way that the length of the answer doesn&amp;#39;t exceed&amp;nbsp;105. Solutions Using a Trie and Depth-First Search (DFS). The goal is to determine how a given string s can be segmented into a space-separated sequence of one or more dictionary words from a given list wordDict. Trie Class Initialization: The Trie node (Trie) is initialized with 26 children (assuming only lowercase letters) and a boolean flag is_end to mark the end of a word. Insert Method: Inserts a word into the Trie. For each character in the word, it calculates the index (idx) corresponding to the characterâs position in the alphabet. If the child at that index doesnât exist, it creates a new Trie node. It then moves to this child node. After inserting the last character of the word, it marks is_end as True to indicate the end of the word. Search Method: Searches for a word in the Trie. Similar to insertion, it calculates the index for each character. If at any point the expected child node is None, it means the word doesnât exist in the Trie, and it returns False. If it successfully traverses the word in the Trie, it checks is_end of the last node to confirm the wordâs presence. Solution Class Word Break Function: This is the main function that utilizes a Trie to solve the word break problem. It first inserts all words from wordDict into the Trie for efficient word lookup. Then it uses a DFS approach to find all possible word combinations that can form the given string s. DFS Function: A helper function that takes a substring of s as input. If the input is empty, it returns a list containing an empty list, representing a successful path. For each possible prefix of the input substring, it checks if the prefix exists in the Trie. If so, it recursively calls itself with the remaining substring. For each result from the recursive call, it appends the current prefix to the front, forming a new path. These paths are accumulated in res. Result Construction: After computing all valid paths..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-04-18T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-04-18-140-Word-Break-II/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-140.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="140 - Word Break II" property="twitter:title"/>
   <meta content="Leetcode 140. Word Break II Description Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order. Note that the same word in the dictionary may be reused multiple times in the segmentation. &amp;nbsp; Example 1: Input: s = &amp;quot;catsanddog&amp;quot;, wordDict = [&amp;quot;cat&amp;quot;,&amp;quot;cats&amp;quot;,&amp;quot;and&amp;quot;,&amp;quot;sand&amp;quot;,&amp;quot;dog&amp;quot;] Output: [&amp;quot;cats and dog&amp;quot;,&amp;quot;cat sand dog&amp;quot;] Example 2: Input: s = &amp;quot;pineapplepenapple&amp;quot;, wordDict = [&amp;quot;apple&amp;quot;,&amp;quot;pen&amp;quot;,&amp;quot;applepen&amp;quot;,&amp;quot;pine&amp;quot;,&amp;quot;pineapple&amp;quot;] Output: [&amp;quot;pine apple pen apple&amp;quot;,&amp;quot;pineapple pen apple&amp;quot;,&amp;quot;pine applepen apple&amp;quot;] Explanation: Note that you are allowed to reuse a dictionary word. Example 3: Input: s = &amp;quot;catsandog&amp;quot;, wordDict = [&amp;quot;cats&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;sand&amp;quot;,&amp;quot;and&amp;quot;,&amp;quot;cat&amp;quot;] Output: [] &amp;nbsp; Constraints: 1 &amp;lt;= s.length &amp;lt;= 20 1 &amp;lt;= wordDict.length &amp;lt;= 1000 1 &amp;lt;= wordDict[i].length &amp;lt;= 10 s and wordDict[i] consist of only lowercase English letters. All the strings of wordDict are unique. Input is generated in a way that the length of the answer doesn&amp;#39;t exceed&amp;nbsp;105. Solutions Using a Trie and Depth-First Search (DFS). The goal is to determine how a given string s can be segmented into a space-separated sequence of one or more dictionary words from a given list wordDict. Trie Class Initialization: The Trie node (Trie) is initialized with 26 children (assuming only lowercase letters) and a boolean flag is_end to mark the end of a word. Insert Method: Inserts a word into the Trie. For each character in the word, it calculates the index (idx) corresponding to the characterâs position in the alphabet. If the child at that index doesnât exist, it creates a new Trie node. It then moves to this child node. After inserting the last character of the word, it marks is_end as True to indicate the end of the word. Search Method: Searches for a word in the Trie. Similar to insertion, it calculates the index for each character. If at any point the expected child node is None, it means the word doesnât exist in the Trie, and it returns False. If it successfully traverses the word in the Trie, it checks is_end of the last node to confirm the wordâs presence. Solution Class Word Break Function: This is the main function that utilizes a Trie to solve the word break problem. It first inserts all words from wordDict into the Trie for efficient word lookup. Then it uses a DFS approach to find all possible word combinations that can form the given string s. DFS Function: A helper function that takes a substring of s as input. If the input is empty, it returns a list containing an empty list, representing a successful path. For each possible prefix of the input substring, it checks if the prefix exists in the Trie. If so, it recursively calls itself with the remaining substring. For each result from the recursive call, it appends the current prefix to the front, forming a new path. These paths are accumulated in res. Result Construction: After computing all valid paths..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    140 - Word Break II | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="140 - Word Break II" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-140.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-04-18-140-Word-Break-II/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-04-18T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"140 - Word Break II","dateModified":"2016-04-18T00:00:00-07:00","datePublished":"2016-04-18T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-04-18-140-Word-Break-II/"},"url":"https://leetcode.ca/2016-04-18-140-Word-Break-II/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="140-word-break-ii">
       <a href="solution-140.html">
        140. Word Break II
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given a string
       <code>
        s
       </code>
       and a dictionary of strings
       <code>
        wordDict
       </code>
       , add spaces in
       <code>
        s
       </code>
       to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in
       <strong>
        any order
       </strong>
       .
      </p>
      <p>
       <strong>
        Note
       </strong>
       that the same word in the dictionary may be reused multiple times in the segmentation.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> s = "catsanddog", wordDict = ["cat","cats","and","sand","dog"]
<strong>Output:</strong> ["cats and dog","cat sand dog"]
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> s = "pineapplepenapple", wordDict = ["apple","pen","applepen","pine","pineapple"]
<strong>Output:</strong> ["pine apple pen apple","pineapple pen apple","pine applepen apple"]
<strong>Explanation:</strong> Note that you are allowed to reuse a dictionary word.
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
<strong>Output:</strong> []
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= s.length &lt;= 20
        </code>
       </li>
       <li>
        <code>
         1 &lt;= wordDict.length &lt;= 1000
        </code>
       </li>
       <li>
        <code>
         1 &lt;= wordDict[i].length &lt;= 10
        </code>
       </li>
       <li>
        <code>
         s
        </code>
        and
        <code>
         wordDict[i]
        </code>
        consist of only lowercase English letters.
       </li>
       <li>
        All the strings of
        <code>
         wordDict
        </code>
        are
        <strong>
         unique
        </strong>
        .
       </li>
       <li>
        Input is generated in a way that the length of the answer doesn't exceed 10
        <sup>
         5
        </sup>
        .
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       Using a Trie and Depth-First Search (DFS). The goal is to determine how a given string
       <code class="language-plaintext highlighter-rouge">
        s
       </code>
       can be segmented into a space-separated sequence of one or more dictionary words from a given list
       <code class="language-plaintext highlighter-rouge">
        wordDict
       </code>
       .
      </p>
      <h3 id="trie-class">
       Trie Class
      </h3>
      <ul>
       <li>
        <p>
         <strong>
          Initialization
         </strong>
         : The Trie node (
         <code class="language-plaintext highlighter-rouge">
          Trie
         </code>
         ) is initialized with 26 children (assuming only lowercase letters) and a boolean flag
         <code class="language-plaintext highlighter-rouge">
          is_end
         </code>
         to mark the end of a word.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Insert Method
         </strong>
         : Inserts a word into the Trie. For each character in the word, it calculates the index (
         <code class="language-plaintext highlighter-rouge">
          idx
         </code>
         ) corresponding to the characterâs position in the alphabet. If the child at that index doesnât exist, it creates a new Trie node. It then moves to this child node. After inserting the last character of the word, it marks
         <code class="language-plaintext highlighter-rouge">
          is_end
         </code>
         as
         <code class="language-plaintext highlighter-rouge">
          True
         </code>
         to indicate the end of the word.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Search Method
         </strong>
         : Searches for a word in the Trie. Similar to insertion, it calculates the index for each character. If at any point the expected child node is
         <code class="language-plaintext highlighter-rouge">
          None
         </code>
         , it means the word doesnât exist in the Trie, and it returns
         <code class="language-plaintext highlighter-rouge">
          False
         </code>
         . If it successfully traverses the word in the Trie, it checks
         <code class="language-plaintext highlighter-rouge">
          is_end
         </code>
         of the last node to confirm the wordâs presence.
        </p>
       </li>
      </ul>
      <h3 id="solution-class">
       Solution Class
      </h3>
      <ul>
       <li>
        <p>
         <strong>
          Word Break Function
         </strong>
         : This is the main function that utilizes a Trie to solve the word break problem. It first inserts all words from
         <code class="language-plaintext highlighter-rouge">
          wordDict
         </code>
         into the Trie for efficient word lookup. Then it uses a DFS approach to find all possible word combinations that can form the given string
         <code class="language-plaintext highlighter-rouge">
          s
         </code>
         .
        </p>
       </li>
       <li>
        <p>
         <strong>
          DFS Function
         </strong>
         : A helper function that takes a substring of
         <code class="language-plaintext highlighter-rouge">
          s
         </code>
         as input. If the input is empty, it returns a list containing an empty list, representing a successful path. For each possible prefix of the input substring, it checks if the prefix exists in the Trie. If so, it recursively calls itself with the remaining substring. For each result from the recursive call, it appends the current prefix to the front, forming a new path. These paths are accumulated in
         <code class="language-plaintext highlighter-rouge">
          res
         </code>
         .
        </p>
       </li>
       <li>
        <p>
         <strong>
          Result Construction
         </strong>
         : After computing all valid paths that break
         <code class="language-plaintext highlighter-rouge">
          s
         </code>
         into words from
         <code class="language-plaintext highlighter-rouge">
          wordDict
         </code>
         , the
         <code class="language-plaintext highlighter-rouge">
          dfs
         </code>
         function returns a list of lists, where each inner list represents a valid word sequence. The main function then joins these words with spaces to form complete sentences and returns them.
        </p>
       </li>
      </ul>
      <p>
       This solution efficiently finds all ways to segment
       <code class="language-plaintext highlighter-rouge">
        s
       </code>
       into a sequence of dictionary words, leveraging the Trie for fast word lookups and DFS for exhaustive search.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#78369718-fc7f-4161-a08b-752ec7a965bb'}">
       <li class="uk-active">
        <a href="solution-140.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-140.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-140.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-140.html">
         C#
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="78369718-fc7f-4161-a08b-752ec7a965bb">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Trie</span> <span class="o">{</span>
    <span class="nc">Trie</span><span class="o">[]</span> <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Trie</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
    <span class="kt">boolean</span> <span class="n">isEnd</span><span class="o">;</span>

    <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">c</span> <span class="o">-=</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Trie</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">node</span><span class="o">.</span><span class="na">isEnd</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">c</span> <span class="o">-=</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">isEnd</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Trie</span> <span class="n">trie</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Trie</span><span class="o">();</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">wordBreak</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordDict</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">w</span> <span class="o">:</span> <span class="n">wordDict</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">trie</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">" "</span><span class="o">,</span> <span class="n">e</span><span class="o">)).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="s">""</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">trie</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">:</span> <span class="n">dfs</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
                    <span class="n">v</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">));</span>
                    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">is_end</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">node</span><span class="p">.</span><span class="n">is_end</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">is_end</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">wordBreak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wordDict</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[[]]</span> <span class="c1"># list of list
</span>            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span> <span class="c1"># starts from 1, i is excluded in s[:i]
</span>                <span class="k">if</span> <span class="n">trie</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="n">s</span><span class="p">[:</span><span class="n">i</span><span class="p">]):</span>
                    <span class="c1"># if below dfs() returns empty, then returned res also empty
</span>                    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dfs</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:]):</span>
                        <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">s</span><span class="p">[:</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="c1"># [1] + [2,3] ==&gt; [1, 2, 3]
</span>            <span class="k">return</span> <span class="n">res</span>

        <span class="n">trie</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wordDict</span><span class="p">:</span>
            <span class="n">trie</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="s">' '</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ans</span><span class="p">]</span>

<span class="c1">#############
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">wordBreak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">wordDict</span><span class="p">):</span>
        <span class="s">"""
        :type s: str
        :type wordDict: Set[str]
        :rtype: List[str]
        """</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">check_word_break</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">wordDict</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s">""</span><span class="p">)]</span>
        <span class="n">slen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">len_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wordDict</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">tmp_queue</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">q</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">len_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">start</span> <span class="o">+</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">slen</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="ow">in</span> <span class="n">wordDict</span><span class="p">:</span>
                        <span class="n">new_node</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">l</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">l</span><span class="p">])</span>
                        <span class="n">tmp_queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">start</span> <span class="o">+</span> <span class="n">l</span> <span class="o">==</span> <span class="n">slen</span><span class="p">:</span>
                            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_node</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="n">tmp_queue</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">check_word_break</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">wordDict</span><span class="p">):</span>
        <span class="s">"""
        :type s: str
        :type wordDict: Set[str]
        :rtype: bool
        """</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">slen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">len_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wordDict</span><span class="p">)</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">slen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">tmp_queue</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">len_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="ow">in</span> <span class="n">wordDict</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">start</span> <span class="o">+</span> <span class="n">l</span> <span class="o">==</span> <span class="n">slen</span><span class="p">:</span>
                            <span class="k">return</span> <span class="bp">True</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">start</span> <span class="o">+</span> <span class="n">l</span><span class="p">]:</span>
                            <span class="n">tmp_queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">l</span><span class="p">)</span>
                            <span class="n">visited</span><span class="p">[</span><span class="n">start</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="n">tmp_queue</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">type</span> <span class="n">Trie</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">children</span> <span class="p">[</span><span class="m">26</span><span class="p">]</span><span class="o">*</span><span class="n">Trie</span>
	<span class="n">isEnd</span>    <span class="kt">bool</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">newTrie</span><span class="p">()</span> <span class="o">*</span><span class="n">Trie</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">Trie</span><span class="p">{}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Trie</span><span class="p">)</span> <span class="n">insert</span><span class="p">(</span><span class="n">word</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">this</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">word</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">-=</span> <span class="sc">'a'</span>
		<span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">newTrie</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="n">node</span><span class="o">.</span><span class="n">isEnd</span> <span class="o">=</span> <span class="no">true</span>
<span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Trie</span><span class="p">)</span> <span class="n">search</span><span class="p">(</span><span class="n">word</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">this</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">word</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">-=</span> <span class="sc">'a'</span>
		<span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="no">false</span>
		<span class="p">}</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">isEnd</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">wordBreak</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">,</span> <span class="n">wordDict</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="n">trie</span> <span class="o">:=</span> <span class="n">newTrie</span><span class="p">()</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">w</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">wordDict</span> <span class="p">{</span>
		<span class="n">trie</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">string</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">string</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">string</span><span class="p">{}</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{})</span>
			<span class="k">return</span> <span class="n">res</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">trie</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">:</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">dfs</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">:</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">v</span> <span class="o">=</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="n">s</span><span class="p">[</span><span class="o">:</span><span class="n">i</span><span class="p">]},</span> <span class="n">v</span><span class="o">...</span><span class="p">)</span>
					<span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">res</span>
	<span class="p">}</span>
	<span class="n">res</span> <span class="o">:=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
	<span class="n">ans</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">res</span> <span class="p">{</span>
		<span class="n">ans</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">strings</span><span class="o">.</span><span class="n">Join</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s">" "</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ans</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Linq</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Text</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Node</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Index1</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Index2</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">IList</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">WordBreak</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">IList</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">wordDict</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">paths</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;&gt;[</span><span class="n">s</span><span class="p">.</span><span class="n">Length</span> <span class="p">+</span> <span class="m">1</span><span class="p">];</span>
        <span class="n">paths</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">Length</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;&gt;</span> <span class="p">{</span> <span class="n">Tuple</span><span class="p">.</span><span class="nf">Create</span><span class="p">(-</span><span class="m">1</span><span class="p">,</span> <span class="p">(</span><span class="kt">string</span><span class="p">)</span><span class="k">null</span><span class="p">)</span> <span class="p">};</span>
        <span class="kt">var</span> <span class="n">wordDictGroup</span> <span class="p">=</span> <span class="n">wordDict</span><span class="p">.</span><span class="nf">GroupBy</span><span class="p">(</span><span class="n">word</span> <span class="p">=&gt;</span> <span class="n">word</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="p">&gt;=</span> <span class="m">0</span><span class="p">;</span> <span class="p">--</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">paths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;&gt;();</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">wordGroup</span> <span class="k">in</span> <span class="n">wordDictGroup</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">wordLength</span> <span class="p">=</span> <span class="n">wordGroup</span><span class="p">.</span><span class="n">Key</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">+</span> <span class="n">wordLength</span> <span class="p">&lt;=</span> <span class="n">s</span><span class="p">.</span><span class="n">Length</span> <span class="p">&amp;&amp;</span> <span class="n">paths</span><span class="p">[</span><span class="n">i</span> <span class="p">+</span> <span class="n">wordLength</span><span class="p">].</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">word</span> <span class="k">in</span> <span class="n">wordGroup</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="nf">Substring</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">wordLength</span><span class="p">)</span> <span class="p">==</span> <span class="n">word</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">paths</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">Add</span><span class="p">(</span><span class="n">Tuple</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="n">i</span> <span class="p">+</span> <span class="n">wordLength</span><span class="p">,</span> <span class="n">word</span><span class="p">));</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nf">GenerateResults</span><span class="p">(</span><span class="n">paths</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="n">IList</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">GenerateResults</span><span class="p">(</span><span class="n">List</span><span class="p">&lt;</span><span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;&gt;[]</span> <span class="n">paths</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">results</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
        <span class="kt">var</span> <span class="n">sb</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">StringBuilder</span><span class="p">();</span>
        <span class="kt">var</span> <span class="n">stack</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="p">&lt;</span><span class="n">Node</span><span class="p">&gt;();</span>
        <span class="n">stack</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="k">new</span> <span class="nf">Node</span><span class="p">());</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">node</span> <span class="p">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">Peek</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Index1</span> <span class="p">==</span> <span class="n">paths</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="m">1</span> <span class="p">||</span> <span class="n">node</span><span class="p">.</span><span class="n">Index2</span> <span class="p">==</span> <span class="n">paths</span><span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">Index1</span><span class="p">].</span><span class="n">Count</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Index1</span> <span class="p">==</span> <span class="n">paths</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">results</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">sb</span><span class="p">.</span><span class="nf">ToString</span><span class="p">());</span>
                <span class="p">}</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">Pop</span><span class="p">();</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="kt">var</span> <span class="n">parent</span> <span class="p">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">Peek</span><span class="p">();</span>
                    <span class="kt">var</span> <span class="n">length</span> <span class="p">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">parent</span><span class="p">.</span><span class="n">Index1</span><span class="p">][</span><span class="n">parent</span><span class="p">.</span><span class="n">Index2</span> <span class="p">-</span> <span class="m">1</span><span class="p">].</span><span class="n">Item2</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="p">&lt;</span> <span class="n">sb</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span> <span class="p">++</span><span class="n">length</span><span class="p">;</span>
                    <span class="n">sb</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="n">sb</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="n">length</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">newNode</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span> <span class="n">Index1</span> <span class="p">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">Index1</span><span class="p">][</span><span class="n">node</span><span class="p">.</span><span class="n">Index2</span><span class="p">].</span><span class="n">Item1</span><span class="p">,</span> <span class="n">Index2</span> <span class="p">=</span> <span class="m">0</span> <span class="p">};</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="p">.</span><span class="n">Length</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">sb</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">sb</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">Index1</span><span class="p">][</span><span class="n">node</span><span class="p">.</span><span class="n">Index2</span><span class="p">].</span><span class="n">Item2</span><span class="p">);</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="n">newNode</span><span class="p">);</span>
                <span class="p">++</span><span class="n">node</span><span class="p">.</span><span class="n">Index2</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">results</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-140.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
