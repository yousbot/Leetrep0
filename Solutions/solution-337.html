<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-337.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-337.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>337 - House Robber III</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode Question Formatted question description: https://leetcode.ca/all/337.html The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root. Besides the root, each house has one and only one parent house. After a tour, the smart thief...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-337.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-337.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-337.html" rel="stylesheet"/>
   <link href="solution-337.html" rel="stylesheet"/>
   <link href="solution-337.html" rel="stylesheet"/>
   <link href="solution-337.html" rel="stylesheet"/>
   <link href="solution-337.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="337 - House Robber III" property="og:title"/>
   <meta content="Leetcode Question Formatted question description: https://leetcode.ca/all/337.html The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root. Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night. Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police. &amp;nbsp; Example 1: Input: root = [3,2,3,null,3,null,1] Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: Input: root = [3,4,5,1,3,null,1] Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. &amp;nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. 0 &amp;lt;= Node.val &amp;lt;= 104 Algorithm Key Ideas: The solution uses a Depth-First Search (DFS) approach with memoization (caching) to efficiently calculate the maximum amount of money that can be robbed. It considers two scenarios at each node: The current node is robbed (isCurrentRootRobbed is True). The current node is not robbed (isCurrentRootRobbed is False). The solution maximizes the total amount by choosing the best scenario at each node. Detailed Explanation: Base Case: If the current node (root) is None, the function returns 0 since there is no money to rob. DFS with Two Scenarios: When isCurrentRootRobbed is True, it means the current node is being robbed. Therefore, the children of the current node cannot be robbed due to the problemâs adjacency constraint. The total amount in this scenario is the value of the current node plus the optimal amounts from not robbing its left and right children. When isCurrentRootRobbed is False, it means the current node is not being robbed. Thus, the optimal amount from this node is the sum of the optimal amounts from either robbing or not robbing its left and right children. This is calculated by calling self.rob(root.left) and self.rob(root.right). Memoization (@cache): The @cache decorator from Pythonâs functools library caches the results of expensive function calls and returns the cached result when the same inputs occur again. This significantly reduces the number of calculations by avoiding redundant DFS calls for the same subtree and scenario. This memoization is crucial for the solution to meet the time constraints of the problem, as it prevents the exponential blow-up in runtime that would occur from recalculating the optimal robbery plan for each subtree multiple times. Note on a common-sense mistake on this question The example given above seems to be stolen every other node, but in fact it is not necessarily only every other, such as the following example 4 / 1 / 2 / 3 If you steal one by every other node, then 4+2=6 or 1+3=4. In fact, the optimal solution should be 4+3=7,..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-11-01T22:21:01-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-11-01-337-House-Robber-III/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-337.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="337 - House Robber III" property="twitter:title"/>
   <meta content="Leetcode Question Formatted question description: https://leetcode.ca/all/337.html The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root. Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night. Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police. &amp;nbsp; Example 1: Input: root = [3,2,3,null,3,null,1] Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: Input: root = [3,4,5,1,3,null,1] Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. &amp;nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. 0 &amp;lt;= Node.val &amp;lt;= 104 Algorithm Key Ideas: The solution uses a Depth-First Search (DFS) approach with memoization (caching) to efficiently calculate the maximum amount of money that can be robbed. It considers two scenarios at each node: The current node is robbed (isCurrentRootRobbed is True). The current node is not robbed (isCurrentRootRobbed is False). The solution maximizes the total amount by choosing the best scenario at each node. Detailed Explanation: Base Case: If the current node (root) is None, the function returns 0 since there is no money to rob. DFS with Two Scenarios: When isCurrentRootRobbed is True, it means the current node is being robbed. Therefore, the children of the current node cannot be robbed due to the problemâs adjacency constraint. The total amount in this scenario is the value of the current node plus the optimal amounts from not robbing its left and right children. When isCurrentRootRobbed is False, it means the current node is not being robbed. Thus, the optimal amount from this node is the sum of the optimal amounts from either robbing or not robbing its left and right children. This is calculated by calling self.rob(root.left) and self.rob(root.right). Memoization (@cache): The @cache decorator from Pythonâs functools library caches the results of expensive function calls and returns the cached result when the same inputs occur again. This significantly reduces the number of calculations by avoiding redundant DFS calls for the same subtree and scenario. This memoization is crucial for the solution to meet the time constraints of the problem, as it prevents the exponential blow-up in runtime that would occur from recalculating the optimal robbery plan for each subtree multiple times. Note on a common-sense mistake on this question The example given above seems to be stolen every other node, but in fact it is not necessarily only every other, such as the following example 4 / 1 / 2 / 3 If you steal one by every other node, then 4+2=6 or 1+3=4. In fact, the optimal solution should be 4+3=7,..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    337 - House Robber III | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="337 - House Robber III" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-337.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-11-01-337-House-Robber-III/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-11-01T22:21:01-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"337 - House Robber III","dateModified":"2016-11-01T22:21:01-07:00","datePublished":"2016-11-01T22:21:01-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-11-01-337-House-Robber-III/"},"url":"https://leetcode.ca/2016-11-01-337-House-Robber-III/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="question">
       Question
      </h1>
      <p>
       Formatted question description:
       <a href="solution-337.html">
        https://leetcode.ca/all/337.html
       </a>
      </p>
      <p>
       The thief has found himself a new place for his thievery again. There is only one entrance to this area, called
       <code>
        root
       </code>
       .
      </p>
      <p>
       Besides the
       <code>
        root
       </code>
       , each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if
       <strong>
        two directly-linked houses were broken into on the same night
       </strong>
       .
      </p>
      <p>
       Given the
       <code>
        root
       </code>
       of the binary tree, return
       <em>
        the maximum amount of money the thief can rob
        <strong>
         without alerting the police
        </strong>
       </em>
       .
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0300-0399/0337.House%20Robber%20III/images/rob1-tree.jpg" style="width: 277px; height: 293px;"/>
      </p>
      <pre>
<strong>Input:</strong> root = [3,2,3,null,3,null,1]
<strong>Output:</strong> 7
<strong>Explanation:</strong> Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0300-0399/0337.House%20Robber%20III/images/rob2-tree.jpg" style="width: 357px; height: 293px;"/>
      </p>
      <pre>
<strong>Input:</strong> root = [3,4,5,1,3,null,1]
<strong>Output:</strong> 9
<strong>Explanation:</strong> Maximum amount of money the thief can rob = 4 + 5 = 9.
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the tree is in the range
        <code>
         [1, 10
         <sup>
          4
         </sup>
         ]
        </code>
        .
       </li>
       <li>
        <code>
         0 &lt;= Node.val &lt;= 10
         <sup>
          4
         </sup>
        </code>
       </li>
      </ul>
      <h1 id="algorithm">
       Algorithm
      </h1>
      <p>
       Key Ideas:
      </p>
      <ul>
       <li>
        The solution uses a Depth-First Search (DFS) approach with memoization (caching) to efficiently calculate the maximum amount of money that can be robbed.
       </li>
       <li>
        It considers two scenarios at each node:
        <ol>
         <li>
          The current node is robbed (
          <code class="language-plaintext highlighter-rouge">
           isCurrentRootRobbed
          </code>
          is
          <code class="language-plaintext highlighter-rouge">
           True
          </code>
          ).
         </li>
         <li>
          The current node is not robbed (
          <code class="language-plaintext highlighter-rouge">
           isCurrentRootRobbed
          </code>
          is
          <code class="language-plaintext highlighter-rouge">
           False
          </code>
          ).
         </li>
        </ol>
       </li>
       <li>
        The solution maximizes the total amount by choosing the best scenario at each node.
       </li>
      </ul>
      <p>
       Detailed Explanation:
      </p>
      <ol>
       <li>
        <p>
         <strong>
          Base Case
         </strong>
         : If the current node (
         <code class="language-plaintext highlighter-rouge">
          root
         </code>
         ) is
         <code class="language-plaintext highlighter-rouge">
          None
         </code>
         , the function returns 0 since there is no money to rob.
        </p>
       </li>
       <li>
        <strong>
         DFS with Two Scenarios
        </strong>
        :
        <ul>
         <li>
          When
          <code class="language-plaintext highlighter-rouge">
           isCurrentRootRobbed
          </code>
          is
          <code class="language-plaintext highlighter-rouge">
           True
          </code>
          , it means the current node is being robbed. Therefore, the children of the current node cannot be robbed due to the problemâs adjacency constraint. The total amount in this scenario is the value of the current node plus the optimal amounts from not robbing its left and right children.
         </li>
         <li>
          When
          <code class="language-plaintext highlighter-rouge">
           isCurrentRootRobbed
          </code>
          is
          <code class="language-plaintext highlighter-rouge">
           False
          </code>
          , it means the current node is not being robbed. Thus, the optimal amount from this node is the sum of the optimal amounts from either robbing or not robbing its left and right children. This is calculated by calling
          <code class="language-plaintext highlighter-rouge">
           self.rob(root.left)
          </code>
          and
          <code class="language-plaintext highlighter-rouge">
           self.rob(root.right)
          </code>
          .
         </li>
        </ul>
       </li>
       <li>
        <strong>
         Memoization (@cache)
        </strong>
        :
        <ul>
         <li>
          The
          <code class="language-plaintext highlighter-rouge">
           @cache
          </code>
          decorator from Pythonâs functools library caches the results of expensive function calls and returns the cached result when the same inputs occur again. This significantly reduces the number of calculations by avoiding redundant DFS calls for the same subtree and scenario.
         </li>
         <li>
          This memoization is crucial for the solution to meet the time constraints of the problem, as it prevents the exponential blow-up in runtime that would occur from recalculating the optimal robbery plan for each subtree multiple times.
         </li>
        </ul>
       </li>
      </ol>
      <h1 id="note-on-a-common-sense-mistake-on-this-question">
       <code class="language-plaintext highlighter-rouge">
        Note
       </code>
       on a common-sense mistake on this question
      </h1>
      <p>
       The example given above seems to be stolen every other node, but in fact it is not necessarily only every other, such as the following example
      </p>
      <div class="language-plaintext highlighter-rouge">
       <div class="highlight">
        <pre class="highlight"><code>        4
       /
      1
     /
    2
   /
  3
</code></pre>
       </div>
      </div>
      <p>
       If you steal one by every other node, then
       <code class="language-plaintext highlighter-rouge">
        4+2=6
       </code>
       or
       <code class="language-plaintext highlighter-rouge">
        1+3=4
       </code>
       . In fact, the optimal solution should be
       <code class="language-plaintext highlighter-rouge">
        4+3=7
       </code>
       , which is two times apart, so it is purely how to get it. Then this kind of problem is a typical recursive problem. Can be done using backtracking.
      </p>
      <h1 id="code">
       Code
      </h1>
      <ul class="uk-tab" data-uk-switcher="{connect:'#c4687f2b-8e70-4262-8a59-87e10aec0fab'}">
       <li class="uk-active">
        <a href="solution-337.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-337.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-337.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-337.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-337.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="c4687f2b-8e70-4262-8a59-87e10aec0fab">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">House_Robber_III</span> <span class="o">{</span>
    <span class="cm">/**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode(int x) { val = x; }
     * }
     */</span>


    <span class="kd">class</span> <span class="nc">Solution_singleRecursion</span> <span class="o">{</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>

            <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="kc">true</span><span class="o">),</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="kc">false</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="kd">private</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isCurrentRootRobbed</span><span class="o">)</span> <span class="o">{</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">isCurrentRootRobbed</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span> <span class="o">+</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// child can be either rob or no-rob</span>
                <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="kc">true</span><span class="o">),</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="kc">false</span><span class="o">))</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="kc">true</span><span class="o">),</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="kc">false</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
        <span class="cm">/*
            1. node value can be negative?

         */</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">target</span><span class="o">(</span><span class="n">root</span><span class="o">),</span> <span class="n">skip</span><span class="o">(</span><span class="n">root</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="kd">private</span> <span class="kt">int</span> <span class="nf">target</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">skip</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">skip</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">private</span> <span class="kt">int</span> <span class="nf">skip</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// @note: not target, but rob again =&gt; å ä¸ºçè®ºä¸å¯ä»¥è¿ç»­skipä¸¤å±</span>
<span class="c1">//            return target(root.left) + target(root.right);</span>
            <span class="k">return</span> <span class="nf">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">rob</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">/////////</span>

<span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">memo</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">memo</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">root</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">memo</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">b</span> <span class="o">+=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">b</span> <span class="o">+=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
        <span class="n">memo</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1">// OJ: https://leetcode.com/problems/house-robber-iii/</span>
<span class="c1">// Time: O(N)</span>
<span class="c1">// Space: O(H)</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// rob, skip</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
        <span class="k">auto</span> <span class="p">[</span><span class="n">lr</span><span class="p">,</span> <span class="n">ls</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="k">auto</span> <span class="p">[</span><span class="n">rr</span><span class="p">,</span> <span class="n">rs</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">{</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="n">ls</span> <span class="o">+</span> <span class="n">rs</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">lr</span><span class="p">,</span> <span class="n">ls</span><span class="p">)</span> <span class="o">+</span> <span class="n">max</span><span class="p">(</span><span class="n">rr</span><span class="p">,</span> <span class="n">rs</span><span class="p">)</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">rob</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-python highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">rob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="bp">True</span><span class="p">),</span> <span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="bp">False</span><span class="p">))</span>

    <span class="c1"># if no cache, then running time over limit
</span>    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">isCurrentRootRobbed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">isCurrentRootRobbed</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">rob</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">rob</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="c1"># below else logic also passing OJ
</span>            <span class="c1"># return max(self.dfs(root.left, True), self.dfs(root.left, False)) + max(self.dfs(root.right, True), self.dfs(root.right, False))
</span>
<span class="c1">###########
</span>
<span class="c1"># better and concise
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span> <span class="c1"># post-order
</span>    <span class="k">def</span> <span class="nf">rob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">),</span> <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">rob</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">left</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">right</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># [1] meaming left/right children skippted
</span>            <span class="n">skip</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rob</span><span class="p">,</span> <span class="n">skip</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>


<span class="c1">###########
</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span> <span class="c1"># return in else is too lengthy...
</span>    <span class="k">def</span> <span class="nf">rob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="bp">True</span><span class="p">),</span> <span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="bp">False</span><span class="p">))</span>

    <span class="c1"># if no cache, then running time over limit
</span>    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">isCurrentRootRobbed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">isCurrentRootRobbed</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">True</span><span class="p">),</span> <span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">False</span><span class="p">))</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="bp">True</span><span class="p">),</span> <span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="bp">False</span><span class="p">))</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */</span>
<span class="k">func</span> <span class="n">rob</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">memo</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="kt">int</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="m">0</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">memo</span><span class="p">[</span><span class="n">root</span><span class="p">];</span> <span class="n">ok</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="n">a</span> <span class="o">:=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span> <span class="o">+</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
		<span class="n">b</span> <span class="o">:=</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span>
		<span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">Left</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">b</span> <span class="o">+=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span> <span class="o">+</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">Right</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">b</span> <span class="o">+=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span> <span class="o">+</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="n">res</span> <span class="o">:=</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
		<span class="n">memo</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
		<span class="k">return</span> <span class="n">res</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">b</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>

<span class="kd">function</span> <span class="nx">rob</span><span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">number</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="kd">const</span> <span class="p">[</span><span class="nx">la</span><span class="p">,</span> <span class="nx">lb</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
        <span class="kd">const</span> <span class="p">[</span><span class="nx">ra</span><span class="p">,</span> <span class="nx">rb</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">[</span><span class="nx">root</span><span class="p">.</span><span class="nx">val</span> <span class="o">+</span> <span class="nx">lb</span> <span class="o">+</span> <span class="nx">rb</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">la</span><span class="p">,</span> <span class="nx">lb</span><span class="p">)</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">ra</span><span class="p">,</span> <span class="nx">rb</span><span class="p">)];</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...</span><span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">));</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-337.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
