<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-297.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-297.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>297 - Serialize and Deserialize Binary Tree</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 297. Serialize and Deserialize Binary Tree Description Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-297.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-297.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-297.html" rel="stylesheet"/>
   <link href="solution-297.html" rel="stylesheet"/>
   <link href="solution-297.html" rel="stylesheet"/>
   <link href="solution-297.html" rel="stylesheet"/>
   <link href="solution-297.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="297 - Serialize and Deserialize Binary Tree" property="og:title"/>
   <meta content='Leetcode 297. Serialize and Deserialize Binary Tree Description Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. &amp;nbsp; Example 1: Input: root = [1,2,3,null,null,4,5] Output: [1,2,3,null,null,4,5] Example 2: Input: root = [] Output: [] &amp;nbsp; Constraints: The number of nodes in the tree is in the range [0, 104]. -1000 &amp;lt;= Node.val &amp;lt;= 1000 Solutions Pre-order traversal method. For serialization, we start from the root node. If the node exists, store the value in the output string stream, and then recursively call the serialization function on its left and right child nodes. For deserialization, we first read in the first character to generate a root node, and then recursively call the deserialization function on the left and right child nodes of the root node. Java C++ Python TypeScript Javascript RenderScript Go C# /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ public class Codec { private static final String NULL = "#"; private static final String SEP = ","; // Encodes a tree to a single string. public String serialize(TreeNode root) { if (root == null) { return ""; } StringBuilder sb = new StringBuilder(); preorder(root, sb); return sb.toString(); } private void preorder(TreeNode root, StringBuilder sb) { if (root == null) { sb.append(NULL + SEP); return; } sb.append(root.val + SEP); preorder(root.left, sb); preorder(root.right, sb); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { if (data == null || "".equals(data)) { return null; } List&amp;lt;String&amp;gt; vals = new LinkedList&amp;lt;&amp;gt;(); for (String x : data.split(SEP)) { vals.add(x); } return deserialize(vals); } private TreeNode deserialize(List&amp;lt;String&amp;gt; vals) { String first = vals.remove(0); if (NULL.equals(first)) { return null; } TreeNode root = new TreeNode(Integer.parseInt(first)); root.left = deserialize(vals); root.right = deserialize(vals); return root; } } // Your Codec object will be instantiated and called as such: // Codec ser = new Codec(); // Codec deser = new Codec(); // TreeNode ans = deser.deserialize(ser.serialize(root)); /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Codec { public: // Encodes a tree to a single...' property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-09-22T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-09-22-297-Serialize-and-Deserialize-Binary-Tree/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-297.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="297 - Serialize and Deserialize Binary Tree" property="twitter:title"/>
   <meta content='Leetcode 297. Serialize and Deserialize Binary Tree Description Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. &amp;nbsp; Example 1: Input: root = [1,2,3,null,null,4,5] Output: [1,2,3,null,null,4,5] Example 2: Input: root = [] Output: [] &amp;nbsp; Constraints: The number of nodes in the tree is in the range [0, 104]. -1000 &amp;lt;= Node.val &amp;lt;= 1000 Solutions Pre-order traversal method. For serialization, we start from the root node. If the node exists, store the value in the output string stream, and then recursively call the serialization function on its left and right child nodes. For deserialization, we first read in the first character to generate a root node, and then recursively call the deserialization function on the left and right child nodes of the root node. Java C++ Python TypeScript Javascript RenderScript Go C# /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ public class Codec { private static final String NULL = "#"; private static final String SEP = ","; // Encodes a tree to a single string. public String serialize(TreeNode root) { if (root == null) { return ""; } StringBuilder sb = new StringBuilder(); preorder(root, sb); return sb.toString(); } private void preorder(TreeNode root, StringBuilder sb) { if (root == null) { sb.append(NULL + SEP); return; } sb.append(root.val + SEP); preorder(root.left, sb); preorder(root.right, sb); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { if (data == null || "".equals(data)) { return null; } List&amp;lt;String&amp;gt; vals = new LinkedList&amp;lt;&amp;gt;(); for (String x : data.split(SEP)) { vals.add(x); } return deserialize(vals); } private TreeNode deserialize(List&amp;lt;String&amp;gt; vals) { String first = vals.remove(0); if (NULL.equals(first)) { return null; } TreeNode root = new TreeNode(Integer.parseInt(first)); root.left = deserialize(vals); root.right = deserialize(vals); return root; } } // Your Codec object will be instantiated and called as such: // Codec ser = new Codec(); // Codec deser = new Codec(); // TreeNode ans = deser.deserialize(ser.serialize(root)); /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Codec { public: // Encodes a tree to a single...' property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    297 - Serialize and Deserialize Binary Tree | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="297 - Serialize and Deserialize Binary Tree" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-297.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-09-22-297-Serialize-and-Deserialize-Binary-Tree/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-09-22T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"297 - Serialize and Deserialize Binary Tree","dateModified":"2016-09-22T00:00:00-07:00","datePublished":"2016-09-22T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-09-22-297-Serialize-and-Deserialize-Binary-Tree/"},"url":"https://leetcode.ca/2016-09-22-297-Serialize-and-Deserialize-Binary-Tree/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="297-serialize-and-deserialize-binary-tree">
       <a href="solution-297.html">
        297. Serialize and Deserialize Binary Tree
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
      </p>
      <p>
       Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.
      </p>
      <p>
       <strong>
        Clarification:
       </strong>
       The input/output format is the same as
       <a href="solution-297.html" target="_blank">
        how LeetCode serializes a binary tree
       </a>
       . You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0297.Serialize%20and%20Deserialize%20Binary%20Tree/images/serdeser.jpg" style="width: 442px; height: 324px;"/>
      </p>
      <pre>
<strong>Input:</strong> root = [1,2,3,null,null,4,5]
<strong>Output:</strong> [1,2,3,null,null,4,5]
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the tree is in the range
        <code>
         [0, 10
         <sup>
          4
         </sup>
         ]
        </code>
        .
       </li>
       <li>
        <code>
         -1000 &lt;= Node.val &lt;= 1000
        </code>
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       Pre-order traversal method.
      </p>
      <p>
       For serialization, we start from the root node. If the node exists, store the value in the output string stream, and then recursively call the serialization function on its left and right child nodes.
      </p>
      <p>
       For deserialization, we first read in the first character to generate a root node, and then recursively call the deserialization function on the left and right child nodes of the root node.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#a1c1ae7d-3a98-4e5b-9331-63e633c07628'}">
       <li class="uk-active">
        <a href="solution-297.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-297.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-297.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-297.html">
         TypeScript
        </a>
       </li>
       <li>
        <a href="solution-297.html">
         Javascript
        </a>
       </li>
       <li>
        <a href="solution-297.html">
         RenderScript
        </a>
       </li>
       <li>
        <a href="solution-297.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-297.html">
         C#
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="a1c1ae7d-3a98-4e5b-9331-63e633c07628">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Codec</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">NULL</span> <span class="o">=</span> <span class="s">"#"</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SEP</span> <span class="o">=</span> <span class="s">","</span><span class="o">;</span>

    <span class="c1">// Encodes a tree to a single string.</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">serialize</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="n">preorder</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">sb</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">preorder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="no">NULL</span> <span class="o">+</span> <span class="no">SEP</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="no">SEP</span><span class="o">);</span>
        <span class="n">preorder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">sb</span><span class="o">);</span>
        <span class="n">preorder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">sb</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Decodes your encoded data to tree.</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">deserialize</span><span class="o">(</span><span class="nc">String</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">data</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="s">""</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">data</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">vals</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">x</span> <span class="o">:</span> <span class="n">data</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="no">SEP</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">vals</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">deserialize</span><span class="o">(</span><span class="n">vals</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">TreeNode</span> <span class="nf">deserialize</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">vals</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">first</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="no">NULL</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">first</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">first</span><span class="o">));</span>
        <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">deserialize</span><span class="o">(</span><span class="n">vals</span><span class="o">);</span>
        <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">deserialize</span><span class="o">(</span><span class="n">vals</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Your Codec object will be instantiated and called as such:</span>
<span class="c1">// Codec ser = new Codec();</span>
<span class="c1">// Codec deser = new Codec();</span>
<span class="c1">// TreeNode ans = deser.deserialize(ser.serialize(root));</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Codec</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Encodes a tree to a single string.</span>
    <span class="n">string</span> <span class="n">serialize</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="s">""</span><span class="p">;</span>
        <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
        <span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">preorder</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">"# "</span><span class="p">;</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">to_string</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="s">" "</span><span class="p">;</span>
            <span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
            <span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Decodes your encoded data to tree.</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">deserialize</span><span class="p">(</span><span class="n">string</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="s">""</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">stringstream</span> <span class="n">ss</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">deserialize</span><span class="p">(</span><span class="n">ss</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">deserialize</span><span class="p">(</span><span class="n">stringstream</span><span class="o">&amp;</span> <span class="n">ss</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">first</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="s">"#"</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">stoi</span><span class="p">(</span><span class="n">first</span><span class="p">));</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">deserialize</span><span class="p">(</span><span class="n">ss</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">deserialize</span><span class="p">(</span><span class="n">ss</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Your Codec object will be instantiated and called as such:</span>
<span class="c1">// Codec ser, deser;</span>
<span class="c1">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
</span>

<span class="k">class</span> <span class="nc">Codec</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="s">"""Encodes a tree to a single string.

        :type root: TreeNode
        :rtype: str
        """</span>

        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">''</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"#,"</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="s">","</span><span class="p">)</span>
            <span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

        <span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="s">"""Decodes your encoded data to tree.

        :type data: str
        :rtype: TreeNode
        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">vals</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">first</span> <span class="o">==</span> <span class="s">'#'</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">first</span><span class="p">),</span> <span class="n">inner</span><span class="p">(),</span> <span class="n">inner</span><span class="p">())</span> 
            <span class="c1"># seems using a constructor __init__(val, left, right)
</span>
        <span class="k">return</span> <span class="n">inner</span><span class="p">()</span>


<span class="c1"># Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))
</span>
<span class="c1">############
</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="c1"># bfs, each level based
</span><span class="k">class</span> <span class="nc">Codec</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="s">"""Encodes a tree to a single string.

        :type root: TreeNode
        :rtype: str
        """</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">top</span><span class="p">:</span>
                <span class="n">ret</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"None"</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">top</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>
            <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">","</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="s">"""Decodes your encoded data to tree.

        :type data: str
        :rtype: TreeNode
        """</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">","</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">"None"</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">queue</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s">"None"</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s">"None"</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

            <span class="n">top</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
            <span class="n">top</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

        <span class="k">return</span> <span class="n">root</span>

<span class="c1"># Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.deserialize(codec.serialize(root))
</span></code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>

<span class="cm">/*
 * Encodes a tree to a single string.
 */</span>
<span class="kd">function</span> <span class="nx">serialize</span><span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">root</span><span class="p">;</span>
    <span class="k">return</span> <span class="s2">`</span><span class="p">${</span><span class="nx">val</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">serialize</span><span class="p">(</span><span class="nx">left</span><span class="p">)}</span><span class="s2">,</span><span class="p">${</span><span class="nx">serialize</span><span class="p">(</span><span class="nx">right</span><span class="p">)}</span><span class="s2">`</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
 * Decodes your encoded data to tree.
 */</span>
<span class="kd">function</span> <span class="nx">deserialize</span><span class="p">(</span><span class="nx">data</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">vals</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">,</span><span class="dl">'</span><span class="p">).</span><span class="nx">reverse</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">renew</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">val</span> <span class="o">=</span> <span class="nx">vals</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">val</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="nx">val</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">TreeNode</span><span class="p">(</span><span class="nb">Number</span><span class="p">(</span><span class="nx">val</span><span class="p">),</span> <span class="nx">renew</span><span class="p">(),</span> <span class="nx">renew</span><span class="p">());</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">renew</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-js highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */</span>

<span class="cm">/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */</span>
<span class="kd">var</span> <span class="nx">serialize</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">rserialize</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="dl">''</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */</span>
<span class="kd">var</span> <span class="nx">deserialize</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dataArray</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">,</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">rdeserialize</span><span class="p">(</span><span class="nx">dataArray</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">rserialize</span> <span class="o">=</span> <span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">str</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">root</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">str</span> <span class="o">+=</span> <span class="dl">'</span><span class="s1">#,</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">str</span> <span class="o">+=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">val</span> <span class="o">+</span> <span class="dl">''</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">,</span><span class="dl">'</span><span class="p">;</span>
        <span class="nx">str</span> <span class="o">=</span> <span class="nx">rserialize</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">str</span><span class="p">);</span>
        <span class="nx">str</span> <span class="o">=</span> <span class="nx">rserialize</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">str</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">str</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">rdeserialize</span> <span class="o">=</span> <span class="nx">dataList</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">dataList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">dataList</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
        <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TreeNode</span><span class="p">(</span><span class="nb">parseInt</span><span class="p">(</span><span class="nx">dataList</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
    <span class="nx">dataList</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
    <span class="nx">root</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">rdeserialize</span><span class="p">(</span><span class="nx">dataList</span><span class="p">);</span>
    <span class="nx">root</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">rdeserialize</span><span class="p">(</span><span class="nx">dataList</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">root</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-rs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1">// Definition for a binary tree node.</span>
<span class="c1">// #[derive(Debug, PartialEq, Eq)]</span>
<span class="c1">// pub struct TreeNode {</span>
<span class="c1">//   pub val: i32,</span>
<span class="c1">//   pub left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span>
<span class="c1">//   pub right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span>
<span class="c1">// }</span>
<span class="c1">//</span>
<span class="c1">// impl TreeNode {</span>
<span class="c1">//   #[inline]</span>
<span class="c1">//   pub fn new(val: i32) -&gt; Self {</span>
<span class="c1">//     TreeNode {</span>
<span class="c1">//       val,</span>
<span class="c1">//       left: None,</span>
<span class="c1">//       right: None</span>
<span class="c1">//     }</span>
<span class="c1">//   }</span>
<span class="c1">// }</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Codec</span> <span class="p">{}</span>

<span class="cd">/**
 * `&amp;self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&amp;mut self` instead.
 */</span>
<span class="k">impl</span> <span class="n">Codec</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">Codec</span> <span class="p">{}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">serialize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"#"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.borrow_mut</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="n">node</span><span class="py">.left</span><span class="nf">.take</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="py">.right</span><span class="nf">.take</span><span class="p">();</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{},{},{}"</span><span class="p">,</span> <span class="k">self</span><span class="nf">.serialize</span><span class="p">(</span><span class="n">right</span><span class="p">),</span> <span class="k">self</span><span class="nf">.serialize</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">node</span><span class="py">.val</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">deserialize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">Self</span><span class="p">::</span><span class="nf">renew</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">data</span><span class="nf">.split</span><span class="p">(</span><span class="s">","</span><span class="p">)</span><span class="nf">.collect</span><span class="p">())</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">renew</span><span class="p">(</span><span class="n">vals</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="n">vals</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="s">"#"</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="s">"#"</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nf">Some</span><span class="p">(</span>
            <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
                <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">TreeNode</span> <span class="p">{</span>
                    <span class="n">val</span><span class="p">:</span> <span class="n">val</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
                    <span class="n">left</span><span class="p">:</span> <span class="k">Self</span><span class="p">::</span><span class="nf">renew</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span>
                    <span class="n">right</span><span class="p">:</span> <span class="k">Self</span><span class="p">::</span><span class="nf">renew</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span>
                <span class="p">})</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span><span class="cd">/**
 * Your Codec object will be instantiated and called as such:
 * let obj = Codec::new();
 * let data: String = obj.serialize(strs);
 * let ans: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; = obj.deserialize(data);
 */</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */</span>

<span class="k">type</span> <span class="n">Codec</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Constructor</span><span class="p">()</span> <span class="n">Codec</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">Codec</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c">// Serializes a tree to a single string.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Codec</span><span class="p">)</span> <span class="n">serialize</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">""</span>
	<span class="p">}</span>
	<span class="n">q</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">{</span><span class="n">root</span><span class="p">}</span>
	<span class="n">ans</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">node</span> <span class="o">:=</span> <span class="n">q</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">node</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">ans</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">strconv</span><span class="o">.</span><span class="n">Itoa</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">Val</span><span class="p">))</span>
			<span class="n">q</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span>
			<span class="n">q</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ans</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="s">"#"</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">strings</span><span class="o">.</span><span class="n">Join</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="s">","</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// Deserializes your encoded data to tree.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Codec</span><span class="p">)</span> <span class="n">deserialize</span><span class="p">(</span><span class="n">data</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="n">TreeNode</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="s">""</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">nil</span>
	<span class="p">}</span>
	<span class="n">vals</span> <span class="o">:=</span> <span class="n">strings</span><span class="o">.</span><span class="n">Split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">","</span><span class="p">)</span>
	<span class="n">v</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">strconv</span><span class="o">.</span><span class="n">Atoi</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="m">0</span><span class="p">])</span>
	<span class="n">i</span> <span class="o">:=</span> <span class="m">1</span>
	<span class="n">root</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">TreeNode</span><span class="p">{</span><span class="n">Val</span><span class="o">:</span> <span class="n">v</span><span class="p">}</span>
	<span class="n">q</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">{</span><span class="n">root</span><span class="p">}</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">node</span> <span class="o">:=</span> <span class="n">q</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">x</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">strconv</span><span class="o">.</span><span class="n">Atoi</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">node</span><span class="o">.</span><span class="n">Left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">TreeNode</span><span class="p">{</span><span class="n">Val</span><span class="o">:</span> <span class="n">x</span><span class="p">}</span>
			<span class="n">q</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">++</span>
		<span class="k">if</span> <span class="n">x</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">strconv</span><span class="o">.</span><span class="n">Atoi</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">node</span><span class="o">.</span><span class="n">Right</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">TreeNode</span><span class="p">{</span><span class="n">Val</span><span class="o">:</span> <span class="n">x</span><span class="p">}</span>
			<span class="n">q</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">root</span>
<span class="p">}</span>

<span class="c">/**
 * Your Codec object will be instantiated and called as such:
 * ser := Constructor();
 * deser := Constructor();
 * data := ser.serialize(root);
 * ans := deser.deserialize(data);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Codec</span> <span class="p">{</span>

    <span class="c1">// Encodes a tree to a single string.</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">ans</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
        <span class="n">Queue</span><span class="p">&lt;</span><span class="n">TreeNode</span><span class="p">&gt;</span> <span class="n">q</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="p">&lt;</span><span class="n">TreeNode</span><span class="p">&gt;();</span>
        <span class="n">q</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="n">node</span> <span class="p">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">Dequeue</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ans</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">.</span><span class="nf">ToString</span><span class="p">());</span>
                <span class="n">q</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">);</span>
                <span class="n">q</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">ans</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"#"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="s">","</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Decodes your encoded data to tree.</span>
    <span class="k">public</span> <span class="n">TreeNode</span> <span class="nf">deserialize</span><span class="p">(</span><span class="kt">string</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">string</span><span class="p">[]</span> <span class="n">vals</span> <span class="p">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="sc">','</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="n">TreeNode</span> <span class="n">root</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">TreeNode</span><span class="p">(</span><span class="kt">int</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">++]));</span>
        <span class="n">Queue</span><span class="p">&lt;</span><span class="n">TreeNode</span><span class="p">&gt;</span> <span class="n">q</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="p">&lt;</span><span class="n">TreeNode</span><span class="p">&gt;();</span>
        <span class="n">q</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="n">node</span> <span class="p">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">Dequeue</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">!=</span> <span class="s">"#"</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">TreeNode</span><span class="p">(</span><span class="kt">int</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
                <span class="n">q</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">i</span><span class="p">++;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">!=</span> <span class="s">"#"</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">TreeNode</span><span class="p">(</span><span class="kt">int</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
                <span class="n">q</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">i</span><span class="p">++;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Your Codec object will be instantiated and called as such:</span>
<span class="c1">// Codec codec = new Codec();</span>
<span class="c1">// codec.deserialize(codec.serialize(root));</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-297.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
