<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-114.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-114.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>114 - Flatten Binary Tree to Linked List</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 114. Flatten Binary Tree to Linked List Description Given the root of a binary tree, flatten the tree into a &amp;quot;linked list&amp;quot;: The &amp;quot;linked list&amp;quot; should use the same TreeNode class where the right child pointer points to the next node in the list and...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-114.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-114.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-114.html" rel="stylesheet"/>
   <link href="solution-114.html" rel="stylesheet"/>
   <link href="solution-114.html" rel="stylesheet"/>
   <link href="solution-114.html" rel="stylesheet"/>
   <link href="solution-114.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="114 - Flatten Binary Tree to Linked List" property="og:title"/>
   <meta content="Leetcode 114. Flatten Binary Tree to Linked List Description Given the root of a binary tree, flatten the tree into a &amp;quot;linked list&amp;quot;: The &amp;quot;linked list&amp;quot; should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null. The &amp;quot;linked list&amp;quot; should be in the same order as a pre-order traversal of the binary tree. &amp;nbsp; Example 1: Input: root = [1,2,5,3,4,null,6] Output: [1,null,2,null,3,null,4,null,5,null,6] Example 2: Input: root = [] Output: [] Example 3: Input: root = [0] Output: [0] &amp;nbsp; Constraints: The number of nodes in the tree is in the range [0, 2000]. -100 &amp;lt;= Node.val &amp;lt;= 100 &amp;nbsp; Follow up: Can you flatten the tree in-place (with O(1) extra space)? Solutions Solution 1: Find Predecessor Node The visit order of preorder traversal is âroot, left subtree, right subtreeâ. After the last node of the left subtree is visited, the right subtree node of the root node will be visited next. Therefore, for the current node, if its left child node is not null, we find the rightmost node of the left subtree as the predecessor node, and then assign the right child node of the current node to the right child node of the predecessor node. Then assign the left child node of the current node to the right child node of the current node, and set the left child node of the current node to null. Then take the right child node of the current node as the next node and continue processing until all nodes are processed. The time complexity is $O(n)$, where $n$ is the number of nodes in the tree. The space complexity is $O(1)$. Flatten process: 1 / \ 2 5 / \ \ 3 4 6 1 / \ 2 5 \ \ 3 6 \ 4 1 \ 2 \ 3 \ 4 \ 5 \ 6 Java C++ Python Go TypeScript Javascript RenderScript /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public void flatten(TreeNode root) { while (root != null) { if (root.left != null) { TreeNode pre = root.left; while (pre.right != null) { pre = pre.right; } pre.right = root.right; root.right = root.left; root.left = null; } root = root.right; } } } /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void flatten(TreeNode* root) { while (root) {..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-03-23T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-03-23-114-Flatten-Binary-Tree-to-Linked-List/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-114.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="114 - Flatten Binary Tree to Linked List" property="twitter:title"/>
   <meta content="Leetcode 114. Flatten Binary Tree to Linked List Description Given the root of a binary tree, flatten the tree into a &amp;quot;linked list&amp;quot;: The &amp;quot;linked list&amp;quot; should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null. The &amp;quot;linked list&amp;quot; should be in the same order as a pre-order traversal of the binary tree. &amp;nbsp; Example 1: Input: root = [1,2,5,3,4,null,6] Output: [1,null,2,null,3,null,4,null,5,null,6] Example 2: Input: root = [] Output: [] Example 3: Input: root = [0] Output: [0] &amp;nbsp; Constraints: The number of nodes in the tree is in the range [0, 2000]. -100 &amp;lt;= Node.val &amp;lt;= 100 &amp;nbsp; Follow up: Can you flatten the tree in-place (with O(1) extra space)? Solutions Solution 1: Find Predecessor Node The visit order of preorder traversal is âroot, left subtree, right subtreeâ. After the last node of the left subtree is visited, the right subtree node of the root node will be visited next. Therefore, for the current node, if its left child node is not null, we find the rightmost node of the left subtree as the predecessor node, and then assign the right child node of the current node to the right child node of the predecessor node. Then assign the left child node of the current node to the right child node of the current node, and set the left child node of the current node to null. Then take the right child node of the current node as the next node and continue processing until all nodes are processed. The time complexity is $O(n)$, where $n$ is the number of nodes in the tree. The space complexity is $O(1)$. Flatten process: 1 / \ 2 5 / \ \ 3 4 6 1 / \ 2 5 \ \ 3 6 \ 4 1 \ 2 \ 3 \ 4 \ 5 \ 6 Java C++ Python Go TypeScript Javascript RenderScript /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public void flatten(TreeNode root) { while (root != null) { if (root.left != null) { TreeNode pre = root.left; while (pre.right != null) { pre = pre.right; } pre.right = root.right; root.right = root.left; root.left = null; } root = root.right; } } } /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void flatten(TreeNode* root) { while (root) {..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    114 - Flatten Binary Tree to Linked List | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="114 - Flatten Binary Tree to Linked List" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-114.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-03-23-114-Flatten-Binary-Tree-to-Linked-List/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-03-23T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"114 - Flatten Binary Tree to Linked List","dateModified":"2016-03-23T00:00:00-07:00","datePublished":"2016-03-23T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-03-23-114-Flatten-Binary-Tree-to-Linked-List/"},"url":"https://leetcode.ca/2016-03-23-114-Flatten-Binary-Tree-to-Linked-List/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="114-flatten-binary-tree-to-linked-list">
       <a href="solution-114.html">
        114. Flatten Binary Tree to Linked List
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given the
       <code>
        root
       </code>
       of a binary tree, flatten the tree into a "linked list":
      </p>
      <ul>
       <li>
        The "linked list" should use the same
        <code>
         TreeNode
        </code>
        class where the
        <code>
         right
        </code>
        child pointer points to the next node in the list and the
        <code>
         left
        </code>
        child pointer is always
        <code>
         null
        </code>
        .
       </li>
       <li>
        The "linked list" should be in the same order as a
        <a href="solution-114.html" target="_blank">
         <strong>
          pre-order
         </strong>
         <strong>
          traversal
         </strong>
        </a>
        of the binary tree.
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0114.Flatten%20Binary%20Tree%20to%20Linked%20List/images/flaten.jpg" style="width: 500px; height: 226px;"/>
      </p>
      <pre>
<strong>Input:</strong> root = [1,2,5,3,4,null,6]
<strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6]
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> root = [0]
<strong>Output:</strong> [0]
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the tree is in the range
        <code>
         [0, 2000]
        </code>
        .
       </li>
       <li>
        <code>
         -100 &lt;= Node.val &lt;= 100
        </code>
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong>
        Follow up:
       </strong>
       Can you flatten the tree in-place (with
       <code>
        O(1)
       </code>
       extra space)?
      </p>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       <strong>
        Solution 1: Find Predecessor Node
       </strong>
      </p>
      <p>
       The visit order of preorder traversal is âroot, left subtree, right subtreeâ. After the last node of the left subtree is visited, the right subtree node of the root node will be visited next.
      </p>
      <p>
       Therefore, for the current node, if its left child node is not null, we find the rightmost node of the left subtree as the predecessor node, and then assign the right child node of the current node to the right child node of the predecessor node. Then assign the left child node of the current node to the right child node of the current node, and set the left child node of the current node to null. Then take the right child node of the current node as the next node and continue processing until all nodes are processed.
      </p>
      <p>
       The time complexity is $O(n)$, where $n$ is the number of nodes in the tree. The space complexity is $O(1)$.
      </p>
      <p>
       Flatten process:
      </p>
      <div class="language-plaintext highlighter-rouge">
       <div class="highlight">
        <pre class="highlight"><code>     1
    / \
   2   5
  / \   \
 3   4   6

     1
    / \
   2   5
    \   \
     3   6
      \    
       4

   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6
</code></pre>
       </div>
      </div>
      <ul class="uk-tab" data-uk-switcher="{connect:'#4f6ff5fd-05c3-492f-96d3-eb2f860688aa'}">
       <li class="uk-active">
        <a href="solution-114.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-114.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-114.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-114.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-114.html">
         TypeScript
        </a>
       </li>
       <li>
        <a href="solution-114.html">
         Javascript
        </a>
       </li>
       <li>
        <a href="solution-114.html">
         RenderScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="4f6ff5fd-05c3-492f-96d3-eb2f860688aa">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatten</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">TreeNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">pre</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">pre</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">flatten</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">TreeNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">pre</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
                <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
                <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span> <span class="c1"># stack, pre-order interation
</span>    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="s">"""
        Do not return anything, modify root in-place instead.
        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># dummy node
</span>        
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="n">current</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">current</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                
            <span class="n">prev</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">prev</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">current</span>
            
            <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span>

<span class="c1">###########
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span> <span class="c1"># no stack
</span>    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="s">"""
        Do not return anything, modify root in-place instead.
        """</span>
        <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span>
                <span class="k">while</span> <span class="n">pre</span><span class="p">.</span><span class="n">right</span><span class="p">:</span> <span class="c1"># start feom right
</span>                    <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="p">.</span><span class="n">right</span>
                <span class="n">pre</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span>
                <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span>
                <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */</span>
<span class="k">func</span> <span class="n">flatten</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">root</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">:=</span> <span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">Right</span>
		<span class="n">root</span><span class="o">.</span><span class="n">Left</span> <span class="o">=</span> <span class="no">nil</span>
		<span class="k">if</span> <span class="n">left</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">root</span><span class="o">.</span><span class="n">Right</span> <span class="o">=</span> <span class="n">left</span>
			<span class="k">for</span> <span class="n">left</span><span class="o">.</span><span class="n">Right</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">Right</span>
			<span class="p">}</span>
			<span class="n">left</span><span class="o">.</span><span class="n">Right</span> <span class="o">=</span> <span class="n">right</span>
		<span class="p">}</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">Right</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>

<span class="cm">/**
 Do not return anything, modify root in-place instead.
 */</span>
<span class="kd">function</span> <span class="nx">flatten</span><span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">root</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">pre</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="nx">pre</span><span class="p">.</span><span class="nx">right</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">pre</span> <span class="o">=</span> <span class="nx">pre</span><span class="p">.</span><span class="nx">right</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nx">pre</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">;</span>
            <span class="nx">root</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">;</span>
            <span class="nx">root</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">root</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-js highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="cm">/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */</span>
<span class="kd">var</span> <span class="nx">flatten</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">pre</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="nx">pre</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">pre</span> <span class="o">=</span> <span class="nx">pre</span><span class="p">.</span><span class="nx">right</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nx">pre</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">;</span>
            <span class="nx">root</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">;</span>
            <span class="nx">root</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">root</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-rs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1">// Definition for a binary tree node.</span>
<span class="c1">// #[derive(Debug, PartialEq, Eq)]</span>
<span class="c1">// pub struct TreeNode {</span>
<span class="c1">//   pub val: i32,</span>
<span class="c1">//   pub left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span>
<span class="c1">//   pub right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span>
<span class="c1">// }</span>
<span class="c1">//</span>
<span class="c1">// impl TreeNode {</span>
<span class="c1">//   #[inline]</span>
<span class="c1">//   pub fn new(val: i32) -&gt; Self {</span>
<span class="c1">//     TreeNode {</span>
<span class="c1">//       val,</span>
<span class="c1">//       left: None,</span>
<span class="c1">//       right: None</span>
<span class="c1">//     }</span>
<span class="c1">//   }</span>
<span class="c1">// }</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Solution</span> <span class="p">{</span>
    <span class="nd">#[allow(dead_code)]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">v</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;&gt;&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="c1">// Initialize the vector</span>
        <span class="k">Self</span><span class="p">::</span><span class="nf">pre_order_traverse</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">v</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
        <span class="c1">// Traverse the vector</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.left</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
            <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.right</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[allow(dead_code)]</span>
    <span class="k">fn</span> <span class="nf">pre_order_traverse</span><span class="p">(</span>
        <span class="n">v</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">,</span>
        <span class="n">root</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;&gt;</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">v</span><span class="nf">.push</span><span class="p">(</span><span class="n">root</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">()</span><span class="py">.left</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">()</span><span class="py">.right</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">Self</span><span class="p">::</span><span class="nf">pre_order_traverse</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">left</span><span class="p">);</span>
        <span class="k">Self</span><span class="p">::</span><span class="nf">pre_order_traverse</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-114.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
