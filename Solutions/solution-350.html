<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-350.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-350.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>350 - Intersection of Two Arrays II</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 350. Intersection of Two Arrays II Description Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order....">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-350.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-350.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-350.html" rel="stylesheet"/>
   <link href="solution-350.html" rel="stylesheet"/>
   <link href="solution-350.html" rel="stylesheet"/>
   <link href="solution-350.html" rel="stylesheet"/>
   <link href="solution-350.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="350 - Intersection of Two Arrays II" property="og:title"/>
   <meta content="Leetcode 350. Intersection of Two Arrays II Description Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order. &amp;nbsp; Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Explanation: [9,4] is also accepted. &amp;nbsp; Constraints: 1 &amp;lt;= nums1.length, nums2.length &amp;lt;= 1000 0 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 1000 &amp;nbsp; Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1&amp;#39;s size is small compared to nums2&amp;#39;s size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? Solutions HashSet The previous expansion of 349 Intersection of Two Arrays, the difference is that this question allows to return repeated numbers, and returns as many as possible. HashMap to establish the mapping between the characters in nums1 and the number of occurrences, and then traverse the nums2 array. If the number of the current character in the HashMap is greater than 0, add this character to the result, and then the corresponding value of the HashMap will be decremented by 1. Two pointers Sort the two arrays first, and then use two pointers to point to the starting positions of the two arrays, If the numbers pointed to by the two pointers are equal, it is stored in the result, and both pointers are incremented by 1, If the number pointed to by the first pointer is large, the second pointer is incremented by 1, and vice versa Follow up 1. If the given array is already sorted: If both nums1 and nums2 are sorted, you can use a two-pointer technique to improve the time complexity to O(n + m), where n and m are the lengths of the two arrays. This approach eliminates the need for additional space required for hash maps in the unsorted case. 2. If nums1âs size is small compared to nums2âs size: If one array is significantly smaller than the other, itâs more efficient to use a hash map for the smaller array. This reduces the space complexity and potentially the time complexity since you iterate over and hash only the smaller array and then iterate over the larger array to check for intersections. 3. If elements of nums2 are stored on disk, and the memory is limited: In this scenario, external sorting and the two-pointer technique can be used. Process nums1 into a hash map or sort it if not already sorted. For nums2, use external sorting algorithms that break the data into chunks that fit into memory, sort each chunk, and then merge them. This way, you can sort nums2 without loading it entirely into memory. After sorting, you can stream nums2 from..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-11-14T00:00:00-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-11-14-350-Intersection-of-Two-Arrays-II/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-350.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="350 - Intersection of Two Arrays II" property="twitter:title"/>
   <meta content="Leetcode 350. Intersection of Two Arrays II Description Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order. &amp;nbsp; Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Explanation: [9,4] is also accepted. &amp;nbsp; Constraints: 1 &amp;lt;= nums1.length, nums2.length &amp;lt;= 1000 0 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 1000 &amp;nbsp; Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1&amp;#39;s size is small compared to nums2&amp;#39;s size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? Solutions HashSet The previous expansion of 349 Intersection of Two Arrays, the difference is that this question allows to return repeated numbers, and returns as many as possible. HashMap to establish the mapping between the characters in nums1 and the number of occurrences, and then traverse the nums2 array. If the number of the current character in the HashMap is greater than 0, add this character to the result, and then the corresponding value of the HashMap will be decremented by 1. Two pointers Sort the two arrays first, and then use two pointers to point to the starting positions of the two arrays, If the numbers pointed to by the two pointers are equal, it is stored in the result, and both pointers are incremented by 1, If the number pointed to by the first pointer is large, the second pointer is incremented by 1, and vice versa Follow up 1. If the given array is already sorted: If both nums1 and nums2 are sorted, you can use a two-pointer technique to improve the time complexity to O(n + m), where n and m are the lengths of the two arrays. This approach eliminates the need for additional space required for hash maps in the unsorted case. 2. If nums1âs size is small compared to nums2âs size: If one array is significantly smaller than the other, itâs more efficient to use a hash map for the smaller array. This reduces the space complexity and potentially the time complexity since you iterate over and hash only the smaller array and then iterate over the larger array to check for intersections. 3. If elements of nums2 are stored on disk, and the memory is limited: In this scenario, external sorting and the two-pointer technique can be used. Process nums1 into a hash map or sort it if not already sorted. For nums2, use external sorting algorithms that break the data into chunks that fit into memory, sort each chunk, and then merge them. This way, you can sort nums2 without loading it entirely into memory. After sorting, you can stream nums2 from..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    350 - Intersection of Two Arrays II | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="350 - Intersection of Two Arrays II" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-350.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-11-14-350-Intersection-of-Two-Arrays-II/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-11-14T00:00:00-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"350 - Intersection of Two Arrays II","dateModified":"2016-11-14T00:00:00-08:00","datePublished":"2016-11-14T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-11-14-350-Intersection-of-Two-Arrays-II/"},"url":"https://leetcode.ca/2016-11-14-350-Intersection-of-Two-Arrays-II/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="350-intersection-of-two-arrays-ii">
       <a href="solution-350.html">
        350. Intersection of Two Arrays II
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given two integer arrays
       <code>
        nums1
       </code>
       and
       <code>
        nums2
       </code>
       , return
       <em>
        an array of their intersection
       </em>
       . Each element in the result must appear as many times as it shows in both arrays and you may return the result in
       <strong>
        any order
       </strong>
       .
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> nums1 = [1,2,2,1], nums2 = [2,2]
<strong>Output:</strong> [2,2]
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> nums1 = [4,9,5], nums2 = [9,4,9,8,4]
<strong>Output:</strong> [4,9]
<strong>Explanation:</strong> [9,4] is also accepted.
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= nums1.length, nums2.length &lt;= 1000
        </code>
       </li>
       <li>
        <code>
         0 &lt;= nums1[i], nums2[i] &lt;= 1000
        </code>
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong>
        Follow up:
       </strong>
      </p>
      <ul>
       <li>
        What if the given array is already sorted? How would you optimize your algorithm?
       </li>
       <li>
        What if
        <code>
         nums1
        </code>
        's size is small compared to
        <code>
         nums2
        </code>
        's size? Which algorithm is better?
       </li>
       <li>
        What if elements of
        <code>
         nums2
        </code>
        are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <h3 id="hashset">
       HashSet
      </h3>
      <p>
       The previous expansion of
       <a href="solution-350.html">
        349 Intersection of Two Arrays
       </a>
       , the difference is that this question
       <code class="language-plaintext highlighter-rouge">
        allows to return repeated numbers
       </code>
       , and returns as many as possible.
      </p>
      <p>
       HashMap to establish the mapping between the characters in nums1 and the number of occurrences, and then traverse the nums2 array.
      </p>
      <p>
       If the number of the current character in the HashMap is greater than 0, add this character to the result, and then the corresponding value of the HashMap will be decremented by 1.
      </p>
      <h3 id="two-pointers">
       Two pointers
      </h3>
      <p>
       Sort the two arrays first, and then use two pointers to point to the starting positions of the two arrays,
      </p>
      <ul>
       <li>
        If the numbers pointed to by the two pointers are equal, it is stored in the result, and both pointers are incremented by 1,
       </li>
       <li>
        If the number pointed to by the first pointer is large, the second pointer is incremented by 1, and vice versa
       </li>
      </ul>
      <h1 id="follow-up">
       Follow up
      </h1>
      <h3 id="1-if-the-given-array-is-already-sorted">
       1. If the given array is already sorted:
      </h3>
      <p>
       If both
       <code class="language-plaintext highlighter-rouge">
        nums1
       </code>
       and
       <code class="language-plaintext highlighter-rouge">
        nums2
       </code>
       are sorted, you can use a
       <code class="language-plaintext highlighter-rouge">
        two-pointer technique
       </code>
       to improve the time complexity to
       <code class="language-plaintext highlighter-rouge">
        O(n + m)
       </code>
       , where n and m are the lengths of the two arrays. This approach eliminates the need for additional space required for hash maps in the unsorted case.
      </p>
      <h3 id="2-if-nums1s-size-is-small-compared-to-nums2s-size">
       2. If
       <code class="language-plaintext highlighter-rouge">
        nums1
       </code>
       âs size is small compared to
       <code class="language-plaintext highlighter-rouge">
        nums2
       </code>
       âs size:
      </h3>
      <p>
       If one array is significantly smaller than the other, itâs
       <code class="language-plaintext highlighter-rouge">
        more efficient to use a hash map
       </code>
       for the smaller array. This reduces the space complexity and potentially the time complexity since you iterate over and hash only the smaller array and then iterate over the larger array to check for intersections.
      </p>
      <h3 id="3-if-elements-of-nums2-are-stored-on-disk-and-the-memory-is-limited">
       3. If elements of
       <code class="language-plaintext highlighter-rouge">
        nums2
       </code>
       are stored on disk, and the memory is limited:
      </h3>
      <p>
       In this scenario,
       <code class="language-plaintext highlighter-rouge">
        external sorting
       </code>
       and the
       <code class="language-plaintext highlighter-rouge">
        two-pointer technique
       </code>
       can be used.
      </p>
      <p>
       Process
       <code class="language-plaintext highlighter-rouge">
        nums1
       </code>
       into a hash map or sort it if not already sorted. For
       <code class="language-plaintext highlighter-rouge">
        nums2
       </code>
       , use external sorting algorithms that break the data into chunks that fit into memory, sort each chunk, and then merge them. This way, you can sort
       <code class="language-plaintext highlighter-rouge">
        nums2
       </code>
       without loading it entirely into memory. After sorting, you can stream
       <code class="language-plaintext highlighter-rouge">
        nums2
       </code>
       from disk and use the two-pointer technique or binary search (if
       <code class="language-plaintext highlighter-rouge">
        nums1
       </code>
       is hashed) to find intersections without exceeding memory limits.
      </p>
      <p>
       For massive datasets that cannot fit into memory (like
       <code class="language-plaintext highlighter-rouge">
        nums2
       </code>
       in this case), consider using
       <code class="language-plaintext highlighter-rouge">
        database solutions
       </code>
       designed for handling large-scale data or big data technologies like
       <strong>
        Hadoop or Spark
       </strong>
       , which provide mechanisms for distributed data processing.
      </p>
      <h1 id="31-more-on-external-sorting---memory-is-limited">
       3.1 More on external sorting - memory is limited
      </h1>
      <p>
       External sorting is a class of algorithms used to handle massive amounts of data that do not fit into a computerâs main memory (RAM) but instead are stored on a slower, external memory such as a hard disk drive (HDD) or solid-state drive (SSD). This is particularly useful for sorting large files that exceed the capacity of the systemâs RAM. The most common external sorting algorithm is the external merge sort, which involves the following steps:
      </p>
      <h3 id="1-divide">
       1.
       <strong>
        Divide
       </strong>
       :
      </h3>
      <ul>
       <li>
        The large dataset is divided into smaller chunks, each of which can fit into the available RAM.
       </li>
       <li>
        These chunks are read into memory one at a time.
       </li>
      </ul>
      <h3 id="2-sort">
       2.
       <strong>
        Sort
       </strong>
       :
      </h3>
      <ul>
       <li>
        Each chunk is sorted in memory using an efficient internal sorting algorithm, like quicksort or mergesort.
       </li>
       <li>
        After sorting, the sorted chunks are written back to the external storage.
       </li>
      </ul>
      <h3 id="3-merge">
       3.
       <strong>
        Merge
       </strong>
       :
      </h3>
      <ul>
       <li>
        The sorted chunks are then merged into a single, fully sorted file.
       </li>
       <li>
        This merge process is done in a way that always maintains a manageable number of chunks in memory, regardless of the total size of the dataset.
       </li>
      </ul>
      <h3 id="example-of-external-merge-sort">
       Example of External Merge Sort:
      </h3>
      <p>
       Assume you have 1GB of data to sort, but only 256MB of RAM available.
      </p>
      <p>
       <strong>
        Divide
       </strong>
       :
      </p>
      <ul>
       <li>
        Break the 1GB file into 4 chunks of 256MB each.
       </li>
       <li>
        Read the first 256MB chunk into RAM.
       </li>
      </ul>
      <p>
       <strong>
        Sort
       </strong>
       :
      </p>
      <ul>
       <li>
        Sort this chunk using an in-memory sorting algorithm (like mergesort).
       </li>
       <li>
        Write the sorted chunk back to disk.
       </li>
       <li>
        Repeat this process for the remaining chunks.
       </li>
      </ul>
      <p>
       <strong>
        Merge
       </strong>
       :
      </p>
      <ul>
       <li>
        Read the first part of each sorted chunk into RAM and merge them, creating a new sorted sequence of data. Given the RAM limitation, you might only be able to read a small portion of each chunk at a time.
       </li>
       <li>
        Write the merged sequence back to disk.
       </li>
       <li>
        If there was more than one value from each chunk in RAM, repeat the merge process, reading the next values from the chunks as needed until all chunks are fully merged into a single sorted sequence.
       </li>
      </ul>
      <p>
       <strong>
        Efficiency Tips
       </strong>
       :
      </p>
      <ul>
       <li>
        To reduce disk I/O, which is typically the bottleneck in external sorting, itâs essential to optimize how data is read from and written to disk. For example, using larger buffers can reduce the number of disk accesses.
       </li>
       <li>
        Multiway merges, where more than two chunks are merged at once, can significantly reduce the total number of merging passes needed.
       </li>
      </ul>
      <p>
       <strong>
        Applications
       </strong>
       :
      </p>
      <ul>
       <li>
        External sorting is crucial in databases for sorting large tables and in big data applications where datasets far exceed the available memory.
       </li>
       <li>
        Tools and frameworks that handle big data, like Hadoop and Spark, implement their versions of external sorting to distribute the sorting process across multiple machines, further scaling the ability to sort massive datasets efficiently.
       </li>
      </ul>
      <ul class="uk-tab" data-uk-switcher="{connect:'#5415ca9a-b66f-4827-88dc-aab7c0b0f48c'}">
       <li class="uk-active">
        <a href="solution-350.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-350.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-350.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-350.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-350.html">
         TypeScript
        </a>
       </li>
       <li>
        <a href="solution-350.html">
         Javascript
        </a>
       </li>
       <li>
        <a href="solution-350.html">
         Php
        </a>
       </li>
       <li>
        <a href="solution-350.html">
         C#
        </a>
       </li>
       <li>
        <a href="solution-350.html">
         RenderScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="5415ca9a-b66f-4827-88dc-aab7c0b0f48c">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">intersect</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">counter</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">counter</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">counter</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">t</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
                <span class="n">counter</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">counter</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">t</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">res</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intersect</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">counter</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums1</span><span class="p">)</span> <span class="o">++</span><span class="n">counter</span><span class="p">[</span><span class="n">num</span><span class="p">];</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">counter</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">--</span><span class="n">counter</span><span class="p">[</span><span class="n">num</span><span class="p">];</span>
                <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">counter</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                <span class="n">counter</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">res</span>

<span class="c1">############
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span><span class="p">):</span>
    <span class="s">"""
    :type nums1: List[int]
    :type nums2: List[int]
    :rtype: List[int]
    """</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nums1</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">nums2</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">elif</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">ans</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">intersect</span><span class="p">(</span><span class="n">nums1</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">nums2</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="n">counter</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">num</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">nums1</span> <span class="p">{</span>
		<span class="n">counter</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">var</span> <span class="n">res</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">num</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">nums2</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">counter</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">counter</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">--</span>
			<span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">function</span> <span class="nx">intersect</span><span class="p">(</span><span class="nx">nums1</span><span class="p">:</span> <span class="kr">number</span><span class="p">[],</span> <span class="nx">nums2</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]):</span> <span class="kr">number</span><span class="p">[]</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="kr">number</span><span class="p">,</span> <span class="kr">number</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">num</span> <span class="k">of</span> <span class="nx">nums1</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">num</span><span class="p">,</span> <span class="p">(</span><span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="o">??</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">num</span> <span class="k">of</span> <span class="nx">nums2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">map</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span>
            <span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">num</span><span class="p">,</span> <span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-js highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */</span>
<span class="kd">var</span> <span class="nx">intersect</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">nums1</span><span class="p">,</span> <span class="nx">nums2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">counter</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">num</span> <span class="k">of</span> <span class="nx">nums1</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">counter</span><span class="p">[</span><span class="nx">num</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">counter</span><span class="p">[</span><span class="nx">num</span><span class="p">]</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">num</span> <span class="k">of</span> <span class="nx">nums2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">counter</span><span class="p">[</span><span class="nx">num</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span>
            <span class="nx">counter</span><span class="p">[</span><span class="nx">num</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">};</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-php highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="cd">/**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @return Integer[]
     */</span>
    <span class="k">function</span> <span class="n">intersect</span><span class="p">(</span><span class="nv">$nums1</span><span class="p">,</span> <span class="nv">$nums2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$rs</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="k">for</span> <span class="p">(</span><span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nv">$i</span> <span class="o">&lt;</span> <span class="nb">count</span><span class="p">(</span><span class="nv">$nums1</span><span class="p">);</span> <span class="nv">$i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nv">$hashtable</span><span class="p">[</span><span class="nv">$nums1</span><span class="p">[</span><span class="nv">$i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="nv">$j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nv">$j</span> <span class="o">&lt;</span> <span class="nb">count</span><span class="p">(</span><span class="nv">$nums2</span><span class="p">);</span> <span class="nv">$j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">isset</span><span class="p">(</span><span class="nv">$hashtable</span><span class="p">[</span><span class="nv">$nums2</span><span class="p">[</span><span class="nv">$j</span><span class="p">]])</span> <span class="o">&amp;&amp;</span> <span class="nv">$hashtable</span><span class="p">[</span><span class="nv">$nums2</span><span class="p">[</span><span class="nv">$j</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="nb">array_push</span><span class="p">(</span><span class="nv">$rs</span><span class="p">,</span> <span class="nv">$nums2</span><span class="p">[</span><span class="nv">$j</span><span class="p">]);</span>
                <span class="nv">$hashtable</span><span class="p">[</span><span class="nv">$nums2</span><span class="p">[</span><span class="nv">$j</span><span class="p">]]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nv">$rs</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span><span class="p">[]</span> <span class="nf">Intersect</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">nums1</span><span class="p">,</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">nums2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">HashSet</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">hs1</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="n">nums1</span><span class="p">.</span><span class="nf">Concat</span><span class="p">(</span><span class="n">nums2</span><span class="p">).</span><span class="nf">ToArray</span><span class="p">());</span>
        <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">dict</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;();</span>
        <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">result</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>

        <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="k">in</span> <span class="n">hs1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dict</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="k">in</span> <span class="n">nums1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="nf">ContainsKey</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">dict</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">+=</span> <span class="m">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">dict</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="k">in</span> <span class="n">nums2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="n">dict</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">-=</span><span class="m">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">.</span><span class="nf">ToArray</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-rs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Solution</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">nums1</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">nums2</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">map</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">num</span> <span class="k">in</span> <span class="n">nums1</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">map</span><span class="nf">.entry</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="nf">.or_insert</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
        <span class="k">for</span> <span class="n">num</span> <span class="k">in</span> <span class="n">nums2</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">map</span><span class="nf">.contains_key</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="nf">.get</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="mi">0</span> <span class="p">{</span>
                <span class="n">map</span><span class="nf">.insert</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">map</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
                <span class="n">res</span><span class="nf">.push</span><span class="p">(</span><span class="o">*</span><span class="n">num</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">res</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-350.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
