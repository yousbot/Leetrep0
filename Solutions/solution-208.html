<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-208.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-208.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>208 - Implement Trie (Prefix Tree)</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode Question Formatted question description: https://leetcode.ca/all/208.html A trie (pronounced as &amp;quot;try&amp;quot;) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-208.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-208.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-208.html" rel="stylesheet"/>
   <link href="solution-208.html" rel="stylesheet"/>
   <link href="solution-208.html" rel="stylesheet"/>
   <link href="solution-208.html" rel="stylesheet"/>
   <link href="solution-208.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="208 - Implement Trie (Prefix Tree)" property="og:title"/>
   <meta content="Leetcode Question Formatted question description: https://leetcode.ca/all/208.html A trie (pronounced as &amp;quot;try&amp;quot;) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class: Trie() Initializes the trie object. void insert(String word) Inserts the string word into the trie. boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise. boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise. &amp;nbsp; Example 1: Input [&amp;quot;Trie&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;startsWith&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;search&amp;quot;] [[], [&amp;quot;apple&amp;quot;], [&amp;quot;apple&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;app&amp;quot;]] Output [null, null, true, false, true, null, true] Explanation Trie trie = new Trie(); trie.insert(&amp;quot;apple&amp;quot;); trie.search(&amp;quot;apple&amp;quot;); // return True trie.search(&amp;quot;app&amp;quot;); // return False trie.startsWith(&amp;quot;app&amp;quot;); // return True trie.insert(&amp;quot;app&amp;quot;); trie.search(&amp;quot;app&amp;quot;); // return True &amp;nbsp; Constraints: 1 &amp;lt;= word.length, prefix.length &amp;lt;= 2000 word and prefix consist only of lowercase English letters. At most 3 * 104 calls in total will be made to insert, search, and startsWith. Algorithm Using a basic Trie (pronounced as âtryâ), which is a type of search tree used to efficiently store a dynamic set or associative array where the keys are usually strings. Tries are well-suited for solving problems related to word searches, auto-completions, and prefix matching. TrieNode Class: Purpose: Represents a single node in the Trie. child Attribute: Uses a defaultdict from the collections module to automatically create a new TrieNode when accessing a missing key. This eliminates the need for explicit checks if a child node exists, streamlining node creation during word insertion. is_word Attribute: A boolean flag indicating whether the node marks the end of a word in the Trie. It is initialized as False and set to True when a word is fully inserted. Trie Class: Initialization: The Trie constructor initializes the Trie with a root TrieNode. insert Method: Inserts a word into the Trie. Iterates through each letter in the word. For each letter, it moves down to the corresponding child node, creating new nodes as necessary due to the use of defaultdict. After all letters are inserted, sets the is_word flag of the last node to True to mark the end of a word. search Method: Searches for a word in the Trie. Iterates through each letter in the word, navigating through the child nodes. If a letter does not exist as a key in the current nodeâs children (i.e., cur.child.get(letter) returns None), returns False immediately. If all letters are found in sequence, checks the is_word flag of the last node. Returns True if itâs set (meaning the word exists in the Trie), otherwise False. startsWith Method: Checks if there is any word in the Trie that starts with the given prefix. Similar to search, but returns True as soon as all letters of the prefix are found in sequence, without checking the is_word flag...." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-06-25T22:21:01-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-06-25-208-Implement-Trie-(Prefix-Tree)/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-208.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="208 - Implement Trie (Prefix Tree)" property="twitter:title"/>
   <meta content="Leetcode Question Formatted question description: https://leetcode.ca/all/208.html A trie (pronounced as &amp;quot;try&amp;quot;) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class: Trie() Initializes the trie object. void insert(String word) Inserts the string word into the trie. boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise. boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise. &amp;nbsp; Example 1: Input [&amp;quot;Trie&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;startsWith&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;search&amp;quot;] [[], [&amp;quot;apple&amp;quot;], [&amp;quot;apple&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;app&amp;quot;]] Output [null, null, true, false, true, null, true] Explanation Trie trie = new Trie(); trie.insert(&amp;quot;apple&amp;quot;); trie.search(&amp;quot;apple&amp;quot;); // return True trie.search(&amp;quot;app&amp;quot;); // return False trie.startsWith(&amp;quot;app&amp;quot;); // return True trie.insert(&amp;quot;app&amp;quot;); trie.search(&amp;quot;app&amp;quot;); // return True &amp;nbsp; Constraints: 1 &amp;lt;= word.length, prefix.length &amp;lt;= 2000 word and prefix consist only of lowercase English letters. At most 3 * 104 calls in total will be made to insert, search, and startsWith. Algorithm Using a basic Trie (pronounced as âtryâ), which is a type of search tree used to efficiently store a dynamic set or associative array where the keys are usually strings. Tries are well-suited for solving problems related to word searches, auto-completions, and prefix matching. TrieNode Class: Purpose: Represents a single node in the Trie. child Attribute: Uses a defaultdict from the collections module to automatically create a new TrieNode when accessing a missing key. This eliminates the need for explicit checks if a child node exists, streamlining node creation during word insertion. is_word Attribute: A boolean flag indicating whether the node marks the end of a word in the Trie. It is initialized as False and set to True when a word is fully inserted. Trie Class: Initialization: The Trie constructor initializes the Trie with a root TrieNode. insert Method: Inserts a word into the Trie. Iterates through each letter in the word. For each letter, it moves down to the corresponding child node, creating new nodes as necessary due to the use of defaultdict. After all letters are inserted, sets the is_word flag of the last node to True to mark the end of a word. search Method: Searches for a word in the Trie. Iterates through each letter in the word, navigating through the child nodes. If a letter does not exist as a key in the current nodeâs children (i.e., cur.child.get(letter) returns None), returns False immediately. If all letters are found in sequence, checks the is_word flag of the last node. Returns True if itâs set (meaning the word exists in the Trie), otherwise False. startsWith Method: Checks if there is any word in the Trie that starts with the given prefix. Similar to search, but returns True as soon as all letters of the prefix are found in sequence, without checking the is_word flag...." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    208 - Implement Trie (Prefix Tree) | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="208 - Implement Trie (Prefix Tree)" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-208.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-06-25-208-Implement-Trie-(Prefix-Tree)/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-06-25T22:21:01-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"208 - Implement Trie (Prefix Tree)","dateModified":"2016-06-25T22:21:01-07:00","datePublished":"2016-06-25T22:21:01-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-06-25-208-Implement-Trie-(Prefix-Tree)/"},"url":"https://leetcode.ca/2016-06-25-208-Implement-Trie-(Prefix-Tree)/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="question">
       Question
      </h1>
      <p>
       Formatted question description:
       <a href="solution-208.html">
        https://leetcode.ca/all/208.html
       </a>
      </p>
      <p>
       A
       <a href="solution-208.html" target="_blank">
        <strong>
         trie
        </strong>
       </a>
       (pronounced as "try") or
       <strong>
        prefix tree
       </strong>
       is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.
      </p>
      <p>
       Implement the Trie class:
      </p>
      <ul>
       <li>
        <code>
         Trie()
        </code>
        Initializes the trie object.
       </li>
       <li>
        <code>
         void insert(String word)
        </code>
        Inserts the string
        <code>
         word
        </code>
        into the trie.
       </li>
       <li>
        <code>
         boolean search(String word)
        </code>
        Returns
        <code>
         true
        </code>
        if the string
        <code>
         word
        </code>
        is in the trie (i.e., was inserted before), and
        <code>
         false
        </code>
        otherwise.
       </li>
       <li>
        <code>
         boolean startsWith(String prefix)
        </code>
        Returns
        <code>
         true
        </code>
        if there is a previously inserted string
        <code>
         word
        </code>
        that has the prefix
        <code>
         prefix
        </code>
        , and
        <code>
         false
        </code>
        otherwise.
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input</strong>
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
<strong>Output</strong>
[null, null, true, false, true, null, true]

<strong>Explanation</strong>
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // return True
trie.search("app");     // return False
trie.startsWith("app"); // return True
trie.insert("app");
trie.search("app");     // return True
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= word.length, prefix.length &lt;= 2000
        </code>
       </li>
       <li>
        <code>
         word
        </code>
        and
        <code>
         prefix
        </code>
        consist only of lowercase English letters.
       </li>
       <li>
        At most
        <code>
         3 * 10
         <sup>
          4
         </sup>
        </code>
        calls
        <strong>
         in total
        </strong>
        will be made to
        <code>
         insert
        </code>
        ,
        <code>
         search
        </code>
        , and
        <code>
         startsWith
        </code>
        .
       </li>
      </ul>
      <h1 id="algorithm">
       Algorithm
      </h1>
      <p>
       Using a basic Trie (pronounced as âtryâ), which is a type of search tree used to efficiently store a dynamic set or associative array where the keys are usually strings. Tries are well-suited for solving problems related to word searches, auto-completions, and prefix matching.
      </p>
      <h3 id="trienode-class">
       <code class="language-plaintext highlighter-rouge">
        TrieNode
       </code>
       Class:
      </h3>
      <ul>
       <li>
        <strong>
         Purpose
        </strong>
        : Represents a single node in the Trie.
       </li>
       <li>
        <strong>
         <code class="language-plaintext highlighter-rouge">
          child
         </code>
         Attribute
        </strong>
        : Uses a
        <code class="language-plaintext highlighter-rouge">
         defaultdict
        </code>
        from the
        <code class="language-plaintext highlighter-rouge">
         collections
        </code>
        module to automatically create a new
        <code class="language-plaintext highlighter-rouge">
         TrieNode
        </code>
        when accessing a missing key. This eliminates the need for explicit checks if a child node exists, streamlining node creation during word insertion.
       </li>
       <li>
        <strong>
         <code class="language-plaintext highlighter-rouge">
          is_word
         </code>
         Attribute
        </strong>
        : A boolean flag indicating whether the node marks the end of a word in the Trie. It is initialized as
        <code class="language-plaintext highlighter-rouge">
         False
        </code>
        and set to
        <code class="language-plaintext highlighter-rouge">
         True
        </code>
        when a word is fully inserted.
       </li>
      </ul>
      <h3 id="trie-class">
       <code class="language-plaintext highlighter-rouge">
        Trie
       </code>
       Class:
      </h3>
      <ul>
       <li>
        <p>
         <strong>
          Initialization
         </strong>
         : The
         <code class="language-plaintext highlighter-rouge">
          Trie
         </code>
         constructor initializes the Trie with a root
         <code class="language-plaintext highlighter-rouge">
          TrieNode
         </code>
         .
        </p>
       </li>
       <li>
        <strong>
         <code class="language-plaintext highlighter-rouge">
          insert
         </code>
         Method
        </strong>
        : Inserts a word into the Trie.
        <ul>
         <li>
          Iterates through each letter in the word.
         </li>
         <li>
          For each letter, it moves down to the corresponding child node, creating new nodes as necessary due to the use of
          <code class="language-plaintext highlighter-rouge">
           defaultdict
          </code>
          .
         </li>
         <li>
          After all letters are inserted, sets the
          <code class="language-plaintext highlighter-rouge">
           is_word
          </code>
          flag of the last node to
          <code class="language-plaintext highlighter-rouge">
           True
          </code>
          to mark the end of a word.
         </li>
        </ul>
       </li>
       <li>
        <strong>
         <code class="language-plaintext highlighter-rouge">
          search
         </code>
         Method
        </strong>
        : Searches for a word in the Trie.
        <ul>
         <li>
          Iterates through each letter in the word, navigating through the child nodes.
         </li>
         <li>
          If a letter does not exist as a key in the current nodeâs children (i.e.,
          <code class="language-plaintext highlighter-rouge">
           cur.child.get(letter)
          </code>
          returns
          <code class="language-plaintext highlighter-rouge">
           None
          </code>
          ), returns
          <code class="language-plaintext highlighter-rouge">
           False
          </code>
          immediately.
         </li>
         <li>
          If all letters are found in sequence, checks the
          <code class="language-plaintext highlighter-rouge">
           is_word
          </code>
          flag of the last node. Returns
          <code class="language-plaintext highlighter-rouge">
           True
          </code>
          if itâs set (meaning the word exists in the Trie), otherwise
          <code class="language-plaintext highlighter-rouge">
           False
          </code>
          .
         </li>
        </ul>
       </li>
       <li>
        <strong>
         <code class="language-plaintext highlighter-rouge">
          startsWith
         </code>
         Method
        </strong>
        : Checks if there is any word in the Trie that starts with the given prefix.
        <ul>
         <li>
          Similar to
          <code class="language-plaintext highlighter-rouge">
           search
          </code>
          , but returns
          <code class="language-plaintext highlighter-rouge">
           True
          </code>
          as soon as all letters of the prefix are found in sequence, without checking the
          <code class="language-plaintext highlighter-rouge">
           is_word
          </code>
          flag. This is because the presence of the prefix nodes alone is sufficient to confirm that at least one word with that prefix exists in the Trie.
         </li>
        </ul>
       </li>
      </ul>
      <h3 id="usage-and-functionality">
       Usage and Functionality:
      </h3>
      <p>
       This Trie implementation allows for efficient insertion and search operations for words and prefixes. The
       <code class="language-plaintext highlighter-rouge">
        defaultdict
       </code>
       significantly simplifies the code by automatically handling missing children. This Trie can be used in various applications such as implementing an autocomplete feature, spell checker, or for efficiently solving word search puzzles.
      </p>
      <p>
       Note: The comment in the
       <code class="language-plaintext highlighter-rouge">
        search
       </code>
       and
       <code class="language-plaintext highlighter-rouge">
        startsWith
       </code>
       methods about
       <code class="language-plaintext highlighter-rouge">
        cur = cur.child[letter]
       </code>
       potentially creating a default node is crucial. Using
       <code class="language-plaintext highlighter-rouge">
        cur.child.get(letter)
       </code>
       instead avoids unintended Trie modifications during search operations, ensuring that the Trie structure only changes during explicit insertions.
      </p>
      <h1 id="code">
       Code
      </h1>
      <ul class="uk-tab" data-uk-switcher="{connect:'#30af75bd-466f-4da8-b287-691c6eb71e64'}">
       <li class="uk-active">
        <a href="solution-208.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-208.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-208.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-208.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-208.html">
         TypeScript
        </a>
       </li>
       <li>
        <a href="solution-208.html">
         Javascript
        </a>
       </li>
       <li>
        <a href="solution-208.html">
         C#
        </a>
       </li>
       <li>
        <a href="solution-208.html">
         RenderScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="30af75bd-466f-4da8-b287-691c6eb71e64">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Implement_Trie_Prefix_Tree</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Implement_Trie_Prefix_Tree</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Implement_Trie_Prefix_Tree</span><span class="o">();</span>

        <span class="nc">Trie</span> <span class="n">trie</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="na">new</span> <span class="nf">Trie</span><span class="o">();</span>
        <span class="n">trie</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="s">"abc"</span><span class="o">);</span>
        <span class="n">trie</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="s">"ab"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">trie</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="s">"ab"</span><span class="o">));</span>
        <span class="n">trie</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="s">"ab"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">trie</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="s">"ab"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">trie</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"a"</span><span class="o">));</span>

    <span class="o">}</span>

    <span class="kd">class</span> <span class="nc">TrieNode</span> <span class="o">{</span>

        <span class="c1">// R children to node children</span>
        <span class="kd">private</span> <span class="nc">TrieNode</span><span class="o">[]</span> <span class="n">children</span><span class="o">;</span>

        <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">R</span> <span class="o">=</span> <span class="mi">26</span><span class="o">;</span>

        <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isEnd</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">TrieNode</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TrieNode</span><span class="o">[</span><span class="no">R</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsKey</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">children</span><span class="o">[</span><span class="n">ch</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nc">TrieNode</span> <span class="nf">get</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">children</span><span class="o">[</span><span class="n">ch</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch</span><span class="o">,</span> <span class="nc">TrieNode</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">children</span><span class="o">[</span><span class="n">ch</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setEnd</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">isEnd</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEnd</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">isEnd</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">class</span> <span class="nc">Trie</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="nc">TrieNode</span> <span class="n">root</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Trie</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TrieNode</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// Inserts a word into the trie.</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">TrieNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>

            <span class="c1">// @note:@memorize: iteration is better than recursion during trie building</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">char</span> <span class="n">currentChar</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">node</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">currentChar</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">node</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">currentChar</span><span class="o">,</span> <span class="k">new</span> <span class="nc">TrieNode</span><span class="o">());</span>
                <span class="o">}</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">currentChar</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">node</span><span class="o">.</span><span class="na">setEnd</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// search a prefix or whole key in trie and</span>
        <span class="c1">// returns the node where search ends</span>
        <span class="kd">private</span> <span class="nc">TrieNode</span> <span class="nf">searchPrefix</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">TrieNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">char</span> <span class="n">curLetter</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">curLetter</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">curLetter</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Returns if the word is in the trie.</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">TrieNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">searchPrefix</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="na">isEnd</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// Returns if there is any word in the trie</span>
        <span class="c1">// that starts with the given prefix.</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">startsWith</span><span class="o">(</span><span class="nc">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">TrieNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">searchPrefix</span><span class="o">(</span><span class="n">prefix</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Your Trie object will be instantiated and called as such:</span>
    <span class="c1">// Trie trie = new Trie();</span>
    <span class="c1">// trie.insert("somestring");</span>
    <span class="c1">// trie.search("key");</span>

<span class="o">}</span>


<span class="c1">//////</span>

<span class="kd">class</span> <span class="nc">Trie</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Trie</span><span class="o">[]</span> <span class="n">children</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isEnd</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Trie</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Trie</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Trie</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">node</span><span class="o">.</span><span class="na">isEnd</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="n">searchPrefix</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="na">isEnd</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">startsWith</span><span class="o">(</span><span class="nc">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="n">searchPrefix</span><span class="o">(</span><span class="n">prefix</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Trie</span> <span class="nf">searchPrefix</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1">// OJ: https://leetcode.com/problems/implement-trie-prefix-tree/</span>
<span class="c1">// Time: O(W) for insert/search/startsWith</span>
<span class="c1">// Space: O(1) extra space for all</span>
<span class="k">struct</span> <span class="nc">TrieNode</span> <span class="p">{</span>
    <span class="n">TrieNode</span> <span class="o">*</span><span class="n">next</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">bool</span> <span class="n">word</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Trie</span> <span class="p">{</span>
    <span class="n">TrieNode</span> <span class="n">root</span><span class="p">;</span>
    <span class="n">TrieNode</span> <span class="o">*</span><span class="n">find</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">word</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">])</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">string</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">])</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TrieNode</span><span class="p">();</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">word</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">search</span><span class="p">(</span><span class="n">string</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">word</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">startsWith</span><span class="p">(</span><span class="n">string</span> <span class="n">prefix</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">prefix</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-python highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">collections</span>

<span class="k">class</span> <span class="nc">TrieNode</span><span class="p">:</span>

	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="s">'''
    Usually, a Python dictionary throws a KeyError if you try to get an item with a key that is not currently in the dictionary.
    The defaultdict in contrast will simply create any items that you try to access

    https://stackoverflow.com/questions/5900578/how-does-collections-defaultdict-work
    '''</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">child</span> <span class="o">=</span> <span class="n">collections</span><span class="p">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="n">TrieNode</span><span class="p">)</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">is_word</span> <span class="o">=</span> <span class="bp">False</span>

<span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>

	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">TrieNode</span><span class="p">()</span>

	<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">root</span>
		<span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
			<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">child</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span>
		<span class="n">cur</span><span class="p">.</span><span class="n">is_word</span> <span class="o">=</span> <span class="bp">True</span>

	<span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">root</span>
		<span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
			<span class="c1"># cur = cur.child[letter] ==&gt; will not work, it will creat a default node for this letter
</span>			<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">child</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">cur</span><span class="p">:</span>
				<span class="k">return</span> <span class="bp">False</span>
		<span class="k">return</span> <span class="n">cur</span><span class="p">.</span><span class="n">is_word</span>

	<span class="k">def</span> <span class="nf">startsWith</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">root</span>
		<span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">prefix</span><span class="p">:</span>
			<span class="c1"># cur = cur.child[letter] ==&gt; will not work, it will creat a default node for this letter
</span>			<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">child</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">cur</span><span class="p">:</span>
				<span class="k">return</span> <span class="bp">False</span>
		<span class="k">return</span> <span class="bp">True</span>

<span class="c1"># Your Trie object will be instantiated and called as such:
# obj = Trie()
# obj.insert(word)
# param_2 = obj.search(word)
# param_3 = obj.startsWith(prefix)
</span>

<span class="c1">############
</span>
<span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">is_end</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">node</span><span class="p">.</span><span class="n">is_end</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_search_prefix</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">is_end</span>

    <span class="k">def</span> <span class="nf">startsWith</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_search_prefix</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_search_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">prefix</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">node</span>


<span class="c1"># Your Trie object will be instantiated and called as such:
# obj = Trie()
# obj.insert(word)
# param_2 = obj.search(word)
# param_3 = obj.startsWith(prefix)
</span>


<span class="c1"># below is using reduce()
</span><span class="k">class</span> <span class="nc">Trie</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">T</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">collections</span><span class="p">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">T</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="nb">reduce</span><span class="p">(</span><span class="nb">dict</span><span class="p">.</span><span class="n">__getitem__</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">root</span><span class="p">)[</span><span class="s">'#'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">'#'</span> <span class="ow">in</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">cur</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">cur</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">{}),</span> <span class="n">word</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">root</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">startsWith</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">cur</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">cur</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">{}),</span> <span class="n">prefix</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">root</span><span class="p">))</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">type</span> <span class="n">Trie</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">children</span> <span class="p">[</span><span class="m">26</span><span class="p">]</span><span class="o">*</span><span class="n">Trie</span>
	<span class="n">isEnd</span>    <span class="kt">bool</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Constructor</span><span class="p">()</span> <span class="n">Trie</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">Trie</span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Trie</span><span class="p">)</span> <span class="n">Insert</span><span class="p">(</span><span class="n">word</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">this</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">word</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">:=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span>
		<span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Trie</span><span class="p">{}</span>
		<span class="p">}</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="n">node</span><span class="o">.</span><span class="n">isEnd</span> <span class="o">=</span> <span class="no">true</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Trie</span><span class="p">)</span> <span class="n">Search</span><span class="p">(</span><span class="n">word</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">this</span><span class="o">.</span><span class="n">SearchPrefix</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">node</span> <span class="o">!=</span> <span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="n">isEnd</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Trie</span><span class="p">)</span> <span class="n">StartsWith</span><span class="p">(</span><span class="n">prefix</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">this</span><span class="o">.</span><span class="n">SearchPrefix</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">node</span> <span class="o">!=</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Trie</span><span class="p">)</span> <span class="n">SearchPrefix</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="n">Trie</span> <span class="p">{</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">this</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">:=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span>
		<span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="no">nil</span>
		<span class="p">}</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">node</span>
<span class="p">}</span>

<span class="c">/**
 * Your Trie object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Insert(word);
 * param_2 := obj.Search(word);
 * param_3 := obj.StartsWith(prefix);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nx">TrieNode</span> <span class="p">{</span>
    <span class="nx">children</span><span class="p">;</span>
    <span class="nx">isEnd</span><span class="p">;</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">children</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">26</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">isEnd</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Trie</span> <span class="p">{</span>
    <span class="nx">root</span><span class="p">;</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TrieNode</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="nx">insert</span><span class="p">(</span><span class="nx">word</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">head</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">char</span> <span class="k">of</span> <span class="nx">word</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">char</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">97</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">head</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span> <span class="p">{</span>
                <span class="nx">head</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TrieNode</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="nx">head</span> <span class="o">=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="nx">head</span><span class="p">.</span><span class="nx">isEnd</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">search</span><span class="p">(</span><span class="nx">word</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">boolean</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">head</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">searchPrefix</span><span class="p">(</span><span class="nx">word</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">head</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">head</span><span class="p">.</span><span class="nx">isEnd</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">startsWith</span><span class="p">(</span><span class="nx">prefix</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">boolean</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">searchPrefix</span><span class="p">(</span><span class="nx">prefix</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="nx">searchPrefix</span><span class="p">(</span><span class="nx">prefix</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">head</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">char</span> <span class="k">of</span> <span class="nx">prefix</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">char</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">97</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">head</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span> <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
            <span class="nx">head</span> <span class="o">=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">head</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-js highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Initialize your data structure here.
 */</span>
<span class="kd">var</span> <span class="nx">Trie</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">children</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">};</span>

<span class="cm">/**
 * Inserts a word into the trie.
 * @param {string} word
 * @return {void}
 */</span>
<span class="nx">Trie</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">insert</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">word</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">char</span> <span class="k">of</span> <span class="nx">word</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">[</span><span class="nx">char</span><span class="p">])</span> <span class="p">{</span>
            <span class="nx">node</span><span class="p">[</span><span class="nx">char</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="p">}</span>
        <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">[</span><span class="nx">char</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">isEnd</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**
 * Returns if the word is in the trie.
 * @param {string} word
 * @return {boolean}
 */</span>
<span class="nx">Trie</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">search</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">word</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">searchPrefix</span><span class="p">(</span><span class="nx">word</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">node</span> <span class="o">!=</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">isEnd</span> <span class="o">!=</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">Trie</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">searchPrefix</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">prefix</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">char</span> <span class="k">of</span> <span class="nx">prefix</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">[</span><span class="nx">char</span><span class="p">])</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">[</span><span class="nx">char</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**
 * Returns if there is any word in the trie that starts with the given prefix.
 * @param {string} prefix
 * @return {boolean}
 */</span>
<span class="nx">Trie</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">startsWith</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">prefix</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">searchPrefix</span><span class="p">(</span><span class="nx">prefix</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Trie</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">isEnd</span><span class="p">;</span>
    <span class="n">Trie</span><span class="p">[]</span> <span class="n">children</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Trie</span><span class="p">[</span><span class="m">26</span><span class="p">];</span>

    <span class="k">public</span> <span class="nf">Trie</span><span class="p">()</span> <span class="p">{</span>

    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Insert</span><span class="p">(</span><span class="kt">string</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Trie</span> <span class="n">node</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">c</span> <span class="k">in</span> <span class="n">word</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">idx</span> <span class="p">=</span> <span class="n">c</span> <span class="p">-</span> <span class="sc">'a'</span><span class="p">;</span>
            <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="p">??=</span> <span class="k">new</span> <span class="nf">Trie</span><span class="p">();</span>
            <span class="n">node</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">node</span><span class="p">.</span><span class="n">isEnd</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">Search</span><span class="p">(</span><span class="kt">string</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Trie</span> <span class="n">node</span> <span class="p">=</span> <span class="nf">SearchPrefix</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">node</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">node</span><span class="p">.</span><span class="n">isEnd</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">StartsWith</span><span class="p">(</span><span class="kt">string</span> <span class="n">prefix</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Trie</span> <span class="n">node</span> <span class="p">=</span> <span class="nf">SearchPrefix</span><span class="p">(</span><span class="n">prefix</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">node</span> <span class="p">!=</span> <span class="k">null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="n">Trie</span> <span class="nf">SearchPrefix</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Trie</span> <span class="n">node</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">c</span> <span class="k">in</span> <span class="n">s</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">idx</span> <span class="p">=</span> <span class="n">c</span> <span class="p">-</span> <span class="sc">'a'</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">node</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.Insert(word);
 * bool param_2 = obj.Search(word);
 * bool param_3 = obj.StartsWith(prefix);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-rs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">,</span> <span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">,</span> <span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">TrieNode</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">val</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">flag</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">child</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">char</span><span class="p">,</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TrieNode</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">TrieNode</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">val</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="n">flag</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span>
            <span class="n">child</span><span class="p">:</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">new_with_val</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">val</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">),</span>
            <span class="n">flag</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span>
            <span class="n">child</span><span class="p">:</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Trie</span> <span class="p">{</span>
    <span class="n">root</span><span class="p">:</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TrieNode</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="cd">/// Your Trie object will be instantiated and called as such:</span>
<span class="cd">/// let obj = Trie::new();</span>
<span class="cd">/// obj.insert(word);</span>
<span class="cd">/// let ret_2: bool = obj.search(word);</span>
<span class="cd">/// let ret_3: bool = obj.starts_with(prefix);</span>
<span class="k">impl</span> <span class="n">Trie</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">TrieNode</span><span class="p">::</span><span class="nf">new</span><span class="p">())),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">char_vec</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">word</span><span class="nf">.chars</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>
        <span class="c1">// Get the clone of current root node</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">root</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">char_vec</span> <span class="p">{</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">root</span><span class="nf">.borrow</span><span class="p">()</span><span class="py">.child</span><span class="nf">.contains_key</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// We need to manually create the entry</span>
                <span class="n">root</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.child</span><span class="nf">.insert</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">TrieNode</span><span class="p">::</span><span class="nf">new</span><span class="p">())));</span>
            <span class="p">}</span>
            <span class="c1">// Get the child node</span>
            <span class="k">let</span> <span class="n">root_clone</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">root</span><span class="nf">.borrow</span><span class="p">()</span><span class="py">.child</span><span class="nf">.get</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">());</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root_clone</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">{</span>
            <span class="n">root</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.flag</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">search</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">char_vec</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">word</span><span class="nf">.chars</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>
        <span class="c1">// Get the clone of current root node</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">root</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">char_vec</span> <span class="p">{</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">root</span><span class="nf">.borrow</span><span class="p">()</span><span class="py">.child</span><span class="nf">.contains_key</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// Get the child node</span>
            <span class="k">let</span> <span class="n">root_clone</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">root</span><span class="nf">.borrow</span><span class="p">()</span><span class="py">.child</span><span class="nf">.get</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">());</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root_clone</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">root</span><span class="nf">.borrow</span><span class="p">()</span><span class="py">.flag</span><span class="p">;</span>
        <span class="n">flag</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">starts_with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">char_vec</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">prefix</span><span class="nf">.chars</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>
        <span class="c1">// Get the clone of current root node</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">root</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">char_vec</span> <span class="p">{</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">root</span><span class="nf">.borrow</span><span class="p">()</span><span class="py">.child</span><span class="nf">.contains_key</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// Get the child node</span>
            <span class="k">let</span> <span class="n">root_clone</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">root</span><span class="nf">.borrow</span><span class="p">()</span><span class="py">.child</span><span class="nf">.get</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">());</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root_clone</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">true</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-208.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
