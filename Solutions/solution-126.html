<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-126.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-126.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>126 - Word Ladder II</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode Question Formatted question description: https://leetcode.ca/all/126.html A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -&amp;gt; s1 -&amp;gt; s2 -&amp;gt; ... -&amp;gt; sk such that: Every adjacent pair of words differs by a single letter. Every...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-126.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-126.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-126.html" rel="stylesheet"/>
   <link href="solution-126.html" rel="stylesheet"/>
   <link href="solution-126.html" rel="stylesheet"/>
   <link href="solution-126.html" rel="stylesheet"/>
   <link href="solution-126.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="126 - Word Ladder II" property="og:title"/>
   <meta content="Leetcode Question Formatted question description: https://leetcode.ca/all/126.html A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -&amp;gt; s1 -&amp;gt; s2 -&amp;gt; ... -&amp;gt; sk such that: Every adjacent pair of words differs by a single letter. Every si for 1 &amp;lt;= i &amp;lt;= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk]. &amp;nbsp; Example 1: Input: beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;] Output: [[&amp;quot;hit&amp;quot;,&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;cog&amp;quot;],[&amp;quot;hit&amp;quot;,&amp;quot;hot&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;]] Explanation:&amp;nbsp;There are 2 shortest transformation sequences: &amp;quot;hit&amp;quot; -&amp;gt; &amp;quot;hot&amp;quot; -&amp;gt; &amp;quot;dot&amp;quot; -&amp;gt; &amp;quot;dog&amp;quot; -&amp;gt; &amp;quot;cog&amp;quot; &amp;quot;hit&amp;quot; -&amp;gt; &amp;quot;hot&amp;quot; -&amp;gt; &amp;quot;lot&amp;quot; -&amp;gt; &amp;quot;log&amp;quot; -&amp;gt; &amp;quot;cog&amp;quot; Example 2: Input: beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;] Output: [] Explanation: The endWord &amp;quot;cog&amp;quot; is not in wordList, therefore there is no valid transformation sequence. &amp;nbsp; Constraints: 1 &amp;lt;= beginWord.length &amp;lt;= 5 endWord.length == beginWord.length 1 &amp;lt;= wordList.length &amp;lt;= 500 wordList[i].length == beginWord.length beginWord, endWord, and wordList[i] consist of lowercase English letters. beginWord != endWord All the words in wordList are unique. The sum of all shortest transformation sequences does not exceed 105. Algorithm This solution uses a combination of Breadth-First Search (BFS) for discovering the shortest paths and Depth-First Search (DFS) for building the actual paths, a common approach for such problems. Hereâs a step-by-step explanation of the code: BFS Phase Initialization: The words set contains all the words from wordList, ensuring quick lookup. If endWord is not in words, the function returns an empty list as no transformation is possible. Distance and Predecessor Tracking: dist keeps track of the shortest distance (in terms of steps) from beginWord to any word encountered during BFS. prev is a mapping from a word to all of its predecessors on the shortest path from the beginWord. BFS Execution: Starting from beginWord, the code iteratively transforms each letter of the current word to all possible 26 letters and checks if the new word is in words. If a new valid word is found, itâs added to the queue for further exploration, and its distance and predecessors are updated. The BFS continues until endWord is found (found = True), ensuring only the shortest paths are considered. Key BFS Details: The BFS layer-by-layer processing is essential for finding the shortest path efficiently. When a transformation leads to a word already at the current step, it means this word can be reached through another transformation, so the current word is added as its predecessor. The check if dist.get(t, 0) == step ensures that only words reachable in the current number of steps are considered, which helps in identifying all predecessors of words on the shortest paths. Once endWord is found, the BFS search can stop,..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-04-04T22:21:01-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-04-04-126-Word-Ladder-II/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-126.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="126 - Word Ladder II" property="twitter:title"/>
   <meta content="Leetcode Question Formatted question description: https://leetcode.ca/all/126.html A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -&amp;gt; s1 -&amp;gt; s2 -&amp;gt; ... -&amp;gt; sk such that: Every adjacent pair of words differs by a single letter. Every si for 1 &amp;lt;= i &amp;lt;= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk]. &amp;nbsp; Example 1: Input: beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;] Output: [[&amp;quot;hit&amp;quot;,&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;cog&amp;quot;],[&amp;quot;hit&amp;quot;,&amp;quot;hot&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;]] Explanation:&amp;nbsp;There are 2 shortest transformation sequences: &amp;quot;hit&amp;quot; -&amp;gt; &amp;quot;hot&amp;quot; -&amp;gt; &amp;quot;dot&amp;quot; -&amp;gt; &amp;quot;dog&amp;quot; -&amp;gt; &amp;quot;cog&amp;quot; &amp;quot;hit&amp;quot; -&amp;gt; &amp;quot;hot&amp;quot; -&amp;gt; &amp;quot;lot&amp;quot; -&amp;gt; &amp;quot;log&amp;quot; -&amp;gt; &amp;quot;cog&amp;quot; Example 2: Input: beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;] Output: [] Explanation: The endWord &amp;quot;cog&amp;quot; is not in wordList, therefore there is no valid transformation sequence. &amp;nbsp; Constraints: 1 &amp;lt;= beginWord.length &amp;lt;= 5 endWord.length == beginWord.length 1 &amp;lt;= wordList.length &amp;lt;= 500 wordList[i].length == beginWord.length beginWord, endWord, and wordList[i] consist of lowercase English letters. beginWord != endWord All the words in wordList are unique. The sum of all shortest transformation sequences does not exceed 105. Algorithm This solution uses a combination of Breadth-First Search (BFS) for discovering the shortest paths and Depth-First Search (DFS) for building the actual paths, a common approach for such problems. Hereâs a step-by-step explanation of the code: BFS Phase Initialization: The words set contains all the words from wordList, ensuring quick lookup. If endWord is not in words, the function returns an empty list as no transformation is possible. Distance and Predecessor Tracking: dist keeps track of the shortest distance (in terms of steps) from beginWord to any word encountered during BFS. prev is a mapping from a word to all of its predecessors on the shortest path from the beginWord. BFS Execution: Starting from beginWord, the code iteratively transforms each letter of the current word to all possible 26 letters and checks if the new word is in words. If a new valid word is found, itâs added to the queue for further exploration, and its distance and predecessors are updated. The BFS continues until endWord is found (found = True), ensuring only the shortest paths are considered. Key BFS Details: The BFS layer-by-layer processing is essential for finding the shortest path efficiently. When a transformation leads to a word already at the current step, it means this word can be reached through another transformation, so the current word is added as its predecessor. The check if dist.get(t, 0) == step ensures that only words reachable in the current number of steps are considered, which helps in identifying all predecessors of words on the shortest paths. Once endWord is found, the BFS search can stop,..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    126 - Word Ladder II | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="126 - Word Ladder II" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-126.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-04-04-126-Word-Ladder-II/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-04-04T22:21:01-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"126 - Word Ladder II","dateModified":"2016-04-04T22:21:01-07:00","datePublished":"2016-04-04T22:21:01-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-04-04-126-Word-Ladder-II/"},"url":"https://leetcode.ca/2016-04-04-126-Word-Ladder-II/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="question">
       Question
      </h1>
      <p>
       Formatted question description:
       <a href="solution-126.html">
        https://leetcode.ca/all/126.html
       </a>
      </p>
      <p>
       A
       <strong>
        transformation sequence
       </strong>
       from word
       <code>
        beginWord
       </code>
       to word
       <code>
        endWord
       </code>
       using a dictionary
       <code>
        wordList
       </code>
       is a sequence of words
       <code>
        beginWord -&gt; s
        <sub>
         1
        </sub>
        -&gt; s
        <sub>
         2
        </sub>
        -&gt; ... -&gt; s
        <sub>
         k
        </sub>
       </code>
       such that:
      </p>
      <ul>
       <li>
        Every adjacent pair of words differs by a single letter.
       </li>
       <li>
        Every
        <code>
         s
         <sub>
          i
         </sub>
        </code>
        for
        <code>
         1 &lt;= i &lt;= k
        </code>
        is in
        <code>
         wordList
        </code>
        . Note that
        <code>
         beginWord
        </code>
        does not need to be in
        <code>
         wordList
        </code>
        .
       </li>
       <li>
        <code>
         s
         <sub>
          k
         </sub>
         == endWord
        </code>
       </li>
      </ul>
      <p>
       Given two words,
       <code>
        beginWord
       </code>
       and
       <code>
        endWord
       </code>
       , and a dictionary
       <code>
        wordList
       </code>
       , return
       <em>
        all the
        <strong>
         shortest transformation sequences
        </strong>
        from
       </em>
       <code>
        beginWord
       </code>
       <em>
        to
       </em>
       <code>
        endWord
       </code>
       <em>
        , or an empty list if no such sequence exists. Each sequence should be returned as a list of the words
       </em>
       <code>
        [beginWord, s
        <sub>
         1
        </sub>
        , s
        <sub>
         2
        </sub>
        , ..., s
        <sub>
         k
        </sub>
        ]
       </code>
       .
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
<strong>Output:</strong> [["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]
<strong>Explanation:</strong> There are 2 shortest transformation sequences:
"hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog"
"hit" -&gt; "hot" -&gt; "lot" -&gt; "log" -&gt; "cog"
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
<strong>Output:</strong> []
<strong>Explanation:</strong> The endWord "cog" is not in wordList, therefore there is no valid transformation sequence.
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= beginWord.length &lt;= 5
        </code>
       </li>
       <li>
        <code>
         endWord.length == beginWord.length
        </code>
       </li>
       <li>
        <code>
         1 &lt;= wordList.length &lt;= 500
        </code>
       </li>
       <li>
        <code>
         wordList[i].length == beginWord.length
        </code>
       </li>
       <li>
        <code>
         beginWord
        </code>
        ,
        <code>
         endWord
        </code>
        , and
        <code>
         wordList[i]
        </code>
        consist of lowercase English letters.
       </li>
       <li>
        <code>
         beginWord != endWord
        </code>
       </li>
       <li>
        All the words in
        <code>
         wordList
        </code>
        are
        <strong>
         unique
        </strong>
        .
       </li>
       <li>
        The
        <strong>
         sum
        </strong>
        of all shortest transformation sequences does not exceed
        <code>
         10
         <sup>
          5
         </sup>
        </code>
        .
       </li>
      </ul>
      <h1 id="algorithm">
       Algorithm
      </h1>
      <p>
       This solution uses a combination of Breadth-First Search (BFS) for discovering the shortest paths and Depth-First Search (DFS) for building the actual paths, a common approach for such problems.
      </p>
      <p>
       Hereâs a step-by-step explanation of the code:
      </p>
      <h3 id="bfs-phase">
       BFS Phase
      </h3>
      <ol>
       <li>
        <p>
         <strong>
          Initialization
         </strong>
         : The
         <code class="language-plaintext highlighter-rouge">
          words
         </code>
         set contains all the words from
         <code class="language-plaintext highlighter-rouge">
          wordList
         </code>
         , ensuring quick lookup. If
         <code class="language-plaintext highlighter-rouge">
          endWord
         </code>
         is not in
         <code class="language-plaintext highlighter-rouge">
          words
         </code>
         , the function returns an empty list as no transformation is possible.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Distance and Predecessor Tracking
         </strong>
         :
         <code class="language-plaintext highlighter-rouge">
          dist
         </code>
         keeps track of the shortest distance (in terms of steps) from
         <code class="language-plaintext highlighter-rouge">
          beginWord
         </code>
         to any word encountered during BFS.
         <code class="language-plaintext highlighter-rouge">
          prev
         </code>
         is a mapping from a word to all of its predecessors on the shortest path from the
         <code class="language-plaintext highlighter-rouge">
          beginWord
         </code>
         .
        </p>
       </li>
       <li>
        <p>
         <strong>
          BFS Execution
         </strong>
         : Starting from
         <code class="language-plaintext highlighter-rouge">
          beginWord
         </code>
         , the code iteratively transforms each letter of the current word to all possible 26 letters and checks if the new word is in
         <code class="language-plaintext highlighter-rouge">
          words
         </code>
         . If a new valid word is found, itâs added to the queue for further exploration, and its distance and predecessors are updated. The BFS continues until
         <code class="language-plaintext highlighter-rouge">
          endWord
         </code>
         is found (
         <code class="language-plaintext highlighter-rouge">
          found = True
         </code>
         ), ensuring only the shortest paths are considered.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Key BFS Details
         </strong>
         :
        </p>
        <ul>
         <li>
          The BFS layer-by-layer processing is essential for finding the shortest path efficiently.
         </li>
         <li>
          When a transformation leads to a word already at the current
          <code class="language-plaintext highlighter-rouge">
           step
          </code>
          , it means this word can be reached through another transformation, so the current word is added as its predecessor.
         </li>
         <li>
          The check
          <code class="language-plaintext highlighter-rouge">
           if dist.get(t, 0) == step
          </code>
          ensures that only words reachable in the current number of steps are considered, which helps in identifying all predecessors of words on the shortest paths.
         </li>
         <li>
          Once
          <code class="language-plaintext highlighter-rouge">
           endWord
          </code>
          is found, the BFS search can stop, as all shortest paths to
          <code class="language-plaintext highlighter-rouge">
           endWord
          </code>
          would have been discovered due to the layer-by-layer nature of BFS.
         </li>
        </ul>
       </li>
      </ol>
      <h3 id="dfs-phase">
       DFS Phase
      </h3>
      <ol>
       <li>
        <p>
         <strong>
          Building Paths
         </strong>
         : The
         <code class="language-plaintext highlighter-rouge">
          dfs
         </code>
         function is a recursive function that constructs paths from
         <code class="language-plaintext highlighter-rouge">
          endWord
         </code>
         back to
         <code class="language-plaintext highlighter-rouge">
          beginWord
         </code>
         using the
         <code class="language-plaintext highlighter-rouge">
          prev
         </code>
         mapping filled during BFS. It does so by starting with
         <code class="language-plaintext highlighter-rouge">
          endWord
         </code>
         and recursively exploring all its predecessors, appending each valid path to
         <code class="language-plaintext highlighter-rouge">
          ans
         </code>
         .
        </p>
       </li>
       <li>
        <p>
         <strong>
          Path Construction
         </strong>
         : The path is constructed in reverse (from
         <code class="language-plaintext highlighter-rouge">
          endWord
         </code>
         to
         <code class="language-plaintext highlighter-rouge">
          beginWord
         </code>
         ) because the
         <code class="language-plaintext highlighter-rouge">
          prev
         </code>
         mapping stores how to reach each word from the start word, making it natural to traverse the mapping in reverse to reconstruct the path. Once the path reaches
         <code class="language-plaintext highlighter-rouge">
          beginWord
         </code>
         , itâs reversed to match the required direction and added to
         <code class="language-plaintext highlighter-rouge">
          ans
         </code>
         .
        </p>
       </li>
       <li>
        <p>
         <strong>
          Efficiency Considerations
         </strong>
         : The reason for traversing from
         <code class="language-plaintext highlighter-rouge">
          endWord
         </code>
         to
         <code class="language-plaintext highlighter-rouge">
          beginWord
         </code>
         (as noted in the comment) is to reduce the number of paths explored during DFS. Since
         <code class="language-plaintext highlighter-rouge">
          prev
         </code>
         contains only predecessors on the shortest paths, paths that do not lead to
         <code class="language-plaintext highlighter-rouge">
          endWord
         </code>
         in the minimum number of steps are naturally excluded, making the DFS phase more efficient.
        </p>
       </li>
      </ol>
      <h3 id="conclusion">
       Conclusion
      </h3>
      <p>
       This approach ensures that all shortest transformation sequences are found by first using BFS to discover the shortest path lengths and record predecessors, then using DFS to build the paths from these predecessors. The combination of BFS for shortest path discovery and DFS for path construction is a powerful pattern for solving similar problems in graph theory and word transformation challenges.
      </p>
      <h1 id="code">
       Code
      </h1>
      <ul class="uk-tab" data-uk-switcher="{connect:'#bf607188-4f05-48df-9627-3a13f1b6ec83'}">
       <li class="uk-active">
        <a href="solution-126.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-126.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-126.html">
         Go
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="bf607188-4f05-48df-9627-3a13f1b6ec83">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.LinkedList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Queue</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Word_Ladder_II</span> <span class="o">{</span>

	<span class="c1">// iteration bfs</span>
	<span class="c1">// https://leetcode.com/problems/word-ladder-ii/solution/</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;();</span>

        <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="nf">findLadders</span><span class="o">(</span><span class="nc">String</span> <span class="n">start</span><span class="o">,</span> <span class="nc">String</span> <span class="n">end</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">dict</span><span class="o">)</span> <span class="o">{</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">start</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">end</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">dict</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">list</span><span class="o">;</span>

            <span class="n">dict</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">end</span><span class="o">);</span> <span class="c1">// !!!</span>

            <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
            <span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">currentLevelCount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">newLevelCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="kt">boolean</span> <span class="n">found</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">foundLevel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

            <span class="c1">// from end word, to all paths</span>
            <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;&gt;();</span>


            <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
            <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">singlePath</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
            <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">allPaths</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;();</span>

            <span class="n">singlePath</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
            <span class="n">allPaths</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">singlePath</span><span class="o">);</span>
            <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">allPaths</span><span class="o">);</span>

            <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>

                <span class="nc">String</span> <span class="n">current</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="n">currentLevelCount</span><span class="o">--;</span> <span class="c1">// è¿éç¨äºæ°æ§countæ¥æ è®°æ¯ä¸ªlevelï¼æ²¡æç¨null</span>

                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="kt">char</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>

                    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">'a'</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
                        <span class="nc">String</span> <span class="n">each</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">array</span><span class="o">);</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">each</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">end</span><span class="o">))</span> <span class="o">{</span>
                            <span class="n">found</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                            <span class="n">foundLevel</span> <span class="o">=</span> <span class="n">level</span><span class="o">;</span>
                        <span class="o">}</span>


                        <span class="k">if</span> <span class="o">(</span><span class="n">dict</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">each</span><span class="o">))</span> <span class="o">{</span>
                            <span class="c1">// q.offer(each);</span>
                            <span class="n">newLevelCount</span><span class="o">++;</span>

                            <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">prevAllPaths</span> <span class="o">=</span> <span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>

                            <span class="k">if</span> <span class="o">(</span><span class="n">hm</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">each</span><span class="o">))</span>
                                <span class="n">allPaths</span> <span class="o">=</span> <span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">each</span><span class="o">);</span>
                            <span class="k">else</span> <span class="o">{</span>
                                <span class="cm">/* @note@note:
	                                enqueue is here. if no path ending at this one, then has to explore in future
	                                if there is path ending at this one, meaning it's been explored already. no need to enqueue
	                            */</span>
                                <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">each</span><span class="o">);</span>
                                <span class="n">allPaths</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;();</span>
                                <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">each</span><span class="o">,</span> <span class="n">allPaths</span><span class="o">);</span>
                            <span class="o">}</span>

                            <span class="c1">// @note@note: this if is the key !!! no path for new word, or new word path is one more than previous path</span>
                            <span class="c1">// using this if, the"if visited" check can be removed</span>
                            <span class="c1">// if (allPaths.size() == 0 || prevAllPaths.size() + 1 == allPaths.size()) {</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">allPaths</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">prevAllPaths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">size</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">allPaths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
                                <span class="k">for</span> <span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">eachPath</span> <span class="o">:</span> <span class="n">prevAllPaths</span><span class="o">)</span> <span class="o">{</span>
                                    <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">newone</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="n">eachPath</span><span class="o">);</span>
                                    <span class="n">newone</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">each</span><span class="o">);</span>
                                    <span class="n">allPaths</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">newone</span><span class="o">);</span>
                                <span class="o">}</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="c1">// @note@note: also the key, to make sure only find shortest</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">found</span> <span class="o">&amp;&amp;</span> <span class="n">foundLevel</span> <span class="o">!=</span> <span class="n">level</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// @note: must be after trying the last word of currentLevel, then update</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">currentLevelCount</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">currentLevelCount</span> <span class="o">=</span> <span class="n">newLevelCount</span><span class="o">;</span>
                    <span class="n">newLevelCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">level</span><span class="o">++;</span>

                <span class="o">}</span>

            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(!</span><span class="n">found</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">for</span> <span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">each</span> <span class="o">:</span> <span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">end</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">each</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="n">list</span><span class="o">;</span>

        <span class="o">}</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution_recursion</span> <span class="o">{</span>

        <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">findPath</span><span class="o">(</span><span class="nc">String</span> <span class="n">fromWord</span><span class="o">,</span> <span class="nc">String</span> <span class="n">toWord</span><span class="o">,</span>
                                      <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">seenWords</span><span class="o">)</span> <span class="o">{</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">fromWord</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">toWord</span><span class="o">))</span> <span class="o">{</span>
                <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">toWord</span><span class="o">);</span>
                <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Find all words that you can go to from fromWord</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nextWords</span> <span class="o">=</span> <span class="n">getNextWords</span><span class="o">(</span><span class="n">fromWord</span><span class="o">,</span> <span class="n">seenWords</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">word</span> <span class="o">:</span> <span class="n">nextWords</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">newSeenWords</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="n">seenWords</span><span class="o">);</span>
                <span class="n">newSeenWords</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
                <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">subPath</span> <span class="o">=</span> <span class="n">findPath</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">toWord</span><span class="o">,</span> <span class="n">newSeenWords</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">subPath</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">subPath</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">fromWord</span><span class="o">);</span>
                    <span class="k">return</span> <span class="n">subPath</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// There wasn't a path</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

        <span class="o">}</span>

        <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="no">WORDS</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"head"</span><span class="o">,</span> <span class="s">"heal"</span><span class="o">,</span>
            <span class="s">"teal"</span><span class="o">,</span> <span class="s">"tell"</span><span class="o">,</span> <span class="s">"tall"</span><span class="o">,</span> <span class="s">"tail"</span><span class="o">);</span>

        <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="no">ALPHA</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="sc">'a'</span><span class="o">,</span> <span class="sc">'b'</span><span class="o">,</span>
            <span class="sc">'c'</span><span class="o">,</span> <span class="sc">'d'</span><span class="o">,</span> <span class="sc">'e'</span><span class="o">,</span> <span class="sc">'f'</span><span class="o">,</span> <span class="sc">'g'</span><span class="o">,</span> <span class="sc">'h'</span><span class="o">,</span> <span class="sc">'i'</span><span class="o">,</span> <span class="sc">'j'</span><span class="o">,</span> <span class="sc">'k'</span><span class="o">,</span> <span class="sc">'l'</span><span class="o">,</span> <span class="sc">'m'</span><span class="o">,</span> <span class="sc">'n'</span><span class="o">,</span>
            <span class="sc">'o'</span><span class="o">,</span> <span class="sc">'p'</span><span class="o">,</span> <span class="sc">'q'</span><span class="o">,</span> <span class="sc">'r'</span><span class="o">,</span> <span class="sc">'s'</span><span class="o">,</span> <span class="sc">'t'</span><span class="o">,</span> <span class="sc">'u'</span><span class="o">,</span> <span class="sc">'v'</span><span class="o">,</span> <span class="sc">'w'</span><span class="o">,</span> <span class="sc">'x'</span><span class="o">,</span> <span class="sc">'y'</span><span class="o">,</span> <span class="sc">'z'</span><span class="o">);</span>

        <span class="kd">private</span> <span class="kd">final</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="no">DICTIONARY</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span>
            <span class="no">WORDS</span><span class="o">);</span>

        <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">getNextWords</span><span class="o">(</span><span class="nc">String</span> <span class="n">fromWord</span><span class="o">,</span>
                                          <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">seenWords</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">outList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
            <span class="nc">StringBuilder</span> <span class="n">builder</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fromWord</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="n">fromWord</span><span class="o">);</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">Character</span> <span class="n">j</span> <span class="o">:</span> <span class="no">ALPHA</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">fromWord</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                        <span class="k">continue</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">builder</span><span class="o">.</span><span class="na">setCharAt</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
                    <span class="nc">String</span> <span class="n">potentialWord</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
                    <span class="k">if</span> <span class="o">(</span><span class="no">DICTIONARY</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">potentialWord</span><span class="o">)</span>
                        <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">seenWords</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">potentialWord</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">outList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">potentialWord</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">outList</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">//////</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">prev</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="nf">findLadders</span><span class="o">(</span><span class="nc">String</span> <span class="n">beginWord</span><span class="o">,</span> <span class="nc">String</span> <span class="n">endWord</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordList</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;(</span><span class="n">wordList</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">words</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">endWord</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">words</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">beginWord</span><span class="o">);</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">dist</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">dist</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">beginWord</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">beginWord</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">found</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">found</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">++</span><span class="n">step</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">k</span> <span class="o">=</span> <span class="sc">'a'</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">chars</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
                        <span class="nc">String</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">chars</span><span class="o">);</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">dist</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="n">step</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">prev</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">t</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
                        <span class="o">}</span>
                        <span class="k">if</span> <span class="o">(!</span><span class="n">words</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">t</span><span class="o">))</span> <span class="o">{</span>
                            <span class="k">continue</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="n">prev</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">key</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;()).</span><span class="na">add</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
                        <span class="n">words</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
                        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
                        <span class="n">dist</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">step</span><span class="o">);</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">endWord</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">t</span><span class="o">))</span> <span class="o">{</span>
                            <span class="n">found</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                    <span class="n">chars</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">ch</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">found</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
            <span class="n">path</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">endWord</span><span class="o">);</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">path</span><span class="o">,</span> <span class="n">beginWord</span><span class="o">,</span> <span class="n">endWord</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">path</span><span class="o">,</span> <span class="nc">String</span> <span class="n">beginWord</span><span class="o">,</span> <span class="nc">String</span> <span class="n">cur</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">beginWord</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">path</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">precursor</span> <span class="o">:</span> <span class="n">prev</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">cur</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">path</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">precursor</span><span class="o">);</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">path</span><span class="o">,</span> <span class="n">beginWord</span><span class="o">,</span> <span class="n">precursor</span><span class="o">);</span>
            <span class="n">path</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-python highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="s">'''
remove() same as discard()

&gt;&gt;&gt; a = set([11,22,33])
&gt;&gt;&gt; a.remove(22)
&gt;&gt;&gt; a
{33, 11}

&gt;&gt;&gt; a = set([11,22,33])
&gt;&gt;&gt; a.discard(22)
&gt;&gt;&gt; a
{33, 11}


&gt;&gt;&gt; a=set([1,2,3])
&gt;&gt;&gt; a.discard(555)
&gt;&gt;&gt; a.remove(555)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 555
'''</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findLadders</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">beginWord</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">endWord</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wordList</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="c1"># endWord to beginWord
</span>        <span class="c1"># better than begin to end, too many paths not in final result
</span>        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">cur</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cur</span> <span class="o">==</span> <span class="n">beginWord</span><span class="p">:</span>
                <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">return</span>
            <span class="k">for</span> <span class="n">precursor</span> <span class="ow">in</span> <span class="n">prev</span><span class="p">[</span><span class="n">cur</span><span class="p">]:</span>
                <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">precursor</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">precursor</span><span class="p">)</span>
                <span class="n">path</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">wordList</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">endWord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ans</span>
        <span class="c1"># no exception if beginWord not in set
</span>        <span class="n">words</span><span class="p">.</span><span class="n">discard</span><span class="p">(</span><span class="n">beginWord</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="p">{</span><span class="n">beginWord</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">beginWord</span><span class="p">])</span>
        <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">q</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
                    <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">26</span><span class="p">):</span>
                        <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">dist</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">step</span><span class="p">:</span>
                            <span class="n">prev</span><span class="p">[</span><span class="n">t</span><span class="p">].</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="c1"># repeated 3 lines below
</span>                        <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span> 
                        <span class="c1"># if above '== step' met, then t must be removed from words[] from previous iterations
</span>                            <span class="k">continue</span>
                        <span class="n">prev</span><span class="p">[</span><span class="n">t</span><span class="p">].</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="c1"># repeated 3 lines above
</span>                        <span class="n">words</span><span class="p">.</span><span class="n">discard</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                        <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                        <span class="n">dist</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span>
                        <span class="k">if</span> <span class="n">endWord</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
                            <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span>
        <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">endWord</span><span class="p">]</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">endWord</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span>

<span class="c1">############
</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">findLadders</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beginWord</span><span class="p">,</span> <span class="n">endWord</span><span class="p">,</span> <span class="n">wordlist</span><span class="p">):</span>
    <span class="s">"""
    :type beginWord: str
    :type endWord: str
    :type wordlist: Set[str]
    :rtype: List[List[int]]
    """</span>

    <span class="k">def</span> <span class="nf">getNbrs</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">wordList</span><span class="p">):</span>
      <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">string</span><span class="p">.</span><span class="n">ascii_lowercase</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">)):</span>
          <span class="n">newWord</span> <span class="o">=</span> <span class="n">src</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">src</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
          <span class="k">if</span> <span class="n">newWord</span> <span class="o">==</span> <span class="n">src</span><span class="p">:</span>
            <span class="k">continue</span>
          <span class="k">if</span> <span class="n">newWord</span> <span class="ow">in</span> <span class="n">wordList</span> <span class="ow">or</span> <span class="n">newWord</span> <span class="o">==</span> <span class="n">dest</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">newWord</span>

    <span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">beginWord</span><span class="p">,</span> <span class="n">endWord</span><span class="p">,</span> <span class="n">wordList</span><span class="p">):</span>
      <span class="n">distance</span> <span class="o">=</span> <span class="p">{</span><span class="n">beginWord</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
      <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">beginWord</span><span class="p">])</span>
      <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">length</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)):</span>
          <span class="n">top</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
          <span class="k">for</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">getNbrs</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">endWord</span><span class="p">,</span> <span class="n">wordList</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nbr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">distance</span><span class="p">:</span>
              <span class="n">distance</span><span class="p">[</span><span class="n">nbr</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span><span class="p">[</span><span class="n">top</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
              <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">nbr</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">distance</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">beginWord</span><span class="p">,</span> <span class="n">endWord</span><span class="p">,</span> <span class="n">wordList</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">distance</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">beginWord</span> <span class="o">==</span> <span class="n">endWord</span><span class="p">:</span>
        <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="p">[])</span>
        <span class="k">return</span>

      <span class="k">for</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">getNbrs</span><span class="p">(</span><span class="n">beginWord</span><span class="p">,</span> <span class="n">endWord</span><span class="p">,</span> <span class="n">wordList</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">distance</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">nbr</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">distance</span><span class="p">[</span><span class="n">beginWord</span><span class="p">]:</span>
          <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">nbr</span><span class="p">)</span>
          <span class="n">dfs</span><span class="p">(</span><span class="n">nbr</span><span class="p">,</span> <span class="n">endWord</span><span class="p">,</span> <span class="n">wordList</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span>
          <span class="n">path</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">bfs</span><span class="p">(</span><span class="n">endWord</span><span class="p">,</span> <span class="n">beginWord</span><span class="p">,</span> <span class="n">wordlist</span><span class="p">)</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">beginWord</span><span class="p">,</span> <span class="n">endWord</span><span class="p">,</span> <span class="n">wordlist</span><span class="p">,</span> <span class="p">[</span><span class="n">beginWord</span><span class="p">],</span> <span class="n">res</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">findLadders</span><span class="p">(</span><span class="n">beginWord</span> <span class="kt">string</span><span class="p">,</span> <span class="n">endWord</span> <span class="kt">string</span><span class="p">,</span> <span class="n">wordList</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">ans</span> <span class="p">[][]</span><span class="kt">string</span>
	<span class="n">words</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">word</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">wordList</span> <span class="p">{</span>
		<span class="n">words</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="no">true</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="o">!</span><span class="n">words</span><span class="p">[</span><span class="n">endWord</span><span class="p">]</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ans</span>
	<span class="p">}</span>
	<span class="n">words</span><span class="p">[</span><span class="n">beginWord</span><span class="p">]</span> <span class="o">=</span> <span class="no">false</span>
	<span class="n">dist</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="n">beginWord</span><span class="o">:</span> <span class="m">0</span><span class="p">}</span>
	<span class="n">prev</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">{}</span>
	<span class="n">q</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="n">beginWord</span><span class="p">}</span>
	<span class="n">found</span> <span class="o">:=</span> <span class="no">false</span>
	<span class="n">step</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">found</span> <span class="p">{</span>
		<span class="n">step</span><span class="o">++</span>
		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">);</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">:=</span> <span class="n">q</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
			<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">]</span>
			<span class="n">chars</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
				<span class="n">ch</span> <span class="o">:=</span> <span class="n">chars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
				<span class="k">for</span> <span class="n">k</span> <span class="o">:=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span> <span class="p">{</span>
					<span class="n">chars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kt">byte</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
					<span class="n">t</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>
					<span class="k">if</span> <span class="n">v</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">dist</span><span class="p">[</span><span class="n">t</span><span class="p">];</span> <span class="n">ok</span> <span class="p">{</span>
						<span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">step</span> <span class="p">{</span>
							<span class="n">prev</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="no">true</span>
						<span class="p">}</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="o">!</span><span class="n">words</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="p">{</span>
						<span class="k">continue</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
						<span class="n">prev</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
					<span class="p">}</span>
					<span class="n">prev</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="no">true</span>
					<span class="n">words</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="no">false</span>
					<span class="n">q</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
					<span class="n">dist</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span>
					<span class="k">if</span> <span class="n">endWord</span> <span class="o">==</span> <span class="n">t</span> <span class="p">{</span>
						<span class="n">found</span> <span class="o">=</span> <span class="no">true</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="n">chars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="n">path</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">cur</span> <span class="kt">string</span><span class="p">)</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">path</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">cur</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">cur</span> <span class="o">==</span> <span class="n">beginWord</span> <span class="p">{</span>
			<span class="n">cp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
			<span class="nb">copy</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
			<span class="n">ans</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">cp</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="n">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">prev</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="p">{</span>
			<span class="n">path</span> <span class="o">=</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="n">k</span><span class="p">},</span> <span class="n">path</span><span class="o">...</span><span class="p">)</span>
			<span class="n">dfs</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">beginWord</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
			<span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="n">found</span> <span class="p">{</span>
		<span class="n">path</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="n">endWord</span><span class="p">}</span>
		<span class="n">dfs</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">beginWord</span><span class="p">,</span> <span class="n">endWord</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ans</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-126.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
