<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-1206.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-1206.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>1206 - Design Skiplist</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 1206. Design Skiplist Description Design a Skiplist without using any built-in libraries. A skiplist is a data structure that takes O(log(n)) time to add, erase and search. Comparing with treap and red-black tree which has the same function and performance, the code length of Skiplist...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-1206.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-1206.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-1206.html" rel="stylesheet"/>
   <link href="solution-1206.html" rel="stylesheet"/>
   <link href="solution-1206.html" rel="stylesheet"/>
   <link href="solution-1206.html" rel="stylesheet"/>
   <link href="solution-1206.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="1206 - Design Skiplist" property="og:title"/>
   <meta content="Leetcode 1206. Design Skiplist Description Design a Skiplist without using any built-in libraries. A skiplist is a data structure that takes O(log(n)) time to add, erase and search. Comparing with treap and red-black tree which has the same function and performance, the code length of Skiplist can be comparatively short and the idea behind Skiplists is just simple linked lists. For example, we have a Skiplist containing [30,40,50,60,70,90] and we want to add 80 and 45 into it. The Skiplist works this way: Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons You can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, add, erase and search can be faster than O(n). It can be proven that the average time complexity for each operation is O(log(n)) and space complexity is O(n). See more about Skiplist: https://en.wikipedia.org/wiki/Skip_list Implement the Skiplist class: Skiplist() Initializes the object of the skiplist. bool search(int target) Returns true if the integer target exists in the Skiplist or false otherwise. void add(int num) Inserts the value num into the SkipList. bool erase(int num) Removes the value num from the Skiplist and returns true. If num does not exist in the Skiplist, do nothing and return false. If there exist multiple num values, removing any one of them is fine. Note that duplicates may exist in the Skiplist, your code needs to handle this situation. &amp;nbsp; Example 1: Input [&amp;quot;Skiplist&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;erase&amp;quot;, &amp;quot;erase&amp;quot;, &amp;quot;search&amp;quot;] [[], [1], [2], [3], [0], [4], [1], [0], [1], [1]] Output [null, null, null, null, false, null, true, false, true, false] Explanation Skiplist skiplist = new Skiplist(); skiplist.add(1); skiplist.add(2); skiplist.add(3); skiplist.search(0); // return False skiplist.add(4); skiplist.search(1); // return True skiplist.erase(0); // return False, 0 is not in skiplist. skiplist.erase(1); // return True skiplist.search(1); // return False, 1 has already been erased. &amp;nbsp; Constraints: 0 &amp;lt;= num, target &amp;lt;= 2 * 104 At most 5 * 104 calls will be made to search, add, and erase. Solutions Class Node: Attributes: val: The value stored in the node. next: A list of pointers to the next node at each level of the skiplist. __init__(self, val: int, level: int): Initializes a new node with the given value and number of levels. Each level in self.next is initially set to None. Class Skiplist: Static Attributes: max_level: The maximum number of levels in the skiplist. p: Probability factor used in determining the level of a new node. Instance Attributes: head: A dummy head node of the skiplist. level: The current number of levels that are in use in the skiplist. __init__(self): Initializes the skiplist with a dummy head node and sets the starting level to 0. search(self, target: int) -&amp;gt; bool: Searches for a value in the skiplist. Iterates from the top level down to the bottom, moving right through the levels as long as the next nodeâs value is less than the target. Returns True if the..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2019-03-20T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2019-03-20-1206-Design-Skiplist/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-1206.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="1206 - Design Skiplist" property="twitter:title"/>
   <meta content="Leetcode 1206. Design Skiplist Description Design a Skiplist without using any built-in libraries. A skiplist is a data structure that takes O(log(n)) time to add, erase and search. Comparing with treap and red-black tree which has the same function and performance, the code length of Skiplist can be comparatively short and the idea behind Skiplists is just simple linked lists. For example, we have a Skiplist containing [30,40,50,60,70,90] and we want to add 80 and 45 into it. The Skiplist works this way: Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons You can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, add, erase and search can be faster than O(n). It can be proven that the average time complexity for each operation is O(log(n)) and space complexity is O(n). See more about Skiplist: https://en.wikipedia.org/wiki/Skip_list Implement the Skiplist class: Skiplist() Initializes the object of the skiplist. bool search(int target) Returns true if the integer target exists in the Skiplist or false otherwise. void add(int num) Inserts the value num into the SkipList. bool erase(int num) Removes the value num from the Skiplist and returns true. If num does not exist in the Skiplist, do nothing and return false. If there exist multiple num values, removing any one of them is fine. Note that duplicates may exist in the Skiplist, your code needs to handle this situation. &amp;nbsp; Example 1: Input [&amp;quot;Skiplist&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;erase&amp;quot;, &amp;quot;erase&amp;quot;, &amp;quot;search&amp;quot;] [[], [1], [2], [3], [0], [4], [1], [0], [1], [1]] Output [null, null, null, null, false, null, true, false, true, false] Explanation Skiplist skiplist = new Skiplist(); skiplist.add(1); skiplist.add(2); skiplist.add(3); skiplist.search(0); // return False skiplist.add(4); skiplist.search(1); // return True skiplist.erase(0); // return False, 0 is not in skiplist. skiplist.erase(1); // return True skiplist.search(1); // return False, 1 has already been erased. &amp;nbsp; Constraints: 0 &amp;lt;= num, target &amp;lt;= 2 * 104 At most 5 * 104 calls will be made to search, add, and erase. Solutions Class Node: Attributes: val: The value stored in the node. next: A list of pointers to the next node at each level of the skiplist. __init__(self, val: int, level: int): Initializes a new node with the given value and number of levels. Each level in self.next is initially set to None. Class Skiplist: Static Attributes: max_level: The maximum number of levels in the skiplist. p: Probability factor used in determining the level of a new node. Instance Attributes: head: A dummy head node of the skiplist. level: The current number of levels that are in use in the skiplist. __init__(self): Initializes the skiplist with a dummy head node and sets the starting level to 0. search(self, target: int) -&amp;gt; bool: Searches for a value in the skiplist. Iterates from the top level down to the bottom, moving right through the levels as long as the next nodeâs value is less than the target. Returns True if the..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    1206 - Design Skiplist | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="1206 - Design Skiplist" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-1206.html" rel="canonical">
          <meta content="https://leetcode.ca/2019-03-20-1206-Design-Skiplist/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2019-03-20T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"1206 - Design Skiplist","dateModified":"2019-03-20T00:00:00-07:00","datePublished":"2019-03-20T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2019-03-20-1206-Design-Skiplist/"},"url":"https://leetcode.ca/2019-03-20-1206-Design-Skiplist/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="1206-design-skiplist">
       <a href="solution-1206.html">
        1206. Design Skiplist
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Design a
       <strong>
        Skiplist
       </strong>
       without using any built-in libraries.
      </p>
      <p>
       A
       <strong>
        skiplist
       </strong>
       is a data structure that takes
       <code>
        O(log(n))
       </code>
       time to add, erase and search. Comparing with treap and red-black tree which has the same function and performance, the code length of Skiplist can be comparatively short and the idea behind Skiplists is just simple linked lists.
      </p>
      <p>
       For example, we have a Skiplist containing
       <code>
        [30,40,50,60,70,90]
       </code>
       and we want to add
       <code>
        80
       </code>
       and
       <code>
        45
       </code>
       into it. The Skiplist works this way:
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1200-1299/1206.Design%20Skiplist/images/1506_skiplist.gif" style="width: 500px; height: 173px;"/>
       <br/>
       <small>
        Artyom Kalinin [CC BY-SA 3.0], via
        <a href="solution-1206.html" target="_blank" title="Artyom Kalinin [CC BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0)], via Wikimedia Commons">
         Wikimedia Commons
        </a>
       </small>
      </p>
      <p>
       You can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, add, erase and search can be faster than
       <code>
        O(n)
       </code>
       . It can be proven that the average time complexity for each operation is
       <code>
        O(log(n))
       </code>
       and space complexity is
       <code>
        O(n)
       </code>
       .
      </p>
      <p>
       See more about Skiplist:
       <a href="solution-1206.html" target="_blank">
        https://en.wikipedia.org/wiki/Skip_list
       </a>
      </p>
      <p>
       Implement the
       <code>
        Skiplist
       </code>
       class:
      </p>
      <ul>
       <li>
        <code>
         Skiplist()
        </code>
        Initializes the object of the skiplist.
       </li>
       <li>
        <code>
         bool search(int target)
        </code>
        Returns
        <code>
         true
        </code>
        if the integer
        <code>
         target
        </code>
        exists in the Skiplist or
        <code>
         false
        </code>
        otherwise.
       </li>
       <li>
        <code>
         void add(int num)
        </code>
        Inserts the value
        <code>
         num
        </code>
        into the SkipList.
       </li>
       <li>
        <code>
         bool erase(int num)
        </code>
        Removes the value
        <code>
         num
        </code>
        from the Skiplist and returns
        <code>
         true
        </code>
        . If
        <code>
         num
        </code>
        does not exist in the Skiplist, do nothing and return
        <code>
         false
        </code>
        . If there exist multiple
        <code>
         num
        </code>
        values, removing any one of them is fine.
       </li>
      </ul>
      <p>
       Note that duplicates may exist in the Skiplist, your code needs to handle this situation.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input</strong>
["Skiplist", "add", "add", "add", "search", "add", "search", "erase", "erase", "search"]
[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]
<strong>Output</strong>
[null, null, null, null, false, null, true, false, true, false]

<strong>Explanation</strong>
Skiplist skiplist = new Skiplist();
skiplist.add(1);
skiplist.add(2);
skiplist.add(3);
skiplist.search(0); // return False
skiplist.add(4);
skiplist.search(1); // return True
skiplist.erase(0);  // return False, 0 is not in skiplist.
skiplist.erase(1);  // return True
skiplist.search(1); // return False, 1 has already been erased.</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         0 &lt;= num, target &lt;= 2 * 10
         <sup>
          4
         </sup>
        </code>
       </li>
       <li>
        At most
        <code>
         5 * 10
         <sup>
          4
         </sup>
        </code>
        calls will be made to
        <code>
         search
        </code>
        ,
        <code>
         add
        </code>
        , and
        <code>
         erase
        </code>
        .
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <h3 id="class-node">
       Class Node:
      </h3>
      <ul>
       <li>
        <strong>
         Attributes:
        </strong>
        <ul>
         <li>
          <code class="language-plaintext highlighter-rouge">
           val
          </code>
          : The value stored in the node.
         </li>
         <li>
          <code class="language-plaintext highlighter-rouge">
           next
          </code>
          : A list of pointers to the next node at each level of the skiplist.
         </li>
        </ul>
       </li>
       <li>
        <strong>
         <code class="language-plaintext highlighter-rouge">
          __init__(self, val: int, level: int)
         </code>
         :
        </strong>
        Initializes a new node with the given value and number of levels. Each level in
        <code class="language-plaintext highlighter-rouge">
         self.next
        </code>
        is initially set to
        <code class="language-plaintext highlighter-rouge">
         None
        </code>
        .
       </li>
      </ul>
      <h3 id="class-skiplist">
       Class Skiplist:
      </h3>
      <ul>
       <li>
        <strong>
         Static Attributes:
        </strong>
        <ul>
         <li>
          <code class="language-plaintext highlighter-rouge">
           max_level
          </code>
          : The maximum number of levels in the skiplist.
         </li>
         <li>
          <code class="language-plaintext highlighter-rouge">
           p
          </code>
          : Probability factor used in determining the level of a new node.
         </li>
        </ul>
       </li>
       <li>
        <strong>
         Instance Attributes:
        </strong>
        <ul>
         <li>
          <code class="language-plaintext highlighter-rouge">
           head
          </code>
          : A dummy head node of the skiplist.
         </li>
         <li>
          <code class="language-plaintext highlighter-rouge">
           level
          </code>
          : The current number of levels that are in use in the skiplist.
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          <code class="language-plaintext highlighter-rouge">
           __init__(self)
          </code>
          :
         </strong>
         Initializes the skiplist with a dummy head node and sets the starting level to 0.
        </p>
       </li>
       <li>
        <strong>
         <code class="language-plaintext highlighter-rouge">
          search(self, target: int) -&gt; bool
         </code>
         :
        </strong>
        <ul>
         <li>
          Searches for a value in the skiplist.
         </li>
         <li>
          Iterates from the top level down to the bottom, moving right through the levels as long as the next nodeâs value is less than the target.
         </li>
         <li>
          Returns
          <code class="language-plaintext highlighter-rouge">
           True
          </code>
          if the target is found,
          <code class="language-plaintext highlighter-rouge">
           False
          </code>
          otherwise.
         </li>
        </ul>
       </li>
       <li>
        <strong>
         <code class="language-plaintext highlighter-rouge">
          add(self, num: int) -&gt; None
         </code>
         :
        </strong>
        <ul>
         <li>
          Inserts a value into the skiplist.
         </li>
         <li>
          Determines the level of the new node randomly using
          <code class="language-plaintext highlighter-rouge">
           random_level()
          </code>
          .
         </li>
         <li>
          Starting from the top level, inserts the new node at the appropriate positions in the levels up to its determined level.
         </li>
        </ul>
       </li>
       <li>
        <strong>
         <code class="language-plaintext highlighter-rouge">
          erase(self, num: int) -&gt; bool
         </code>
         :
        </strong>
        <ul>
         <li>
          Removes a value from the skiplist.
         </li>
         <li>
          Searches for the node from the top level down, updating links to bypass the node with the target value.
         </li>
         <li>
          Reduces the skiplist level if the top levels are unused after deletion.
         </li>
         <li>
          Returns
          <code class="language-plaintext highlighter-rouge">
           True
          </code>
          if the node was found and deleted,
          <code class="language-plaintext highlighter-rouge">
           False
          </code>
          if the node was not found.
         </li>
        </ul>
       </li>
       <li>
        <strong>
         <code class="language-plaintext highlighter-rouge">
          find_closest(self, curr: Node, level: int, target: int) -&gt; Node
         </code>
         :
        </strong>
        <ul>
         <li>
          A helper method to find the node closest to (and less than) the target at the given level.
         </li>
        </ul>
       </li>
       <li>
        <strong>
         <code class="language-plaintext highlighter-rouge">
          random_level(self) -&gt; int
         </code>
         :
        </strong>
        <ul>
         <li>
          Randomly determines the level for a new node based on the probability
          <code class="language-plaintext highlighter-rouge">
           p
          </code>
          .
         </li>
        </ul>
       </li>
      </ul>
      <h3 id="how-skiplist-works">
       How Skiplist Works:
      </h3>
      <ul>
       <li>
        Skiplist is a probabilistic data structure that uses multiple layers of sorted linked lists to ensure efficient operations.
       </li>
       <li>
        Higher levels of the skiplist act as âexpress lanesâ for traversing the list, allowing skipping over large portions of the list.
       </li>
       <li>
        The
        <code class="language-plaintext highlighter-rouge">
         random_level
        </code>
        method ensures that the list remains balanced probabilistically.
       </li>
       <li>
        Each operation (
        <code class="language-plaintext highlighter-rouge">
         search
        </code>
        ,
        <code class="language-plaintext highlighter-rouge">
         add
        </code>
        ,
        <code class="language-plaintext highlighter-rouge">
         erase
        </code>
        ) starts from the topmost level and works its way down, ensuring that operations are performed in logarithmic time on average.
       </li>
      </ul>
      <h3 id="complexity-analysis">
       Complexity Analysis:
      </h3>
      <ul>
       <li>
        <strong>
         Search, Insert, and Delete Operations:
        </strong>
        On average, all these operations have a time complexity of O(log n), where n is the number of elements in the skiplist.
       </li>
       <li>
        <strong>
         Space Complexity:
        </strong>
        O(n log n) on average, due to multiple levels storing references to nodes.
       </li>
      </ul>
      <ul class="uk-tab" data-uk-switcher="{connect:'#141deb4d-0178-4561-b2f7-2fa1e6e99c4d'}">
       <li class="uk-active">
        <a href="solution-1206.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-1206.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-1206.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-1206.html">
         Go
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="141deb4d-0178-4561-b2f7-2fa1e6e99c4d">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Skiplist</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MAX_LEVEL</span> <span class="o">=</span> <span class="mi">32</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="no">P</span> <span class="o">=</span> <span class="mf">0.25</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Random</span> <span class="no">RANDOM</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Node</span> <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(-</span><span class="mi">1</span><span class="o">,</span> <span class="no">MAX_LEVEL</span><span class="o">);</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Skiplist</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">findClosest</span><span class="o">(</span><span class="n">curr</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">val</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">lv</span> <span class="o">=</span> <span class="n">randomLevel</span><span class="o">();</span>
        <span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">lv</span><span class="o">);</span>
        <span class="n">level</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">level</span><span class="o">,</span> <span class="n">lv</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">findClosest</span><span class="o">(</span><span class="n">curr</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">lv</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">erase</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">ok</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">findClosest</span><span class="o">(</span><span class="n">curr</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">val</span> <span class="o">==</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">--</span><span class="n">level</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ok</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">findClosest</span><span class="o">(</span><span class="nc">Node</span> <span class="n">curr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">level</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">level</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">level</span><span class="o">].</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">level</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">curr</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">randomLevel</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">level</span> <span class="o">&lt;</span> <span class="no">MAX_LEVEL</span> <span class="o">&amp;&amp;</span> <span class="no">RANDOM</span><span class="o">.</span><span class="na">nextDouble</span><span class="o">()</span> <span class="o">&lt;</span> <span class="no">P</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">++</span><span class="n">level</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">level</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
        <span class="nc">Node</span><span class="o">[]</span> <span class="n">next</span><span class="o">;</span>

        <span class="nc">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">,</span> <span class="kt">int</span> <span class="n">level</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
            <span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">[</span><span class="n">level</span><span class="o">];</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Your Skiplist object will be instantiated and called as such:
 * Skiplist obj = new Skiplist();
 * boolean param_1 = obj.search(target);
 * obj.add(num);
 * boolean param_3 = obj.erase(num);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">next</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Skiplist</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">RAND_MAX</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">maxLevel</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>

    <span class="n">Skiplist</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxLevel</span><span class="p">);</span>
        <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">search</span><span class="p">(</span><span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">~</span><span class="n">i</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">findClosest</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">lv</span> <span class="o">=</span> <span class="n">randomLevel</span><span class="p">();</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
        <span class="n">level</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">~</span><span class="n">i</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">findClosest</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">lv</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">erase</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">~</span><span class="n">i</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">findClosest</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">--</span><span class="n">level</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">ok</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Node</span><span class="o">*</span> <span class="n">findClosest</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">curr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
        <span class="k">return</span> <span class="n">curr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">randomLevel</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">lv</span> <span class="o">&lt;</span> <span class="n">maxLevel</span> <span class="o">&amp;&amp;</span> <span class="n">rand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">)</span> <span class="o">++</span><span class="n">lv</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">lv</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**
 * Your Skiplist object will be instantiated and called as such:
 * Skiplist* obj = new Skiplist();
 * bool param_1 = obj-&gt;search(target);
 * obj-&gt;add(num);
 * bool param_3 = obj-&gt;erase(num);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s">'val'</span><span class="p">,</span> <span class="s">'next'</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">level</span>


<span class="k">class</span> <span class="nc">Skiplist</span><span class="p">:</span>
    <span class="n">max_level</span> <span class="o">=</span> <span class="mi">32</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mf">0.25</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">max_level</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find_closest</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
        <span class="n">level</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">random_level</span><span class="p">()</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find_closest</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">level</span><span class="p">:</span>
                <span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">erase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find_closest</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span> <span class="o">==</span> <span class="n">num</span><span class="p">:</span>
                <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nb">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">while</span> <span class="bp">self</span><span class="p">.</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">level</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">ok</span>

    <span class="k">def</span> <span class="nf">find_closest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="ow">and</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">[</span><span class="n">level</span><span class="p">].</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">curr</span>

    <span class="k">def</span> <span class="nf">random_level</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">max_level</span> <span class="ow">and</span> <span class="n">random</span><span class="p">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">p</span><span class="p">:</span>
            <span class="n">level</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">level</span>


<span class="c1"># Your Skiplist object will be instantiated and called as such:
# obj = Skiplist()
# param_1 = obj.search(target)
# obj.add(num)
# param_3 = obj.erase(num)
</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span> <span class="n">rand</span><span class="o">.</span><span class="n">Seed</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">UnixNano</span><span class="p">())</span> <span class="p">}</span>

<span class="k">const</span> <span class="p">(</span>
	<span class="n">maxLevel</span> <span class="o">=</span> <span class="m">16</span>
	<span class="n">p</span>        <span class="o">=</span> <span class="m">0.5</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">node</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">val</span>  <span class="kt">int</span>
	<span class="n">next</span> <span class="p">[]</span><span class="o">*</span><span class="n">node</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">newNode</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">level</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">node</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">node</span><span class="p">{</span>
		<span class="n">val</span><span class="o">:</span>  <span class="n">val</span><span class="p">,</span>
		<span class="n">next</span><span class="o">:</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">level</span><span class="p">),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Skiplist</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">head</span>  <span class="o">*</span><span class="n">node</span>
	<span class="n">level</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Constructor</span><span class="p">()</span> <span class="n">Skiplist</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">Skiplist</span><span class="p">{</span>
		<span class="n">head</span><span class="o">:</span>  <span class="n">newNode</span><span class="p">(</span><span class="o">-</span><span class="m">1</span><span class="p">,</span> <span class="n">maxLevel</span><span class="p">),</span>
		<span class="n">level</span><span class="o">:</span> <span class="m">1</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Skiplist</span><span class="p">)</span> <span class="n">Search</span><span class="p">(</span><span class="n">target</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="n">p</span> <span class="o">:=</span> <span class="n">this</span><span class="o">.</span><span class="n">head</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">this</span><span class="o">.</span><span class="n">level</span> <span class="o">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">findClosest</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">target</span> <span class="p">{</span>
			<span class="k">return</span> <span class="no">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="no">false</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Skiplist</span><span class="p">)</span> <span class="n">Add</span><span class="p">(</span><span class="n">num</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">level</span> <span class="o">:=</span> <span class="n">randomLevel</span><span class="p">()</span>
	<span class="k">if</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="n">this</span><span class="o">.</span><span class="n">level</span> <span class="p">{</span>
		<span class="n">this</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span>
	<span class="p">}</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">newNode</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>
	<span class="n">p</span> <span class="o">:=</span> <span class="n">this</span><span class="o">.</span><span class="n">head</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">this</span><span class="o">.</span><span class="n">level</span> <span class="o">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">findClosest</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">level</span> <span class="p">{</span>
			<span class="n">node</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
			<span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Skiplist</span><span class="p">)</span> <span class="n">Erase</span><span class="p">(</span><span class="n">num</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="n">ok</span> <span class="o">:=</span> <span class="no">false</span>
	<span class="n">p</span> <span class="o">:=</span> <span class="n">this</span><span class="o">.</span><span class="n">head</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">this</span><span class="o">.</span><span class="n">level</span> <span class="o">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">findClosest</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">num</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
			<span class="n">ok</span> <span class="o">=</span> <span class="no">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="n">this</span><span class="o">.</span><span class="n">level</span> <span class="o">&gt;</span> <span class="m">1</span> <span class="o">&amp;&amp;</span> <span class="n">this</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="n">this</span><span class="o">.</span><span class="n">level</span><span class="o">-</span><span class="m">1</span><span class="p">]</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">this</span><span class="o">.</span><span class="n">level</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ok</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">findClosest</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">target</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">node</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">!=</span> <span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">p</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">randomLevel</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">level</span> <span class="o">:=</span> <span class="m">1</span>
	<span class="k">for</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="n">maxLevel</span> <span class="o">&amp;&amp;</span> <span class="n">rand</span><span class="o">.</span><span class="n">Float64</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">p</span> <span class="p">{</span>
		<span class="n">level</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">level</span>
<span class="p">}</span>

<span class="c">/**
 * Your Skiplist object will be instantiated and called as such:
 * obj := Constructor();
 * param_1 := obj.Search(target);
 * obj.Add(num);
 * param_3 := obj.Erase(num);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-1206.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
