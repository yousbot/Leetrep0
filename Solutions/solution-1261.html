<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-1261.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-1261.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>1261 - Find Elements in a Contaminated Binary Tree</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 1261. Find Elements in a Contaminated Binary Tree Description Given a binary tree with the following rules: root.val == 0 If treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1 If treeNode.val == x and treeNode.right != null, then...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-1261.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-1261.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-1261.html" rel="stylesheet"/>
   <link href="solution-1261.html" rel="stylesheet"/>
   <link href="solution-1261.html" rel="stylesheet"/>
   <link href="solution-1261.html" rel="stylesheet"/>
   <link href="solution-1261.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="1261 - Find Elements in a Contaminated Binary Tree" property="og:title"/>
   <meta content="Leetcode 1261. Find Elements in a Contaminated Binary Tree Description Given a binary tree with the following rules: root.val == 0 If treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1 If treeNode.val == x and treeNode.right != null, then treeNode.right.val == 2 * x + 2 Now the binary tree is contaminated, which means all treeNode.val have been changed to -1. Implement the FindElements class: FindElements(TreeNode* root) Initializes the object with a contaminated binary tree and recovers it. bool find(int target) Returns true if the target value exists in the recovered binary tree. &amp;nbsp; Example 1: Input [&amp;quot;FindElements&amp;quot;,&amp;quot;find&amp;quot;,&amp;quot;find&amp;quot;] [[[-1,null,-1]],[1],[2]] Output [null,false,true] Explanation FindElements findElements = new FindElements([-1,null,-1]); findElements.find(1); // return False findElements.find(2); // return True Example 2: Input [&amp;quot;FindElements&amp;quot;,&amp;quot;find&amp;quot;,&amp;quot;find&amp;quot;,&amp;quot;find&amp;quot;] [[[-1,-1,-1,-1,-1]],[1],[3],[5]] Output [null,true,true,false] Explanation FindElements findElements = new FindElements([-1,-1,-1,-1,-1]); findElements.find(1); // return True findElements.find(3); // return True findElements.find(5); // return False Example 3: Input [&amp;quot;FindElements&amp;quot;,&amp;quot;find&amp;quot;,&amp;quot;find&amp;quot;,&amp;quot;find&amp;quot;,&amp;quot;find&amp;quot;] [[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]] Output [null,true,false,false,true] Explanation FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]); findElements.find(2); // return True findElements.find(3); // return False findElements.find(4); // return False findElements.find(5); // return True &amp;nbsp; Constraints: TreeNode.val == -1 The height of the binary tree is less than or equal to 20 The total number of nodes is between [1, 104] Total calls of find() is between [1, 104] 0 &amp;lt;= target &amp;lt;= 106 Solutions Solution 1: DFS + Hash Table First, we traverse the binary tree using DFS to restore the node values to their original values. Then, we store all node values in a hash table, so we can directly check whether the target value exists in the hash table when searching. In terms of time complexity, we need to traverse the binary tree during initialization, so the time complexity is $O(n)$. When searching, we only need to check whether the target value exists in the hash table, so the time complexity is $O(1)$. The space complexity is $O(n)$, where $n$ is the number of nodes in the binary tree. Java C++ Python Go TypeScript /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class FindElements { private Set&amp;lt;Integer&amp;gt; vis = new HashSet&amp;lt;&amp;gt;(); public FindElements(TreeNode root) { root.val = 0; dfs(root); } private void dfs(TreeNode root) { vis.add(root.val); if (root.left != null) { root.left.val = root.val * 2 + 1; dfs(root.left); } if (root.right != null) { root.right.val = root.val * 2 + 2; dfs(root.right); } } public boolean find(int target) { return vis.contains(target); } } /** * Your FindElements object will be instantiated and called as such: * FindElements obj = new FindElements(root); * boolean param_1 = obj.find(target); */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode()..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2019-05-14T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2019-05-14-1261-Find-Elements-in-a-Contaminated-Binary-Tree/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-1261.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="1261 - Find Elements in a Contaminated Binary Tree" property="twitter:title"/>
   <meta content="Leetcode 1261. Find Elements in a Contaminated Binary Tree Description Given a binary tree with the following rules: root.val == 0 If treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1 If treeNode.val == x and treeNode.right != null, then treeNode.right.val == 2 * x + 2 Now the binary tree is contaminated, which means all treeNode.val have been changed to -1. Implement the FindElements class: FindElements(TreeNode* root) Initializes the object with a contaminated binary tree and recovers it. bool find(int target) Returns true if the target value exists in the recovered binary tree. &amp;nbsp; Example 1: Input [&amp;quot;FindElements&amp;quot;,&amp;quot;find&amp;quot;,&amp;quot;find&amp;quot;] [[[-1,null,-1]],[1],[2]] Output [null,false,true] Explanation FindElements findElements = new FindElements([-1,null,-1]); findElements.find(1); // return False findElements.find(2); // return True Example 2: Input [&amp;quot;FindElements&amp;quot;,&amp;quot;find&amp;quot;,&amp;quot;find&amp;quot;,&amp;quot;find&amp;quot;] [[[-1,-1,-1,-1,-1]],[1],[3],[5]] Output [null,true,true,false] Explanation FindElements findElements = new FindElements([-1,-1,-1,-1,-1]); findElements.find(1); // return True findElements.find(3); // return True findElements.find(5); // return False Example 3: Input [&amp;quot;FindElements&amp;quot;,&amp;quot;find&amp;quot;,&amp;quot;find&amp;quot;,&amp;quot;find&amp;quot;,&amp;quot;find&amp;quot;] [[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]] Output [null,true,false,false,true] Explanation FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]); findElements.find(2); // return True findElements.find(3); // return False findElements.find(4); // return False findElements.find(5); // return True &amp;nbsp; Constraints: TreeNode.val == -1 The height of the binary tree is less than or equal to 20 The total number of nodes is between [1, 104] Total calls of find() is between [1, 104] 0 &amp;lt;= target &amp;lt;= 106 Solutions Solution 1: DFS + Hash Table First, we traverse the binary tree using DFS to restore the node values to their original values. Then, we store all node values in a hash table, so we can directly check whether the target value exists in the hash table when searching. In terms of time complexity, we need to traverse the binary tree during initialization, so the time complexity is $O(n)$. When searching, we only need to check whether the target value exists in the hash table, so the time complexity is $O(1)$. The space complexity is $O(n)$, where $n$ is the number of nodes in the binary tree. Java C++ Python Go TypeScript /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class FindElements { private Set&amp;lt;Integer&amp;gt; vis = new HashSet&amp;lt;&amp;gt;(); public FindElements(TreeNode root) { root.val = 0; dfs(root); } private void dfs(TreeNode root) { vis.add(root.val); if (root.left != null) { root.left.val = root.val * 2 + 1; dfs(root.left); } if (root.right != null) { root.right.val = root.val * 2 + 2; dfs(root.right); } } public boolean find(int target) { return vis.contains(target); } } /** * Your FindElements object will be instantiated and called as such: * FindElements obj = new FindElements(root); * boolean param_1 = obj.find(target); */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode()..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    1261 - Find Elements in a Contaminated Binary Tree | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="1261 - Find Elements in a Contaminated Binary Tree" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-1261.html" rel="canonical">
          <meta content="https://leetcode.ca/2019-05-14-1261-Find-Elements-in-a-Contaminated-Binary-Tree/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2019-05-14T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"1261 - Find Elements in a Contaminated Binary Tree","dateModified":"2019-05-14T00:00:00-07:00","datePublished":"2019-05-14T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2019-05-14-1261-Find-Elements-in-a-Contaminated-Binary-Tree/"},"url":"https://leetcode.ca/2019-05-14-1261-Find-Elements-in-a-Contaminated-Binary-Tree/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="1261-find-elements-in-a-contaminated-binary-tree">
       <a href="solution-1261.html">
        1261. Find Elements in a Contaminated Binary Tree
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given a binary tree with the following rules:
      </p>
      <ol>
       <li>
        <code>
         root.val == 0
        </code>
       </li>
       <li>
        If
        <code>
         treeNode.val == x
        </code>
        and
        <code>
         treeNode.left != null
        </code>
        , then
        <code>
         treeNode.left.val == 2 * x + 1
        </code>
       </li>
       <li>
        If
        <code>
         treeNode.val == x
        </code>
        and
        <code>
         treeNode.right != null
        </code>
        , then
        <code>
         treeNode.right.val == 2 * x + 2
        </code>
       </li>
      </ol>
      <p>
       Now the binary tree is contaminated, which means all
       <code>
        treeNode.val
       </code>
       have been changed to
       <code>
        -1
       </code>
       .
      </p>
      <p>
       Implement the
       <code>
        FindElements
       </code>
       class:
      </p>
      <ul>
       <li>
        <code>
         FindElements(TreeNode* root)
        </code>
        Initializes the object with a contaminated binary tree and recovers it.
       </li>
       <li>
        <code>
         bool find(int target)
        </code>
        Returns
        <code>
         true
        </code>
        if the
        <code>
         target
        </code>
        value exists in the recovered binary tree.
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1200-1299/1261.Find%20Elements%20in%20a%20Contaminated%20Binary%20Tree/images/untitled-diagram-4-1.jpg" style="width: 320px; height: 119px;"/>
      </p>
      <pre>
<strong>Input</strong>
["FindElements","find","find"]
[[[-1,null,-1]],[1],[2]]
<strong>Output</strong>
[null,false,true]
<strong>Explanation</strong>
FindElements findElements = new FindElements([-1,null,-1]); 
findElements.find(1); // return False 
findElements.find(2); // return True </pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1200-1299/1261.Find%20Elements%20in%20a%20Contaminated%20Binary%20Tree/images/untitled-diagram-4.jpg" style="width: 400px; height: 198px;"/>
      </p>
      <pre>
<strong>Input</strong>
["FindElements","find","find","find"]
[[[-1,-1,-1,-1,-1]],[1],[3],[5]]
<strong>Output</strong>
[null,true,true,false]
<strong>Explanation</strong>
FindElements findElements = new FindElements([-1,-1,-1,-1,-1]);
findElements.find(1); // return True
findElements.find(3); // return True
findElements.find(5); // return False</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1200-1299/1261.Find%20Elements%20in%20a%20Contaminated%20Binary%20Tree/images/untitled-diagram-4-1-1.jpg" style="width: 306px; height: 274px;"/>
      </p>
      <pre>
<strong>Input</strong>
["FindElements","find","find","find","find"]
[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]
<strong>Output</strong>
[null,true,false,false,true]
<strong>Explanation</strong>
FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);
findElements.find(2); // return True
findElements.find(3); // return False
findElements.find(4); // return False
findElements.find(5); // return True
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         TreeNode.val == -1
        </code>
       </li>
       <li>
        The height of the binary tree is less than or equal to
        <code>
         20
        </code>
       </li>
       <li>
        The total number of nodes is between
        <code>
         [1, 10
         <sup>
          4
         </sup>
         ]
        </code>
       </li>
       <li>
        Total calls of
        <code>
         find()
        </code>
        is between
        <code>
         [1, 10
         <sup>
          4
         </sup>
         ]
        </code>
       </li>
       <li>
        <code>
         0 &lt;= target &lt;= 10
         <sup>
          6
         </sup>
        </code>
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       <strong>
        Solution 1: DFS + Hash Table
       </strong>
      </p>
      <p>
       First, we traverse the binary tree using DFS to restore the node values to their original values. Then, we store all node values in a hash table, so we can directly check whether the target value exists in the hash table when searching.
      </p>
      <p>
       In terms of time complexity, we need to traverse the binary tree during initialization, so the time complexity is $O(n)$. When searching, we only need to check whether the target value exists in the hash table, so the time complexity is $O(1)$. The space complexity is $O(n)$, where $n$ is the number of nodes in the binary tree.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#87cec64b-9d97-4b0a-913c-6e829ebd849d'}">
       <li class="uk-active">
        <a href="solution-1261.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-1261.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-1261.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-1261.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-1261.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="87cec64b-9d97-4b0a-913c-6e829ebd849d">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">FindElements</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">vis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="nf">FindElements</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">vis</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">;</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">vis</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Your FindElements object will be instantiated and called as such:
 * FindElements obj = new FindElements(root);
 * boolean param_1 = obj.find(target);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">FindElements</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">FindElements</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vis</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">};</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">vis</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vis</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**
 * Your FindElements object will be instantiated and called as such:
 * FindElements* obj = new FindElements(root);
 * bool param_1 = obj-&gt;find(target);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">FindElements</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]):</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">vis</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

        <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">vis</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">vis</span>


<span class="c1"># Your FindElements object will be instantiated and called as such:
# obj = FindElements(root)
# param_1 = obj.find(target)
</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */</span>
<span class="k">type</span> <span class="n">FindElements</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">vis</span> <span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Constructor</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="n">FindElements</span> <span class="p">{</span>
	<span class="n">root</span><span class="o">.</span><span class="n">Val</span> <span class="o">=</span> <span class="m">0</span>
	<span class="n">vis</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span><span class="p">{}</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vis</span><span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="p">]</span> <span class="o">=</span> <span class="no">true</span>
		<span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">Left</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="o">.</span><span class="n">Val</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="o">*</span><span class="m">2</span> <span class="o">+</span> <span class="m">1</span>
			<span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">Right</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="o">.</span><span class="n">Val</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="o">*</span><span class="m">2</span> <span class="o">+</span> <span class="m">2</span>
			<span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">FindElements</span><span class="p">{</span><span class="n">vis</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">FindElements</span><span class="p">)</span> <span class="n">Find</span><span class="p">(</span><span class="n">target</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">vis</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
<span class="p">}</span>

<span class="c">/**
 * Your FindElements object will be instantiated and called as such:
 * obj := Constructor(root);
 * param_1 := obj.Find(target);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>

<span class="kd">class</span> <span class="nx">FindElements</span> <span class="p">{</span>
    <span class="k">private</span> <span class="nx">s</span><span class="p">:</span> <span class="nb">Set</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">root</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="nx">TreeNode</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">s</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">val</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">val</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">val</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
                <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">};</span>
        <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">find</span><span class="p">(</span><span class="nx">target</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="nx">boolean</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">s</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
 * Your FindElements object will be instantiated and called as such:
 * var obj = new FindElements(root)
 * var param_1 = obj.find(target)
 */</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-1261.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
