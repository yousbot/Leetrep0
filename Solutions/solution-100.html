<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-100.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-100.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>100 - Same Tree</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 100. Same Tree Description Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value....">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-100.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-100.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-100.html" rel="stylesheet"/>
   <link href="solution-100.html" rel="stylesheet"/>
   <link href="solution-100.html" rel="stylesheet"/>
   <link href="solution-100.html" rel="stylesheet"/>
   <link href="solution-100.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="100 - Same Tree" property="og:title"/>
   <meta content="Leetcode 100. Same Tree Description Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value. &amp;nbsp; Example 1: Input: p = [1,2,3], q = [1,2,3] Output: true Example 2: Input: p = [1,2], q = [1,null,2] Output: false Example 3: Input: p = [1,2,1], q = [1,1,2] Output: false &amp;nbsp; Constraints: The number of nodes in both trees is in the range [0, 100]. -104 &amp;lt;= Node.val &amp;lt;= 104 Solutions Solution 1: DFS We can use the DFS recursive method to solve this problem. First, determine whether the root nodes of the two binary trees are the same. If both root nodes are null, then the two binary trees are the same. If only one of the root nodes is null, then the two binary trees are definitely different. If both root nodes are not null, then determine whether their values are the same. If they are not the same, then the two binary trees are definitely different. If they are the same, then determine whether the left subtrees of the two binary trees are the same and whether the right subtrees are the same. The two binary trees are the same only when all the above conditions are met. The time complexity is $O(\min(m, n))$, and the space complexity is $O(\min(m, n))$. Here, $m$ and $n$ are the number of nodes in the two binary trees, respectively. The space complexity mainly depends on the number of layers of recursive calls, which will not exceed the number of nodes in the smaller binary tree. Solution 2: BFS We can also use the BFS iterative method to solve this problem. First, add the root nodes of the two binary trees to two queues. Each time, take out one node from each of the two queues and perform the following comparison operations. If the values of the two nodes are not the same, then the structures of the two binary trees are definitely different. If the values of the two nodes are the same, then determine whether the child nodes of the two nodes are null. If only the left child node of one node is null, then the structures of the two binary trees are definitely different. If only the right child node of one node is null, then the structures of the two binary trees are definitely different. If the structures of the left and right child nodes are the same, then add the left and right child nodes of the two nodes to the two queues respectively. For the next iteration, take out one node from each of the two queues for comparison. When both queues are empty at the same time, it means that we have compared all the nodes, and the structures of the two binary trees are completely the same. The..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-03-09T00:00:00-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-03-09-100-Same-Tree/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-100.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="100 - Same Tree" property="twitter:title"/>
   <meta content="Leetcode 100. Same Tree Description Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value. &amp;nbsp; Example 1: Input: p = [1,2,3], q = [1,2,3] Output: true Example 2: Input: p = [1,2], q = [1,null,2] Output: false Example 3: Input: p = [1,2,1], q = [1,1,2] Output: false &amp;nbsp; Constraints: The number of nodes in both trees is in the range [0, 100]. -104 &amp;lt;= Node.val &amp;lt;= 104 Solutions Solution 1: DFS We can use the DFS recursive method to solve this problem. First, determine whether the root nodes of the two binary trees are the same. If both root nodes are null, then the two binary trees are the same. If only one of the root nodes is null, then the two binary trees are definitely different. If both root nodes are not null, then determine whether their values are the same. If they are not the same, then the two binary trees are definitely different. If they are the same, then determine whether the left subtrees of the two binary trees are the same and whether the right subtrees are the same. The two binary trees are the same only when all the above conditions are met. The time complexity is $O(\min(m, n))$, and the space complexity is $O(\min(m, n))$. Here, $m$ and $n$ are the number of nodes in the two binary trees, respectively. The space complexity mainly depends on the number of layers of recursive calls, which will not exceed the number of nodes in the smaller binary tree. Solution 2: BFS We can also use the BFS iterative method to solve this problem. First, add the root nodes of the two binary trees to two queues. Each time, take out one node from each of the two queues and perform the following comparison operations. If the values of the two nodes are not the same, then the structures of the two binary trees are definitely different. If the values of the two nodes are the same, then determine whether the child nodes of the two nodes are null. If only the left child node of one node is null, then the structures of the two binary trees are definitely different. If only the right child node of one node is null, then the structures of the two binary trees are definitely different. If the structures of the left and right child nodes are the same, then add the left and right child nodes of the two nodes to the two queues respectively. For the next iteration, take out one node from each of the two queues for comparison. When both queues are empty at the same time, it means that we have compared all the nodes, and the structures of the two binary trees are completely the same. The..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    100 - Same Tree | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="100 - Same Tree" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-100.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-03-09-100-Same-Tree/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-03-09T00:00:00-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"100 - Same Tree","dateModified":"2016-03-09T00:00:00-08:00","datePublished":"2016-03-09T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-03-09-100-Same-Tree/"},"url":"https://leetcode.ca/2016-03-09-100-Same-Tree/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="100-same-tree">
       <a href="solution-100.html">
        100. Same Tree
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given the roots of two binary trees
       <code>
        p
       </code>
       and
       <code>
        q
       </code>
       , write a function to check if they are the same or not.
      </p>
      <p>
       Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0100.Same%20Tree/images/ex1.jpg" style="width: 622px; height: 182px;"/>
      </p>
      <pre>
<strong>Input:</strong> p = [1,2,3], q = [1,2,3]
<strong>Output:</strong> true
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0100.Same%20Tree/images/ex2.jpg" style="width: 382px; height: 182px;"/>
      </p>
      <pre>
<strong>Input:</strong> p = [1,2], q = [1,null,2]
<strong>Output:</strong> false
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0100.Same%20Tree/images/ex3.jpg" style="width: 622px; height: 182px;"/>
      </p>
      <pre>
<strong>Input:</strong> p = [1,2,1], q = [1,1,2]
<strong>Output:</strong> false
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in both trees is in the range
        <code>
         [0, 100]
        </code>
        .
       </li>
       <li>
        <code>
         -10
         <sup>
          4
         </sup>
         &lt;= Node.val &lt;= 10
         <sup>
          4
         </sup>
        </code>
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       <strong>
        Solution 1: DFS
       </strong>
      </p>
      <p>
       We can use the DFS recursive method to solve this problem.
      </p>
      <p>
       First, determine whether the root nodes of the two binary trees are the same. If both root nodes are null, then the two binary trees are the same. If only one of the root nodes is null, then the two binary trees are definitely different. If both root nodes are not null, then determine whether their values are the same. If they are not the same, then the two binary trees are definitely different. If they are the same, then determine whether the left subtrees of the two binary trees are the same and whether the right subtrees are the same. The two binary trees are the same only when all the above conditions are met.
      </p>
      <p>
       The time complexity is $O(\min(m, n))$, and the space complexity is $O(\min(m, n))$. Here, $m$ and $n$ are the number of nodes in the two binary trees, respectively. The space complexity mainly depends on the number of layers of recursive calls, which will not exceed the number of nodes in the smaller binary tree.
      </p>
      <p>
       <strong>
        Solution 2: BFS
       </strong>
      </p>
      <p>
       We can also use the BFS iterative method to solve this problem.
      </p>
      <p>
       First, add the root nodes of the two binary trees to two queues. Each time, take out one node from each of the two queues and perform the following comparison operations. If the values of the two nodes are not the same, then the structures of the two binary trees are definitely different. If the values of the two nodes are the same, then determine whether the child nodes of the two nodes are null. If only the left child node of one node is null, then the structures of the two binary trees are definitely different. If only the right child node of one node is null, then the structures of the two binary trees are definitely different. If the structures of the left and right child nodes are the same, then add the left and right child nodes of the two nodes to the two queues respectively. For the next iteration, take out one node from each of the two queues for comparison. When both queues are empty at the same time, it means that we have compared all the nodes, and the structures of the two binary trees are completely the same.
      </p>
      <p>
       The time complexity is $O(\min(m, n))$, and the space complexity is $O(\min(m, n))$. Here, $m$ and $n$ are the number of nodes in the two binary trees, respectively. The space complexity mainly depends on the number of elements in the queue, which will not exceed the number of nodes in the smaller binary tree.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#e19eff0a-97b1-4835-a6de-99ab45280c46'}">
       <li class="uk-active">
        <a href="solution-100.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-100.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-100.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-100.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-100.html">
         TypeScript
        </a>
       </li>
       <li>
        <a href="solution-100.html">
         Javascript
        </a>
       </li>
       <li>
        <a href="solution-100.html">
         Php
        </a>
       </li>
       <li>
        <a href="solution-100.html">
         RenderScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="e19eff0a-97b1-4835-a6de-99ab45280c46">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Same_Tree</span> <span class="o">{</span>

    <span class="cm">/**
     * Definition for a binary tree node.
     * public class TreeNode {
     * int val;
     * TreeNode left;
     * TreeNode right;
     * TreeNode(int x) { val = x; }
     * }
     */</span>

    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution_iteration</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSameTree</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">p</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">q</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">q</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">sk1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;();</span>
            <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">sk2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;();</span>

            <span class="n">sk1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
            <span class="n">sk2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>

            <span class="k">while</span> <span class="o">(!</span><span class="n">sk1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sk2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">TreeNode</span> <span class="n">current1</span> <span class="o">=</span> <span class="n">sk1</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="nc">TreeNode</span> <span class="n">current2</span> <span class="o">=</span> <span class="n">sk2</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">current1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">current2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">continue</span><span class="o">;</span> <span class="c1">// @note: missed both null check</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">current1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">current2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">current1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">current2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">current1</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">current2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="n">sk1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">current1</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                <span class="n">sk2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">current2</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>

                <span class="n">sk1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">current1</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                <span class="n">sk2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">current2</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>

            <span class="o">}</span>

            <span class="c1">// final check</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">sk1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">sk2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

        <span class="o">}</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution_recursion</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSameTree</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">p</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">q</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">q</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">q</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="nf">isSameTree</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">q</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isSameTree</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">q</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="c1">//////</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSameTree</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">p</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">q</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">q</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">q</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">isSameTree</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">q</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isSameTree</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">q</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">q</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span> <span class="o">||</span> <span class="o">!</span><span class="n">q</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="s">"""
    :type p: TreeNode
    :type q: TreeNode
    :rtype: bool
    """</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">p</span> <span class="o">==</span> <span class="n">q</span> <span class="c1"># covers: p=none and q!=none, q=none and p!=none, both none
</span>    <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">q</span><span class="p">.</span><span class="n">val</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>


<span class="c1"># iteration
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">q</span> <span class="ow">is</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">q</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p</span> <span class="ow">is</span> <span class="bp">None</span>

        <span class="n">stack1</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
        <span class="n">stack2</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="p">]</span>

        <span class="k">while</span> <span class="n">stack1</span> <span class="ow">and</span> <span class="n">stack2</span><span class="p">:</span>
            <span class="n">current1</span> <span class="o">=</span> <span class="n">stack1</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">current2</span> <span class="o">=</span> <span class="n">stack2</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">current1</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">current2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">current1</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">current2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">elif</span> <span class="n">current1</span><span class="p">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">current2</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="n">stack1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">current1</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">stack2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">current2</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>

            <span class="n">stack1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">current1</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">stack2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">current2</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

        <span class="k">return</span> <span class="ow">not</span> <span class="n">stack1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stack2</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */</span>
<span class="k">func</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">,</span> <span class="n">q</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="n">q</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">true</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="no">nil</span> <span class="o">||</span> <span class="n">q</span> <span class="o">==</span> <span class="no">nil</span> <span class="o">||</span> <span class="n">p</span><span class="o">.</span><span class="n">Val</span> <span class="o">!=</span> <span class="n">q</span><span class="o">.</span><span class="n">Val</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">Left</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">Right</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>

<span class="kd">function</span> <span class="nx">isSameTree</span><span class="p">(</span><span class="nx">p</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">q</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="nx">boolean</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">q</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="nx">q</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="nx">p</span><span class="p">.</span><span class="nx">val</span> <span class="o">!==</span> <span class="nx">q</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">isSameTree</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isSameTree</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-js highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="cm">/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */</span>
<span class="kd">var</span> <span class="nx">isSameTree</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">p</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">q</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">p</span> <span class="o">&amp;&amp;</span> <span class="nx">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">val</span> <span class="o">===</span> <span class="nx">q</span><span class="p">.</span><span class="nx">val</span> <span class="o">&amp;&amp;</span> <span class="nx">isSameTree</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isSameTree</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">};</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-php highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cd">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     public $val = null;
 *     public $left = null;
 *     public $right = null;
 *     function __construct($val = 0, $left = null, $right = null) {
 *         $this-&gt;val = $val;
 *         $this-&gt;left = $left;
 *         $this-&gt;right = $right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="cd">/**
     * @param TreeNode $p
     * @param TreeNode $q
     * @return Boolean
     */</span>
    <span class="k">function</span> <span class="n">isSameTree</span><span class="p">(</span><span class="nv">$p</span><span class="p">,</span> <span class="nv">$q</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nv">$q</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="nv">$q</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="nv">$q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">isSameTree</span><span class="p">(</span><span class="nv">$p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="nv">$q</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">isSameTree</span><span class="p">(</span><span class="nv">$p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="nv">$q</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-rs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1">// Definition for a binary tree node.</span>
<span class="c1">// #[derive(Debug, PartialEq, Eq)]</span>
<span class="c1">// pub struct TreeNode {</span>
<span class="c1">//   pub val: i32,</span>
<span class="c1">//   pub left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span>
<span class="c1">//   pub right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span>
<span class="c1">// }</span>
<span class="c1">//</span>
<span class="c1">// impl TreeNode {</span>
<span class="c1">//   #[inline]</span>
<span class="c1">//   pub fn new(val: i32) -&gt; Self {</span>
<span class="c1">//     TreeNode {</span>
<span class="c1">//       val,</span>
<span class="c1">//       left: None,</span>
<span class="c1">//       right: None</span>
<span class="c1">//     }</span>
<span class="c1">//   }</span>
<span class="c1">// }</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Solution</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">||</span> <span class="n">q</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">q</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">();</span>
        <span class="n">r1</span><span class="py">.val</span> <span class="o">==</span> <span class="n">r2</span><span class="py">.val</span> <span class="o">&amp;&amp;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">dfs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r1</span><span class="py">.left</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r2</span><span class="py">.left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">dfs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r1</span><span class="py">.right</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r2</span><span class="py">.right</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">is_same_tree</span><span class="p">(</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;&gt;</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">::</span><span class="nf">dfs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-100.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
