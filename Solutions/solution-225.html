<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-225.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-225.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>225 - Implement Stack using Queues</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 225. Implement Stack using Queues Description Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). Implement the MyStack class: void push(int x) Pushes element x to the top...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-225.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-225.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-225.html" rel="stylesheet"/>
   <link href="solution-225.html" rel="stylesheet"/>
   <link href="solution-225.html" rel="stylesheet"/>
   <link href="solution-225.html" rel="stylesheet"/>
   <link href="solution-225.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="225 - Implement Stack using Queues" property="og:title"/>
   <meta content="Leetcode 225. Implement Stack using Queues Description Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). Implement the MyStack class: void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack. boolean empty() Returns true if the stack is empty, false otherwise. Notes: You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue&amp;#39;s standard operations. &amp;nbsp; Example 1: Input [&amp;quot;MyStack&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;top&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;empty&amp;quot;] [[], [1], [2], [], [], []] Output [null, null, null, 2, 2, false] Explanation MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // return 2 myStack.pop(); // return 2 myStack.empty(); // return False &amp;nbsp; Constraints: 1 &amp;lt;= x &amp;lt;= 9 At most 100 calls will be made to push, pop, top, and empty. All the calls to pop and top are valid. &amp;nbsp; Follow-up: Can you implement the stack using only one queue? Solutions Solution 1: Two Queues We use two queues $q_1$ and $q_2$, where $q_1$ is used to store the elements in the stack, and $q_2$ is used to assist in implementing the stack operations. push operation: Push the element into $q_2$, then pop the elements in $q_1$ one by one and push them into $q_2$, finally swap the references of $q_1$ and $q_2$. The time complexity is $O(n)$. pop operation: Directly pop the front element of $q_1$. The time complexity is $O(1)$. top operation: Directly return the front element of $q_1$. The time complexity is $O(1)$. empty operation: Check whether $q_1$ is empty. The time complexity is $O(1)$. The space complexity is $O(n)$, where $n$ is the number of elements in the stack. Java C++ Python Go TypeScript RenderScript import java.util.Deque; class MyStack { private Deque&amp;lt;Integer&amp;gt; q1 = new ArrayDeque&amp;lt;&amp;gt;(); private Deque&amp;lt;Integer&amp;gt; q2 = new ArrayDeque&amp;lt;&amp;gt;(); public MyStack() { } public void push(int x) { q2.offer(x); while (!q1.isEmpty()) { q2.offer(q1.poll()); } Deque&amp;lt;Integer&amp;gt; q = q1; q1 = q2; q2 = q; } public int pop() { return q1.poll(); } public int top() { return q1.peek(); } public boolean empty() { return q1.isEmpty(); } } /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */ class MyStack { public: MyStack() { } void push(int x) { q2.push(x); while (!q1.empty()) { q2.push(q1.front()); q1.pop(); } swap(q1, q2); } int pop() { int x = q1.front(); q1.pop(); return x; } int top() { return q1.front(); }..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-07-12T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-07-12-225-Implement-Stack-using-Queues/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-225.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="225 - Implement Stack using Queues" property="twitter:title"/>
   <meta content="Leetcode 225. Implement Stack using Queues Description Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). Implement the MyStack class: void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack. boolean empty() Returns true if the stack is empty, false otherwise. Notes: You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue&amp;#39;s standard operations. &amp;nbsp; Example 1: Input [&amp;quot;MyStack&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;top&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;empty&amp;quot;] [[], [1], [2], [], [], []] Output [null, null, null, 2, 2, false] Explanation MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // return 2 myStack.pop(); // return 2 myStack.empty(); // return False &amp;nbsp; Constraints: 1 &amp;lt;= x &amp;lt;= 9 At most 100 calls will be made to push, pop, top, and empty. All the calls to pop and top are valid. &amp;nbsp; Follow-up: Can you implement the stack using only one queue? Solutions Solution 1: Two Queues We use two queues $q_1$ and $q_2$, where $q_1$ is used to store the elements in the stack, and $q_2$ is used to assist in implementing the stack operations. push operation: Push the element into $q_2$, then pop the elements in $q_1$ one by one and push them into $q_2$, finally swap the references of $q_1$ and $q_2$. The time complexity is $O(n)$. pop operation: Directly pop the front element of $q_1$. The time complexity is $O(1)$. top operation: Directly return the front element of $q_1$. The time complexity is $O(1)$. empty operation: Check whether $q_1$ is empty. The time complexity is $O(1)$. The space complexity is $O(n)$, where $n$ is the number of elements in the stack. Java C++ Python Go TypeScript RenderScript import java.util.Deque; class MyStack { private Deque&amp;lt;Integer&amp;gt; q1 = new ArrayDeque&amp;lt;&amp;gt;(); private Deque&amp;lt;Integer&amp;gt; q2 = new ArrayDeque&amp;lt;&amp;gt;(); public MyStack() { } public void push(int x) { q2.offer(x); while (!q1.isEmpty()) { q2.offer(q1.poll()); } Deque&amp;lt;Integer&amp;gt; q = q1; q1 = q2; q2 = q; } public int pop() { return q1.poll(); } public int top() { return q1.peek(); } public boolean empty() { return q1.isEmpty(); } } /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */ class MyStack { public: MyStack() { } void push(int x) { q2.push(x); while (!q1.empty()) { q2.push(q1.front()); q1.pop(); } swap(q1, q2); } int pop() { int x = q1.front(); q1.pop(); return x; } int top() { return q1.front(); }..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    225 - Implement Stack using Queues | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="225 - Implement Stack using Queues" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-225.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-07-12-225-Implement-Stack-using-Queues/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-07-12T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"225 - Implement Stack using Queues","dateModified":"2016-07-12T00:00:00-07:00","datePublished":"2016-07-12T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-07-12-225-Implement-Stack-using-Queues/"},"url":"https://leetcode.ca/2016-07-12-225-Implement-Stack-using-Queues/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="225-implement-stack-using-queues">
       <a href="solution-225.html">
        225. Implement Stack using Queues
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (
       <code>
        push
       </code>
       ,
       <code>
        top
       </code>
       ,
       <code>
        pop
       </code>
       , and
       <code>
        empty
       </code>
       ).
      </p>
      <p>
       Implement the
       <code>
        MyStack
       </code>
       class:
      </p>
      <ul>
       <li>
        <code>
         void push(int x)
        </code>
        Pushes element x to the top of the stack.
       </li>
       <li>
        <code>
         int pop()
        </code>
        Removes the element on the top of the stack and returns it.
       </li>
       <li>
        <code>
         int top()
        </code>
        Returns the element on the top of the stack.
       </li>
       <li>
        <code>
         boolean empty()
        </code>
        Returns
        <code>
         true
        </code>
        if the stack is empty,
        <code>
         false
        </code>
        otherwise.
       </li>
      </ul>
      <p>
       <b>
        Notes:
       </b>
      </p>
      <ul>
       <li>
        You must use
        <strong>
         only
        </strong>
        standard operations of a queue, which means that only
        <code>
         push to back
        </code>
        ,
        <code>
         peek/pop from front
        </code>
        ,
        <code>
         size
        </code>
        and
        <code>
         is empty
        </code>
        operations are valid.
       </li>
       <li>
        Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input</strong>
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
<strong>Output</strong>
[null, null, null, 2, 2, false]

<strong>Explanation</strong>
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // return 2
myStack.pop(); // return 2
myStack.empty(); // return False
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= x &lt;= 9
        </code>
       </li>
       <li>
        At most
        <code>
         100
        </code>
        calls will be made to
        <code>
         push
        </code>
        ,
        <code>
         pop
        </code>
        ,
        <code>
         top
        </code>
        , and
        <code>
         empty
        </code>
        .
       </li>
       <li>
        All the calls to
        <code>
         pop
        </code>
        and
        <code>
         top
        </code>
        are valid.
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong>
        Follow-up:
       </strong>
       Can you implement the stack using only one queue?
      </p>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       <strong>
        Solution 1: Two Queues
       </strong>
      </p>
      <p>
       We use two queues $q_1$ and $q_2$, where $q_1$ is used to store the elements in the stack, and $q_2$ is used to assist in implementing the stack operations.
      </p>
      <ul>
       <li>
        <code class="language-plaintext highlighter-rouge">
         push
        </code>
        operation: Push the element into $q_2$, then pop the elements in $q_1$ one by one and push them into $q_2$, finally swap the references of $q_1$ and $q_2$. The time complexity is $O(n)$.
       </li>
       <li>
        <code class="language-plaintext highlighter-rouge">
         pop
        </code>
        operation: Directly pop the front element of $q_1$. The time complexity is $O(1)$.
       </li>
       <li>
        <code class="language-plaintext highlighter-rouge">
         top
        </code>
        operation: Directly return the front element of $q_1$. The time complexity is $O(1)$.
       </li>
       <li>
        <code class="language-plaintext highlighter-rouge">
         empty
        </code>
        operation: Check whether $q_1$ is empty. The time complexity is $O(1)$.
       </li>
      </ul>
      <p>
       The space complexity is $O(n)$, where $n$ is the number of elements in the stack.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#d9fe60e1-ea54-486b-94c3-c1a185e86d69'}">
       <li class="uk-active">
        <a href="solution-225.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-225.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-225.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-225.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-225.html">
         TypeScript
        </a>
       </li>
       <li>
        <a href="solution-225.html">
         RenderScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="d9fe60e1-ea54-486b-94c3-c1a185e86d69">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Deque</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">MyStack</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
    <span class="kd">private</span> <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="nf">MyStack</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">q2</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">q1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">q2</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">q1</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q1</span><span class="o">;</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="n">q2</span><span class="o">;</span>
        <span class="n">q2</span> <span class="o">=</span> <span class="n">q</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">q1</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">top</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">q1</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">empty</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">q1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">MyStack</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MyStack</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">q2</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q1</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">q2</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">q1</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
            <span class="n">q1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">q1</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">q1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">top</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">q1</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">q1</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q1</span><span class="p">;</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q2</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj-&gt;push(x);
 * int param_2 = obj-&gt;pop();
 * int param_3 = obj-&gt;top();
 * bool param_4 = obj-&gt;empty();
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># one queue
</span>
<span class="s">'''
push(1), [1]
push(2), [1,2] =&gt; [2,1]
push(3), [2,1,3] =&gt; [1,3,2] =&gt; [3,2,1]
push(4), [3,2,1,4] =&gt; switch 3 time to get [4,3,2,1]
push(5), [4,3,2,1,5] =&gt; switch 4 time to get [5,4,3,2,1]
'''</span>
<span class="k">class</span> <span class="nc">Stack</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_queue</span> <span class="o">=</span> <span class="n">collections</span><span class="p">.</span><span class="n">deque</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_queue</span>
        <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">())</span>
        
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_queue</span><span class="p">)</span>

<span class="c1"># Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()
</span>
<span class="c1">############
</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="c1"># two queues
</span><span class="k">class</span> <span class="nc">MyStack</span><span class="p">:</span>

	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">q1</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">q2</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

	<span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">q1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
		<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">q1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
			<span class="bp">self</span><span class="p">.</span><span class="n">q2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">q1</span><span class="p">.</span><span class="n">popleft</span><span class="p">())</span>

		<span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">q1</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">q1</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">q2</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">q2</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">q1</span>
		<span class="k">return</span> <span class="n">val</span>

	<span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
		<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">q1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
			<span class="bp">self</span><span class="p">.</span><span class="n">q2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">q1</span><span class="p">.</span><span class="n">popleft</span><span class="p">())</span>

        <span class="c1"># tried to re-use while part, but seems not achievable, since val is retrieved in-between 
</span>		<span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">q1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">q2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">q1</span><span class="p">.</span><span class="n">popleft</span><span class="p">())</span>  <span class="c1"># note: add back to q2, so q1 will always be empty
</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">q1</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">q2</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">q2</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">q1</span>
		<span class="k">return</span> <span class="n">val</span>


	<span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
		<span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">q1</span>

<span class="c1"># Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()
</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">type</span> <span class="n">MyStack</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">q1</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="n">q2</span> <span class="p">[]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Constructor</span><span class="p">()</span> <span class="n">MyStack</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">MyStack</span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">MyStack</span><span class="p">)</span> <span class="n">Push</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">this</span><span class="o">.</span><span class="n">q2</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">q2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">q1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">this</span><span class="o">.</span><span class="n">q2</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">q2</span><span class="p">,</span> <span class="n">this</span><span class="o">.</span><span class="n">q1</span><span class="p">[</span><span class="m">0</span><span class="p">])</span>
		<span class="n">this</span><span class="o">.</span><span class="n">q1</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">q1</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="n">this</span><span class="o">.</span><span class="n">q1</span><span class="p">,</span> <span class="n">this</span><span class="o">.</span><span class="n">q2</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">q2</span><span class="p">,</span> <span class="n">this</span><span class="o">.</span><span class="n">q1</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">MyStack</span><span class="p">)</span> <span class="n">Pop</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">x</span> <span class="o">:=</span> <span class="n">this</span><span class="o">.</span><span class="n">q1</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
	<span class="n">this</span><span class="o">.</span><span class="n">q1</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">q1</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">x</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">MyStack</span><span class="p">)</span> <span class="n">Top</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">q1</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">MyStack</span><span class="p">)</span> <span class="n">Empty</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">q1</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span>
<span class="p">}</span>

<span class="c">/**
 * Your MyStack object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(x);
 * param_2 := obj.Pop();
 * param_3 := obj.Top();
 * param_4 := obj.Empty();
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyStack</span> <span class="p">{</span>
    <span class="nl">q1</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="nl">q2</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="kd">constructor</span><span class="p">()</span> <span class="p">{}</span>

    <span class="nx">push</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">q2</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">q1</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">q2</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">q1</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span><span class="o">!</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">q1</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">q2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">q2</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">q1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="nx">pop</span><span class="p">():</span> <span class="kr">number</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">q1</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span><span class="o">!</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">top</span><span class="p">():</span> <span class="kr">number</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">q1</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="nx">empty</span><span class="p">():</span> <span class="nx">boolean</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">q1</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-rs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">VecDeque</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">MyStack</span> <span class="p">{</span>
    <span class="cd">/// There could only be two status at all time</span>
    <span class="cd">/// 1. One contains N elements, the other is empty</span>
    <span class="cd">/// 2. One contains N - 1 elements, the other contains exactly 1 element</span>
    <span class="n">q_1</span><span class="p">:</span> <span class="n">VecDeque</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">q_2</span><span class="p">:</span> <span class="n">VecDeque</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="c1">// Either 1 or 2, originally begins from 1</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">MyStack</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">q_1</span><span class="p">:</span> <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
            <span class="n">q_2</span><span class="p">:</span> <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
            <span class="n">index</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">move_data</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Always move from q1 to q2</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.q_2</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">while</span> <span class="o">!</span><span class="k">self</span><span class="py">.q_1</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.q_2</span><span class="nf">.push_back</span><span class="p">(</span><span class="k">self</span><span class="py">.q_1</span><span class="nf">.pop_front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">self</span><span class="py">.q_1</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.q_1</span> <span class="o">=</span> <span class="k">self</span><span class="py">.q_2</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.q_2</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.q_2</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.move_data</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">pop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.q_1</span><span class="nf">.pop_front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">top</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="o">*</span><span class="k">self</span><span class="py">.q_1</span><span class="nf">.front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">empty</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.q_1</span><span class="nf">.is_empty</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-225.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
