<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-1059.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-1059.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>1059 - All Paths from Source Lead to Destination</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 1059. All Paths from Source Lead to Destination Description Given the edges of a directed graph where edges[i] = [ai, bi] indicates there is an edge between nodes ai and bi, and two nodes source and destination of this graph, determine whether or not all...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-1059.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-1059.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-1059.html" rel="stylesheet"/>
   <link href="solution-1059.html" rel="stylesheet"/>
   <link href="solution-1059.html" rel="stylesheet"/>
   <link href="solution-1059.html" rel="stylesheet"/>
   <link href="solution-1059.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="1059 - All Paths from Source Lead to Destination" property="og:title"/>
   <meta content="Leetcode 1059. All Paths from Source Lead to Destination Description Given the edges of a directed graph where edges[i] = [ai, bi] indicates there is an edge between nodes ai and bi, and two nodes source and destination of this graph, determine whether or not all paths starting from source eventually, end at destination, that is: At least one path exists from the source node to the destination node If a path exists from the source node to a node with no outgoing edges, then that node is equal to destination. The number of possible paths from source to destination is a finite number. Return true if and only if all roads from source lead to destination. &amp;nbsp; Example 1: Input: n = 3, edges = [[0,1],[0,2]], source = 0, destination = 2 Output: false Explanation: It is possible to reach and get stuck on both node 1 and node 2. Example 2: Input: n = 4, edges = [[0,1],[0,3],[1,2],[2,1]], source = 0, destination = 3 Output: false Explanation: We have two possibilities: to end at node 3, or to loop over node 1 and node 2 indefinitely. Example 3: Input: n = 4, edges = [[0,1],[0,2],[1,3],[2,3]], source = 0, destination = 3 Output: true &amp;nbsp; Constraints: 1 &amp;lt;= n &amp;lt;= 104 0 &amp;lt;= edges.length &amp;lt;= 104 edges.length == 2 0 &amp;lt;= ai, bi &amp;lt;= n - 1 0 &amp;lt;= source &amp;lt;= n - 1 0 &amp;lt;= destination &amp;lt;= n - 1 The given graph may have self-loops and parallel edges. Solutions There are 2 cases it should return false. case 1: it encounters a node that has no outgoing edges, but it is not destination. case 2: it has cycle. Otherwise, it returns true. Could iterate graph with BFS. When indegree of a node becomes negative, then ther is cycle. Time Complexity: O(n+e) e = edges.length. Space: O(n+e). Java C++ Python Go class Solution { private List&amp;lt;Integer&amp;gt;[] g; private int[] f; private boolean[] vis; private int k; public boolean leadsToDestination(int n, int[][] edges, int source, int destination) { vis = new boolean[n]; g = new List[n]; k = destination; f = new int[n]; Arrays.setAll(g, key -&amp;gt; new ArrayList&amp;lt;&amp;gt;()); for (var e : edges) { g[e[0]].add(e[1]); } return dfs(source); } private boolean dfs(int i) { if (i == k) { return g[i].isEmpty(); } if (f[i] != 0) { return f[i] == 1; } if (vis[i] || g[i].isEmpty()) { return false; } vis[i] = true; for (int j : g[i]) { if (!dfs(j)) { f[i] = -1; return false; } } f[i] = 1; return true; } } ////// public class All_Paths_from_Source_Lead_to_Destination { class Solution_bfs { public boolean leadsToDestination(int n, int[][] edges, int source, int destination) { Set&amp;lt;Integer&amp;gt;[] graph = new Set[n]; // node =&amp;gt; set of its next nodes for (int i = 0; i &amp;lt; n; i++) { graph[i] = new HashSet&amp;lt;Integer&amp;gt;(); } int[] inDegrees = new int[n]; for (int[] edge : edges) { graph[edge[0]].add(edge[1]); inDegrees[edge[1]]++; } LinkedList&amp;lt;Integer&amp;gt; q = new LinkedList&amp;lt;Integer&amp;gt;(); q.add(source); while (!q.isEmpty())..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2018-10-24T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2018-10-24-1059-All-Paths-from-Source-Lead-to-Destination/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-1059.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="1059 - All Paths from Source Lead to Destination" property="twitter:title"/>
   <meta content="Leetcode 1059. All Paths from Source Lead to Destination Description Given the edges of a directed graph where edges[i] = [ai, bi] indicates there is an edge between nodes ai and bi, and two nodes source and destination of this graph, determine whether or not all paths starting from source eventually, end at destination, that is: At least one path exists from the source node to the destination node If a path exists from the source node to a node with no outgoing edges, then that node is equal to destination. The number of possible paths from source to destination is a finite number. Return true if and only if all roads from source lead to destination. &amp;nbsp; Example 1: Input: n = 3, edges = [[0,1],[0,2]], source = 0, destination = 2 Output: false Explanation: It is possible to reach and get stuck on both node 1 and node 2. Example 2: Input: n = 4, edges = [[0,1],[0,3],[1,2],[2,1]], source = 0, destination = 3 Output: false Explanation: We have two possibilities: to end at node 3, or to loop over node 1 and node 2 indefinitely. Example 3: Input: n = 4, edges = [[0,1],[0,2],[1,3],[2,3]], source = 0, destination = 3 Output: true &amp;nbsp; Constraints: 1 &amp;lt;= n &amp;lt;= 104 0 &amp;lt;= edges.length &amp;lt;= 104 edges.length == 2 0 &amp;lt;= ai, bi &amp;lt;= n - 1 0 &amp;lt;= source &amp;lt;= n - 1 0 &amp;lt;= destination &amp;lt;= n - 1 The given graph may have self-loops and parallel edges. Solutions There are 2 cases it should return false. case 1: it encounters a node that has no outgoing edges, but it is not destination. case 2: it has cycle. Otherwise, it returns true. Could iterate graph with BFS. When indegree of a node becomes negative, then ther is cycle. Time Complexity: O(n+e) e = edges.length. Space: O(n+e). Java C++ Python Go class Solution { private List&amp;lt;Integer&amp;gt;[] g; private int[] f; private boolean[] vis; private int k; public boolean leadsToDestination(int n, int[][] edges, int source, int destination) { vis = new boolean[n]; g = new List[n]; k = destination; f = new int[n]; Arrays.setAll(g, key -&amp;gt; new ArrayList&amp;lt;&amp;gt;()); for (var e : edges) { g[e[0]].add(e[1]); } return dfs(source); } private boolean dfs(int i) { if (i == k) { return g[i].isEmpty(); } if (f[i] != 0) { return f[i] == 1; } if (vis[i] || g[i].isEmpty()) { return false; } vis[i] = true; for (int j : g[i]) { if (!dfs(j)) { f[i] = -1; return false; } } f[i] = 1; return true; } } ////// public class All_Paths_from_Source_Lead_to_Destination { class Solution_bfs { public boolean leadsToDestination(int n, int[][] edges, int source, int destination) { Set&amp;lt;Integer&amp;gt;[] graph = new Set[n]; // node =&amp;gt; set of its next nodes for (int i = 0; i &amp;lt; n; i++) { graph[i] = new HashSet&amp;lt;Integer&amp;gt;(); } int[] inDegrees = new int[n]; for (int[] edge : edges) { graph[edge[0]].add(edge[1]); inDegrees[edge[1]]++; } LinkedList&amp;lt;Integer&amp;gt; q = new LinkedList&amp;lt;Integer&amp;gt;(); q.add(source); while (!q.isEmpty())..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    1059 - All Paths from Source Lead to Destination | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="1059 - All Paths from Source Lead to Destination" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-1059.html" rel="canonical">
          <meta content="https://leetcode.ca/2018-10-24-1059-All-Paths-from-Source-Lead-to-Destination/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2018-10-24T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"1059 - All Paths from Source Lead to Destination","dateModified":"2018-10-24T00:00:00-07:00","datePublished":"2018-10-24T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2018-10-24-1059-All-Paths-from-Source-Lead-to-Destination/"},"url":"https://leetcode.ca/2018-10-24-1059-All-Paths-from-Source-Lead-to-Destination/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="1059-all-paths-from-source-lead-to-destination">
       <a href="solution-1059.html">
        1059. All Paths from Source Lead to Destination
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given the
       <code>
        edges
       </code>
       of a directed graph where
       <code>
        edges[i] = [a
        <sub>
         i
        </sub>
        , b
        <sub>
         i
        </sub>
        ]
       </code>
       indicates there is an edge between nodes
       <code>
        a
        <sub>
         i
        </sub>
       </code>
       and
       <code>
        b
        <sub>
         i
        </sub>
       </code>
       , and two nodes
       <code>
        source
       </code>
       and
       <code>
        destination
       </code>
       of this graph, determine whether or not all paths starting from
       <code>
        source
       </code>
       eventually, end at
       <code>
        destination
       </code>
       , that is:
      </p>
      <ul>
       <li>
        At least one path exists from the
        <code>
         source
        </code>
        node to the
        <code>
         destination
        </code>
        node
       </li>
       <li>
        If a path exists from the
        <code>
         source
        </code>
        node to a node with no outgoing edges, then that node is equal to
        <code>
         destination
        </code>
        .
       </li>
       <li>
        The number of possible paths from
        <code>
         source
        </code>
        to
        <code>
         destination
        </code>
        is a finite number.
       </li>
      </ul>
      <p>
       Return
       <code>
        true
       </code>
       if and only if all roads from
       <code>
        source
       </code>
       lead to
       <code>
        destination
       </code>
       .
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1000-1099/1059.All%20Paths%20from%20Source%20Lead%20to%20Destination/images/485_example_1.png" style="width: 200px; height: 208px;"/>
      </p>
      <pre>
<strong>Input:</strong> n = 3, edges = [[0,1],[0,2]], source = 0, destination = 2
<strong>Output:</strong> false
<strong>Explanation:</strong> It is possible to reach and get stuck on both node 1 and node 2.
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1000-1099/1059.All%20Paths%20from%20Source%20Lead%20to%20Destination/images/485_example_2.png" style="width: 200px; height: 230px;"/>
      </p>
      <pre>
<strong>Input:</strong> n = 4, edges = [[0,1],[0,3],[1,2],[2,1]], source = 0, destination = 3
<strong>Output:</strong> false
<strong>Explanation:</strong> We have two possibilities: to end at node 3, or to loop over node 1 and node 2 indefinitely.
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1000-1099/1059.All%20Paths%20from%20Source%20Lead%20to%20Destination/images/485_example_3.png" style="width: 200px; height: 183px;"/>
      </p>
      <pre>
<strong>Input:</strong> n = 4, edges = [[0,1],[0,2],[1,3],[2,3]], source = 0, destination = 3
<strong>Output:</strong> true
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= n &lt;= 10
         <sup>
          4
         </sup>
        </code>
       </li>
       <li>
        <code>
         0 &lt;= edges.length &lt;= 10
         <sup>
          4
         </sup>
        </code>
       </li>
       <li>
        <code>
         edges.length == 2
        </code>
       </li>
       <li>
        <code>
         0 &lt;= a
         <sub>
          i
         </sub>
         , b
         <sub>
          i
         </sub>
         &lt;= n - 1
        </code>
       </li>
       <li>
        <code>
         0 &lt;= source &lt;= n - 1
        </code>
       </li>
       <li>
        <code>
         0 &lt;= destination &lt;= n - 1
        </code>
       </li>
       <li>
        The given graph may have self-loops and parallel edges.
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       There are 2 cases it should return false.
      </p>
      <ul>
       <li>
        case 1: it encounters a node that has no outgoing edges, but it is not destination.
       </li>
       <li>
        case 2: it has cycle.
       </li>
      </ul>
      <p>
       Otherwise, it returns true.
      </p>
      <p>
       Could iterate graph with BFS. When indegree of a node becomes negative, then ther is cycle.
      </p>
      <p>
       Time Complexity:
       <code class="language-plaintext highlighter-rouge">
        O(n+e)
       </code>
      </p>
      <ul>
       <li>
        e = edges.length.
       </li>
      </ul>
      <p>
       Space:
       <code class="language-plaintext highlighter-rouge">
        O(n+e)
       </code>
       .
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#3adf2039-36a7-4408-acac-0b84eb674d0e'}">
       <li class="uk-active">
        <a href="solution-1059.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-1059.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-1059.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-1059.html">
         Go
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="3adf2039-36a7-4408-acac-0b84eb674d0e">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">g</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">f</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">vis</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">k</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">leadsToDestination</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">,</span> <span class="kt">int</span> <span class="n">source</span><span class="o">,</span> <span class="kt">int</span> <span class="n">destination</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">g</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">List</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">destination</span><span class="o">;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">setAll</span><span class="o">(</span><span class="n">g</span><span class="o">,</span> <span class="n">key</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">var</span> <span class="n">e</span> <span class="o">:</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">g</span><span class="o">[</span><span class="n">e</span><span class="o">[</span><span class="mi">0</span><span class="o">]].</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">source</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">isEmpty</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">vis</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">||</span> <span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">vis</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">:</span> <span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">dfs</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">//////</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">All_Paths_from_Source_Lead_to_Destination</span> <span class="o">{</span>

    <span class="kd">class</span> <span class="nc">Solution_bfs</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">leadsToDestination</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">,</span> <span class="kt">int</span> <span class="n">source</span><span class="o">,</span> <span class="kt">int</span> <span class="n">destination</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="o">[</span><span class="n">n</span><span class="o">];</span> <span class="c1">// node =&gt; set of its next nodes</span>

            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">graph</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
            <span class="o">}</span>

            <span class="kt">int</span><span class="o">[]</span> <span class="n">inDegrees</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">graph</span><span class="o">[</span><span class="n">edge</span><span class="o">[</span><span class="mi">0</span><span class="o">]].</span><span class="na">add</span><span class="o">(</span><span class="n">edge</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
                <span class="n">inDegrees</span><span class="o">[</span><span class="n">edge</span><span class="o">[</span><span class="mi">1</span><span class="o">]]++;</span>
            <span class="o">}</span>

            <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
            <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">source</span><span class="o">);</span>

            <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">graph</span><span class="o">[</span><span class="n">cur</span><span class="o">].</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span> <span class="o">!=</span> <span class="n">destination</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">nei</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">cur</span><span class="o">])</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">inDegrees</span><span class="o">[</span><span class="n">nei</span><span class="o">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// i.e. a cycle</span>
                        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="o">}</span>

                    <span class="n">inDegrees</span><span class="o">[</span><span class="n">nei</span><span class="o">]--;</span>

                    <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nei</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">class</span> <span class="nc">Solution_dfs</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">leadsToDestination</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">,</span> <span class="kt">int</span> <span class="n">source</span><span class="o">,</span> <span class="kt">int</span> <span class="n">destination</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">neighbours</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">edge</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;());</span>
                <span class="n">neighbours</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">edge</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
                <span class="n">graph</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">edge</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">neighbours</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">destination</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="kt">boolean</span><span class="o">[]</span> <span class="n">isVisited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
            <span class="n">isVisited</span><span class="o">[</span><span class="n">source</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">isVisited</span><span class="o">,</span> <span class="n">source</span><span class="o">,</span> <span class="n">destination</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="o">,</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">isVisited</span><span class="o">,</span> <span class="kt">int</span> <span class="n">source</span><span class="o">,</span> <span class="kt">int</span> <span class="n">destination</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">source</span> <span class="o">==</span> <span class="n">destination</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">neighbours</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;());</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">neighbours</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">neib</span> <span class="o">:</span> <span class="n">neighbours</span><span class="o">)</span> <span class="o">{</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">isVisited</span><span class="o">[</span><span class="n">neib</span><span class="o">])</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// cycle spotted</span>

                <span class="n">isVisited</span><span class="o">[</span><span class="n">neib</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">dfs</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">isVisited</span><span class="o">,</span> <span class="n">neib</span><span class="o">,</span> <span class="n">destination</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="n">isVisited</span><span class="o">[</span><span class="n">neib</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">leadsToDestination</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">,</span> <span class="kt">int</span> <span class="n">source</span><span class="p">,</span> <span class="kt">int</span> <span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">vis</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">g</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">e</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">g</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">push_back</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">empty</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dfs</span><span class="p">(</span><span class="n">j</span><span class="p">))</span> <span class="p">{</span>
                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span> <span class="c1"># dfs
</span>    <span class="k">def</span> <span class="nf">leadsToDestination</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">source</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="o">@</span><span class="n">cache</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">destination</span><span class="p">:</span>
                <span class="k">return</span> <span class="ow">not</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vis</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="c1"># not g[i]: not destination but no more neigbours
</span>                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">vis</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">dfs</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>


<span class="c1">#########
</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span> <span class="c1"># bfs
</span>    <span class="k">def</span> <span class="nf">leadsToDestination</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">source</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Build the adjacency list representation of the graph
</span>        <span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="c1"># Handle the case where the destination node has outgoing edges
</span>        <span class="k">if</span> <span class="n">graph</span><span class="p">[</span><span class="n">destination</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c1"># Initialize the visited array to keep track of visited nodes during the traversal
</span>        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

        <span class="c1"># Start the BFS traversal from the source node
</span>        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">source</span><span class="p">])</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>

            <span class="c1"># Check if the current node has no outgoing edges and is not the destination node
</span>            <span class="k">if</span> <span class="n">node</span> <span class="o">!=</span> <span class="n">destination</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="c1"># Process the neighbors of the current node
</span>            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="c1"># If the neighbor has been visited before, it forms a cycle, return False
</span>                <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="bp">False</span>

                <span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>

                <span class="c1"># Remove the edge to prevent revisiting the same node
</span>                <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">remove</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>

        <span class="c1"># Check if all nodes (except the destination) have been visited
</span>        <span class="c1"># destination node may have outgoing edges in the graph, so exclude it
</span>        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">destination</span><span class="p">)</span>


</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">leadsToDestination</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">edges</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="n">source</span> <span class="kt">int</span><span class="p">,</span> <span class="n">destination</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="n">vis</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">bool</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">g</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">f</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">edges</span> <span class="p">{</span>
		<span class="n">g</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="m">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="m">0</span><span class="p">]],</span> <span class="n">e</span><span class="p">[</span><span class="m">1</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">destination</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="m">0</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="m">1</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="no">false</span>
		<span class="p">}</span>
		<span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="no">true</span>
		<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">j</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">if</span> <span class="o">!</span><span class="n">dfs</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="m">1</span>
				<span class="k">return</span> <span class="no">false</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="m">1</span>
		<span class="k">return</span> <span class="no">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-1059.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
