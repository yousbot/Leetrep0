<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-706.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-706.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>706 - Design HashMap</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 706. Design HashMap Description Design a HashMap without using any built-in hash table libraries. Implement the MyHashMap class: MyHashMap() initializes the object with an empty map. void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-706.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-706.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-706.html" rel="stylesheet"/>
   <link href="solution-706.html" rel="stylesheet"/>
   <link href="solution-706.html" rel="stylesheet"/>
   <link href="solution-706.html" rel="stylesheet"/>
   <link href="solution-706.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="706 - Design HashMap" property="og:title"/>
   <meta content="Leetcode 706. Design HashMap Description Design a HashMap without using any built-in hash table libraries. Implement the MyHashMap class: MyHashMap() initializes the object with an empty map. void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value. int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. void remove(key) removes the key and its corresponding value if the map contains the mapping for the key. &amp;nbsp; Example 1: Input [&amp;quot;MyHashMap&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;remove&amp;quot;, &amp;quot;get&amp;quot;] [[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]] Output [null, null, null, 1, -1, null, 1, null, -1] Explanation MyHashMap myHashMap = new MyHashMap(); myHashMap.put(1, 1); // The map is now [[1,1]] myHashMap.put(2, 2); // The map is now [[1,1], [2,2]] myHashMap.get(1); // return 1, The map is now [[1,1], [2,2]] myHashMap.get(3); // return -1 (i.e., not found), The map is now [[1,1], [2,2]] myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value) myHashMap.get(2); // return 1, The map is now [[1,1], [2,1]] myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]] myHashMap.get(2); // return -1 (i.e., not found), The map is now [[1,1]] &amp;nbsp; Constraints: 0 &amp;lt;= key, value &amp;lt;= 106 At most 104 calls will be made to put, get, and remove. Solutions A straightforward approach to implement a hash map is to use chaining with a list of buckets, where each bucket is a list (or linked list) of tuples representing key-value pairs. Since all keys and values are in the range of [0, 1000000], create an array with length 1000001, which has int type. Initially, all the elements in the array are -1. For the put function, set the value at index key in the array to be value. For the remove function, set the value at index key in the array to be -1. For the get function, simply return the element at index key. Some of the questions which can be asked to the interviewer before implementing the solution: For simplicity, are the keys integers only? For collision resolution, can we use chaining? Do we have to worry about load factors? Can we assume inputs are valid or do we have to validate them? Can we assume this fits memory? Open addressing with linear probing There are other ways to implement a HashMap beyond the chaining method with buckets. One alternative approach is to use open addressing with linear probing for collision resolution. In this method, when a collision occurs (i.e., two keys hash to the same index), the algorithm probes subsequent indices in the array (wrapping around to the beginning if necessary) until an empty slot (or the key itself, if already present) is found. Key Differences and Features: Initialization (__init__): The HashMap is initialized with a fixed-size array (self.data)..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2017-11-05T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2017-11-05-706-Design-HashMap/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-706.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="706 - Design HashMap" property="twitter:title"/>
   <meta content="Leetcode 706. Design HashMap Description Design a HashMap without using any built-in hash table libraries. Implement the MyHashMap class: MyHashMap() initializes the object with an empty map. void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value. int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. void remove(key) removes the key and its corresponding value if the map contains the mapping for the key. &amp;nbsp; Example 1: Input [&amp;quot;MyHashMap&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;remove&amp;quot;, &amp;quot;get&amp;quot;] [[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]] Output [null, null, null, 1, -1, null, 1, null, -1] Explanation MyHashMap myHashMap = new MyHashMap(); myHashMap.put(1, 1); // The map is now [[1,1]] myHashMap.put(2, 2); // The map is now [[1,1], [2,2]] myHashMap.get(1); // return 1, The map is now [[1,1], [2,2]] myHashMap.get(3); // return -1 (i.e., not found), The map is now [[1,1], [2,2]] myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value) myHashMap.get(2); // return 1, The map is now [[1,1], [2,1]] myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]] myHashMap.get(2); // return -1 (i.e., not found), The map is now [[1,1]] &amp;nbsp; Constraints: 0 &amp;lt;= key, value &amp;lt;= 106 At most 104 calls will be made to put, get, and remove. Solutions A straightforward approach to implement a hash map is to use chaining with a list of buckets, where each bucket is a list (or linked list) of tuples representing key-value pairs. Since all keys and values are in the range of [0, 1000000], create an array with length 1000001, which has int type. Initially, all the elements in the array are -1. For the put function, set the value at index key in the array to be value. For the remove function, set the value at index key in the array to be -1. For the get function, simply return the element at index key. Some of the questions which can be asked to the interviewer before implementing the solution: For simplicity, are the keys integers only? For collision resolution, can we use chaining? Do we have to worry about load factors? Can we assume inputs are valid or do we have to validate them? Can we assume this fits memory? Open addressing with linear probing There are other ways to implement a HashMap beyond the chaining method with buckets. One alternative approach is to use open addressing with linear probing for collision resolution. In this method, when a collision occurs (i.e., two keys hash to the same index), the algorithm probes subsequent indices in the array (wrapping around to the beginning if necessary) until an empty slot (or the key itself, if already present) is found. Key Differences and Features: Initialization (__init__): The HashMap is initialized with a fixed-size array (self.data)..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    706 - Design HashMap | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="706 - Design HashMap" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-706.html" rel="canonical">
          <meta content="https://leetcode.ca/2017-11-05-706-Design-HashMap/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2017-11-05T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"706 - Design HashMap","dateModified":"2017-11-05T00:00:00-07:00","datePublished":"2017-11-05T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2017-11-05-706-Design-HashMap/"},"url":"https://leetcode.ca/2017-11-05-706-Design-HashMap/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="706-design-hashmap">
       <a href="solution-706.html">
        706. Design HashMap
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Design a HashMap without using any built-in hash table libraries.
      </p>
      <p>
       Implement the
       <code>
        MyHashMap
       </code>
       class:
      </p>
      <ul>
       <li>
        <code>
         MyHashMap()
        </code>
        initializes the object with an empty map.
       </li>
       <li>
        <code>
         void put(int key, int value)
        </code>
        inserts a
        <code>
         (key, value)
        </code>
        pair into the HashMap. If the
        <code>
         key
        </code>
        already exists in the map, update the corresponding
        <code>
         value
        </code>
        .
       </li>
       <li>
        <code>
         int get(int key)
        </code>
        returns the
        <code>
         value
        </code>
        to which the specified
        <code>
         key
        </code>
        is mapped, or
        <code>
         -1
        </code>
        if this map contains no mapping for the
        <code>
         key
        </code>
        .
       </li>
       <li>
        <code>
         void remove(key)
        </code>
        removes the
        <code>
         key
        </code>
        and its corresponding
        <code>
         value
        </code>
        if the map contains the mapping for the
        <code>
         key
        </code>
        .
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input</strong>
["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
<strong>Output</strong>
[null, null, null, 1, -1, null, 1, null, -1]

<strong>Explanation</strong>
MyHashMap myHashMap = new MyHashMap();
myHashMap.put(1, 1); // The map is now [[1,1]]
myHashMap.put(2, 2); // The map is now [[1,1], [2,2]]
myHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]
myHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]
myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)
myHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]
myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]
myHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         0 &lt;= key, value &lt;= 10
         <sup>
          6
         </sup>
        </code>
       </li>
       <li>
        At most
        <code>
         10
         <sup>
          4
         </sup>
        </code>
        calls will be made to
        <code>
         put
        </code>
        ,
        <code>
         get
        </code>
        , and
        <code>
         remove
        </code>
        .
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       A straightforward approach to implement a hash map  is to use chaining with a list of buckets, where each bucket is a list (or linked list) of tuples representing key-value pairs.
      </p>
      <p>
       Since all keys and values are in the range of
       <code class="language-plaintext highlighter-rouge">
        [0, 1000000]
       </code>
       , create an array with length 1000001, which has
       <code class="language-plaintext highlighter-rouge">
        int
       </code>
       type. Initially, all the elements in the array are -1.
      </p>
      <p>
       For the
       <code class="language-plaintext highlighter-rouge">
        put
       </code>
       function, set the value at index
       <code class="language-plaintext highlighter-rouge">
        key
       </code>
       in the array to be
       <code class="language-plaintext highlighter-rouge">
        value
       </code>
       .
      </p>
      <p>
       For the
       <code class="language-plaintext highlighter-rouge">
        remove
       </code>
       function, set the value at index
       <code class="language-plaintext highlighter-rouge">
        key
       </code>
       in the array to be -1.
      </p>
      <p>
       For the
       <code class="language-plaintext highlighter-rouge">
        get
       </code>
       function, simply return the element at index
       <code class="language-plaintext highlighter-rouge">
        key
       </code>
       .
      </p>
      <p>
       Some of the questions which can be asked to the interviewer before implementing the solution:
      </p>
      <ul>
       <li>
        For simplicity, are the keys integers only?
       </li>
       <li>
        For collision resolution, can we use chaining?
       </li>
       <li>
        Do we have to worry about load factors?
       </li>
       <li>
        Can we assume inputs are valid or do we have to validate them?
       </li>
       <li>
        Can we assume this fits memory?
       </li>
      </ul>
      <h2 id="open-addressing-with-linear-probing">
       Open addressing with linear probing
      </h2>
      <p>
       There are other ways to implement a HashMap beyond the chaining method with buckets. One alternative approach is to use
       <strong>
        open addressing
       </strong>
       with linear probing for collision resolution. In this method, when a collision occurs (i.e., two keys hash to the same index), the algorithm probes subsequent indices in the array (wrapping around to the beginning if necessary) until an empty slot (or the key itself, if already present) is found.
      </p>
      <h3 id="key-differences-and-features">
       Key Differences and Features:
      </h3>
      <ul>
       <li>
        <p>
         <strong>
          Initialization (
          <code class="language-plaintext highlighter-rouge">
           __init__
          </code>
          ):
         </strong>
         The HashMap is initialized with a fixed-size array (
         <code class="language-plaintext highlighter-rouge">
          self.data
         </code>
         ) that stores key-value pairs directly. A special marker (
         <code class="language-plaintext highlighter-rouge">
          self.DELETED
         </code>
         ) is used to indicate deleted entries, which is necessary for linear probing to function correctly.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Linear Probing in
          <code class="language-plaintext highlighter-rouge">
           put
          </code>
          :
         </strong>
         To insert a new key-value pair, the method computes the index for the key using the
         <code class="language-plaintext highlighter-rouge">
          _hash
         </code>
         function. If the computed index is occupied (by a different key), it linearly probes subsequent indices until an empty slot or the key itself is found.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Retrieving Values (
          <code class="language-plaintext highlighter-rouge">
           get
          </code>
          ):
         </strong>
         To retrieve a value, the
         <code class="language-plaintext highlighter-rouge">
          _find
         </code>
         helper method is used to locate the key in the array. If found, it returns the associated value; otherwise,
         <code class="language-plaintext highlighter-rouge">
          -1
         </code>
         is returned.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Removing Entries (
          <code class="language-plaintext highlighter-rouge">
           remove
          </code>
          ):
         </strong>
         To remove a key-value pair, the
         <code class="language-plaintext highlighter-rouge">
          _find
         </code>
         method locates the key, and its slot is marked as deleted using the
         <code class="language-plaintext highlighter-rouge">
          self.DELETED
         </code>
         marker. This allows linear probing to continue working correctly for other keys.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Finding Entries (
          <code class="language-plaintext highlighter-rouge">
           _find
          </code>
          ):
         </strong>
         A helper method that attempts to find the slot containing the specified key, taking into account linear probing and deleted entries. It returns both the index and a boolean indicating whether the key was found.
        </p>
       </li>
      </ul>
      <h3 id="advantages-and-considerations">
       Advantages and Considerations:
      </h3>
      <ul>
       <li>
        <strong>
         Space Efficiency:
        </strong>
        This approach tends to be more space-efficient compared to chaining, especially when the load factor is low to moderate.
       </li>
       <li>
        <strong>
         Performance:
        </strong>
        While open addressing with linear probing can offer good performance for lookups, inserts, and deletions, it may suffer from clustering effects, where consecutive slots become filled, leading to longer probe sequences. Careful management of the load factor and capacity is crucial.
       </li>
       <li>
        <strong>
         Resizing:
        </strong>
        To maintain efficient operations, the capacity of the array may need to be increased (and all keys rehashed) when the load factor gets too high. This resizing logic is not included in the above implementation but would be necessary for a production-level HashMap to ensure performance does not degrade with many entries.
       </li>
      </ul>
      <ul class="uk-tab" data-uk-switcher="{connect:'#64cb012d-f15d-4f59-afd1-5f00f9ab3259'}">
       <li class="uk-active">
        <a href="solution-706.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-706.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-706.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-706.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-706.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="64cb012d-f15d-4f59-afd1-5f00f9ab3259">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyHashMap</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">1000001</span><span class="o">];</span>

    <span class="kd">public</span> <span class="nf">MyHashMap</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">data</span><span class="o">[</span><span class="n">key</span><span class="o">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">[</span><span class="n">key</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">data</span><span class="o">[</span><span class="n">key</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Your MyHashMap object will be instantiated and called as such:
 * MyHashMap obj = new MyHashMap();
 * obj.put(key,value);
 * int param_2 = obj.get(key);
 * obj.remove(key);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">MyHashMap</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="mi">1000001</span><span class="p">];</span>

    <span class="n">MyHashMap</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">put</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**
 * Your MyHashMap object will be instantiated and called as such:
 * MyHashMap* obj = new MyHashMap();
 * obj-&gt;put(key,value);
 * int param_2 = obj-&gt;get(key);
 * obj-&gt;remove(key);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">MyHashMap</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1000001</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>


<span class="c1"># Your MyHashMap object will be instantiated and called as such:
# obj = MyHashMap()
# obj.put(key,value)
# param_2 = obj.get(key)
# obj.remove(key)
</span>
<span class="c1">#############
</span>
<span class="k">class</span> <span class="nc">MyHashMap</span><span class="p">:</span> <span class="c1"># hash to bucket
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        Initialize your data structure here.
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">buckets</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">size</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="s">"""
        Generate a hash for a given key.
        """</span>
        <span class="k">return</span> <span class="n">key</span> <span class="o">%</span> <span class="bp">self</span><span class="p">.</span><span class="n">size</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="s">"""
        Value will always be non-negative.
        """</span>
        <span class="n">hash_key</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">buckets</span><span class="p">[</span><span class="n">hash_key</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">buckets</span><span class="p">[</span><span class="n">hash_key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">buckets</span><span class="p">[</span><span class="n">hash_key</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="s">"""
        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
        """</span>
        <span class="n">hash_key</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">buckets</span><span class="p">[</span><span class="n">hash_key</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">v</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="s">"""
        Removes the mapping of the specified value key if this map contains a mapping for the key.
        """</span>
        <span class="n">hash_key</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">buckets</span><span class="p">[</span><span class="n">hash_key</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">.</span><span class="n">buckets</span><span class="p">[</span><span class="n">hash_key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">return</span>

<span class="c1">###############
</span>
<span class="k">class</span> <span class="nc">MyHashMap</span><span class="p">:</span> <span class="c1"># open addressing with linear probing
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">10000</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">DELETED</span> <span class="o">=</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>  <span class="c1"># Marker for deleted entries
</span>
    <span class="k">def</span> <span class="nf">_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">key</span> <span class="o">%</span> <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">DELETED</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">idx</span><span class="p">,</span> <span class="n">found_key</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">found_key</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">idx</span><span class="p">,</span> <span class="n">found_key</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">found_key</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">DELETED</span>

    <span class="k">def</span> <span class="nf">_find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">original_idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">.</span><span class="n">DELETED</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">idx</span><span class="p">,</span> <span class="bp">True</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">original_idx</span><span class="p">:</span>  <span class="c1"># Came full circle
</span>                <span class="k">break</span>
        <span class="k">return</span> <span class="n">original_idx</span><span class="p">,</span> <span class="bp">False</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">type</span> <span class="n">MyHashMap</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">data</span> <span class="p">[]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Constructor</span><span class="p">()</span> <span class="n">MyHashMap</span> <span class="p">{</span>
	<span class="n">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">1000010</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">data</span> <span class="p">{</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="m">1</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">MyHashMap</span><span class="p">{</span><span class="n">data</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">MyHashMap</span><span class="p">)</span> <span class="n">Put</span><span class="p">(</span><span class="n">key</span> <span class="kt">int</span><span class="p">,</span> <span class="n">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">this</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">MyHashMap</span><span class="p">)</span> <span class="n">Get</span><span class="p">(</span><span class="n">key</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">MyHashMap</span><span class="p">)</span> <span class="n">Remove</span><span class="p">(</span><span class="n">key</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">this</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="m">1</span>
<span class="p">}</span>

<span class="c">/**
 * Your MyHashMap object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Put(key,value);
 * param_2 := obj.Get(key);
 * obj.Remove(key);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyHashMap</span> <span class="p">{</span>
    <span class="nl">data</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">6</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">put</span><span class="p">(</span><span class="nx">key</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">value</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">get</span><span class="p">(</span><span class="nx">key</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="nx">remove</span><span class="p">(</span><span class="nx">key</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
 * Your MyHashMap object will be instantiated and called as such:
 * var obj = new MyHashMap()
 * obj.put(key,value)
 * var param_2 = obj.get(key)
 * obj.remove(key)
 */</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-706.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
