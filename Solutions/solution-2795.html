<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-2795.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-2795.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>2795 - Parallel Execution of Promises for Individual Results Retrieval</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 2795. Parallel Execution of Promises for Individual Results Retrieval Description Given an array&amp;nbsp;functions, return a promise promise. functions&amp;nbsp;is an array of functions that return promises fnPromise.&amp;nbsp;Each fnPromise&amp;nbsp;can be resolved or rejected.&amp;nbsp;&amp;nbsp; If&amp;nbsp;fnPromise is resolved: &amp;nbsp; &amp;nbsp; obj = { status: &amp;quot;fulfilled&amp;quot;, value: resolved value} If&amp;nbsp;fnPromise...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-2795.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-2795.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-2795.html" rel="stylesheet"/>
   <link href="solution-2795.html" rel="stylesheet"/>
   <link href="solution-2795.html" rel="stylesheet"/>
   <link href="solution-2795.html" rel="stylesheet"/>
   <link href="solution-2795.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="2795 - Parallel Execution of Promises for Individual Results Retrieval" property="og:title"/>
   <meta content="Leetcode 2795. Parallel Execution of Promises for Individual Results Retrieval Description Given an array&amp;nbsp;functions, return a promise promise. functions&amp;nbsp;is an array of functions that return promises fnPromise.&amp;nbsp;Each fnPromise&amp;nbsp;can be resolved or rejected.&amp;nbsp;&amp;nbsp; If&amp;nbsp;fnPromise is resolved: &amp;nbsp; &amp;nbsp; obj = { status: &amp;quot;fulfilled&amp;quot;, value: resolved value} If&amp;nbsp;fnPromise is rejected: &amp;nbsp; &amp;nbsp;&amp;nbsp;obj = { status: &amp;quot;rejected&amp;quot;, reason: reason of rejection (catched error message)} The promise&amp;nbsp;should resolve with an array of these objects obj.&amp;nbsp;Each obj in the array should correspond&amp;nbsp;to the promises in the original array function, maintaining the same order. Try to implement it without using the built-in method&amp;nbsp;Promise.allSettled(). &amp;nbsp; Example 1: Input: functions = [ () =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(15), 100)) ] Output: {&amp;quot;t&amp;quot;:100,&amp;quot;values&amp;quot;:[{&amp;quot;status&amp;quot;:&amp;quot;fulfilled&amp;quot;,&amp;quot;value&amp;quot;:15}]} Explanation: const time = performance.now() const promise = promiseAllSettled(functions); &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; promise.then(res =&amp;gt; { const out = {t: Math.floor(performance.now() - time), values: res} console.log(out) // {&amp;quot;t&amp;quot;:100,&amp;quot;values&amp;quot;:[{&amp;quot;status&amp;quot;:&amp;quot;fulfilled&amp;quot;,&amp;quot;value&amp;quot;:15}]} }) The returned promise resolves within 100 milliseconds. Since promise from the array functions is fulfilled, the resolved value of the returned promise is set to [{&amp;quot;status&amp;quot;:&amp;quot;fulfilled&amp;quot;,&amp;quot;value&amp;quot;:15}]. Example 2: Input: functions = [ () =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(20), 100)), () =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(15), 100)) ] Output: { &amp;quot;t&amp;quot;:100, &amp;quot;values&amp;quot;: [ &amp;nbsp; {&amp;quot;status&amp;quot;:&amp;quot;fulfilled&amp;quot;,&amp;quot;value&amp;quot;:20}, &amp;nbsp; {&amp;quot;status&amp;quot;:&amp;quot;fulfilled&amp;quot;,&amp;quot;value&amp;quot;:15} ] } Explanation: The returned promise resolves within 100 milliseconds, because the resolution time is determined by the promise that takes the longest time to fulfill. Since promises from the array functions are fulfilled, the resolved value of the returned promise is set to [{&amp;quot;status&amp;quot;:&amp;quot;fulfilled&amp;quot;,&amp;quot;value&amp;quot;:20},{&amp;quot;status&amp;quot;:&amp;quot;fulfilled&amp;quot;,&amp;quot;value&amp;quot;:15}]. Example 3: Input: functions = [ &amp;nbsp; () =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(30), 200)), &amp;nbsp; () =&amp;gt; new Promise((resolve, reject) =&amp;gt; setTimeout(() =&amp;gt; reject(&amp;quot;Error&amp;quot;), 100)) ] Output: { &amp;quot;t&amp;quot;:200, &amp;quot;values&amp;quot;: [ {&amp;quot;status&amp;quot;:&amp;quot;fulfilled&amp;quot;,&amp;quot;value&amp;quot;:30}, {&amp;quot;status&amp;quot;:&amp;quot;rejected&amp;quot;,&amp;quot;reason&amp;quot;:&amp;quot;Error&amp;quot;} ] } Explanation: The returned promise resolves within 200 milliseconds, as its resolution time is determined by the promise that takes the longest time to fulfill. Since one promise from the array function is fulfilled and another is rejected, the resolved value of the returned promise is set to an array containing objects in the following order: [{&amp;quot;status&amp;quot;:&amp;quot;fulfilled&amp;quot;,&amp;quot;value&amp;quot;:30}, {&amp;quot;status&amp;quot;:&amp;quot;rejected&amp;quot;,&amp;quot;reason&amp;quot;:&amp;quot;Error&amp;quot;}]. Each object in the array corresponds to the promises in the original array function, maintaining the same order. &amp;nbsp; Constraints: 1 &amp;lt;= functions.length &amp;lt;= 10 Solutions TypeScript Javascript type FulfilledObj = { status: 'fulfilled'; value: string; }; type RejectedObj = { status: 'rejected'; reason: string; }; type Obj = FulfilledObj | RejectedObj; function promiseAllSettled(functions: Function[]): Promise&amp;lt;Obj[]&amp;gt; { return new Promise(resolve =&amp;gt; { const res: Obj[] = []; let count = 0; for (let i in functions) { functions[i]() .then(value =&amp;gt; ({ status: 'fulfilled', value })) .catch(reason =&amp;gt; ({ status: 'rejected', reason })) .then(obj =&amp;gt; { res[i] = obj; if (++count === functions.length) { resolve(res); } }); } }); } /** * const functions = [ * () =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(15), 100)) * ] * const time = performance.now() * * const promise = promiseAllSettled(functions); * * promise.then(res =&amp;gt; { * const out = {t:..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2023-07-26T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2023-07-26-2795-Parallel-Execution-of-Promises-for-Individual-Results-Retrieval/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-2795.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="2795 - Parallel Execution of Promises for Individual Results Retrieval" property="twitter:title"/>
   <meta content="Leetcode 2795. Parallel Execution of Promises for Individual Results Retrieval Description Given an array&amp;nbsp;functions, return a promise promise. functions&amp;nbsp;is an array of functions that return promises fnPromise.&amp;nbsp;Each fnPromise&amp;nbsp;can be resolved or rejected.&amp;nbsp;&amp;nbsp; If&amp;nbsp;fnPromise is resolved: &amp;nbsp; &amp;nbsp; obj = { status: &amp;quot;fulfilled&amp;quot;, value: resolved value} If&amp;nbsp;fnPromise is rejected: &amp;nbsp; &amp;nbsp;&amp;nbsp;obj = { status: &amp;quot;rejected&amp;quot;, reason: reason of rejection (catched error message)} The promise&amp;nbsp;should resolve with an array of these objects obj.&amp;nbsp;Each obj in the array should correspond&amp;nbsp;to the promises in the original array function, maintaining the same order. Try to implement it without using the built-in method&amp;nbsp;Promise.allSettled(). &amp;nbsp; Example 1: Input: functions = [ () =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(15), 100)) ] Output: {&amp;quot;t&amp;quot;:100,&amp;quot;values&amp;quot;:[{&amp;quot;status&amp;quot;:&amp;quot;fulfilled&amp;quot;,&amp;quot;value&amp;quot;:15}]} Explanation: const time = performance.now() const promise = promiseAllSettled(functions); &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; promise.then(res =&amp;gt; { const out = {t: Math.floor(performance.now() - time), values: res} console.log(out) // {&amp;quot;t&amp;quot;:100,&amp;quot;values&amp;quot;:[{&amp;quot;status&amp;quot;:&amp;quot;fulfilled&amp;quot;,&amp;quot;value&amp;quot;:15}]} }) The returned promise resolves within 100 milliseconds. Since promise from the array functions is fulfilled, the resolved value of the returned promise is set to [{&amp;quot;status&amp;quot;:&amp;quot;fulfilled&amp;quot;,&amp;quot;value&amp;quot;:15}]. Example 2: Input: functions = [ () =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(20), 100)), () =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(15), 100)) ] Output: { &amp;quot;t&amp;quot;:100, &amp;quot;values&amp;quot;: [ &amp;nbsp; {&amp;quot;status&amp;quot;:&amp;quot;fulfilled&amp;quot;,&amp;quot;value&amp;quot;:20}, &amp;nbsp; {&amp;quot;status&amp;quot;:&amp;quot;fulfilled&amp;quot;,&amp;quot;value&amp;quot;:15} ] } Explanation: The returned promise resolves within 100 milliseconds, because the resolution time is determined by the promise that takes the longest time to fulfill. Since promises from the array functions are fulfilled, the resolved value of the returned promise is set to [{&amp;quot;status&amp;quot;:&amp;quot;fulfilled&amp;quot;,&amp;quot;value&amp;quot;:20},{&amp;quot;status&amp;quot;:&amp;quot;fulfilled&amp;quot;,&amp;quot;value&amp;quot;:15}]. Example 3: Input: functions = [ &amp;nbsp; () =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(30), 200)), &amp;nbsp; () =&amp;gt; new Promise((resolve, reject) =&amp;gt; setTimeout(() =&amp;gt; reject(&amp;quot;Error&amp;quot;), 100)) ] Output: { &amp;quot;t&amp;quot;:200, &amp;quot;values&amp;quot;: [ {&amp;quot;status&amp;quot;:&amp;quot;fulfilled&amp;quot;,&amp;quot;value&amp;quot;:30}, {&amp;quot;status&amp;quot;:&amp;quot;rejected&amp;quot;,&amp;quot;reason&amp;quot;:&amp;quot;Error&amp;quot;} ] } Explanation: The returned promise resolves within 200 milliseconds, as its resolution time is determined by the promise that takes the longest time to fulfill. Since one promise from the array function is fulfilled and another is rejected, the resolved value of the returned promise is set to an array containing objects in the following order: [{&amp;quot;status&amp;quot;:&amp;quot;fulfilled&amp;quot;,&amp;quot;value&amp;quot;:30}, {&amp;quot;status&amp;quot;:&amp;quot;rejected&amp;quot;,&amp;quot;reason&amp;quot;:&amp;quot;Error&amp;quot;}]. Each object in the array corresponds to the promises in the original array function, maintaining the same order. &amp;nbsp; Constraints: 1 &amp;lt;= functions.length &amp;lt;= 10 Solutions TypeScript Javascript type FulfilledObj = { status: 'fulfilled'; value: string; }; type RejectedObj = { status: 'rejected'; reason: string; }; type Obj = FulfilledObj | RejectedObj; function promiseAllSettled(functions: Function[]): Promise&amp;lt;Obj[]&amp;gt; { return new Promise(resolve =&amp;gt; { const res: Obj[] = []; let count = 0; for (let i in functions) { functions[i]() .then(value =&amp;gt; ({ status: 'fulfilled', value })) .catch(reason =&amp;gt; ({ status: 'rejected', reason })) .then(obj =&amp;gt; { res[i] = obj; if (++count === functions.length) { resolve(res); } }); } }); } /** * const functions = [ * () =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(15), 100)) * ] * const time = performance.now() * * const promise = promiseAllSettled(functions); * * promise.then(res =&amp;gt; { * const out = {t:..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    2795 - Parallel Execution of Promises for Individual Results Retrieval | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="2795 - Parallel Execution of Promises for Individual Results Retrieval" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-2795.html" rel="canonical">
          <meta content="https://leetcode.ca/2023-07-26-2795-Parallel-Execution-of-Promises-for-Individual-Results-Retrieval/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2023-07-26T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"2795 - Parallel Execution of Promises for Individual Results Retrieval","dateModified":"2023-07-26T00:00:00-07:00","datePublished":"2023-07-26T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2023-07-26-2795-Parallel-Execution-of-Promises-for-Individual-Results-Retrieval/"},"url":"https://leetcode.ca/2023-07-26-2795-Parallel-Execution-of-Promises-for-Individual-Results-Retrieval/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="2795-parallel-execution-of-promises-for-individual-results-retrieval">
       <a href="solution-2795.html">
        2795. Parallel Execution of Promises for Individual Results Retrieval
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given an array
       <code>
        functions
       </code>
       , return a promise
       <code>
        promise
       </code>
       .
       <code>
        functions
       </code>
       is an array of functions that return promises
       <code>
        fnPromise.
       </code>
       Each
       <code>
        fnPromise
       </code>
       can be resolved or rejected.
      </p>
      <p>
       If
       <code>
        fnPromise
       </code>
       is resolved:
      </p>
      <p>
       <code>
        obj = { status: "fulfilled", value:
        <em>
         resolved value
        </em>
        }
       </code>
      </p>
      <p>
       If
       <code>
        fnPromise
       </code>
       is rejected:
      </p>
      <p>
       <code>
        obj = { status: "rejected", reason:
        <em>
         reason of rejection (catched error message)
        </em>
        }
       </code>
      </p>
      <p>
       The
       <code>
        promise
       </code>
       should resolve with an array of these objects
       <code>
        obj
       </code>
       . Each
       <code>
        obj
       </code>
       in the array should correspond to the promises in the original array function,
       <strong>
        maintaining the same order
       </strong>
       .
      </p>
      <p>
       Try to implement it without using the built-in method
       <code>
        Promise.allSettled()
       </code>
       .
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> functions = [
    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(15), 100))
]
<strong>Output: </strong>{"t":100,"values":[{"status":"fulfilled","value":15}]}
<strong>Explanation:</strong> 
const time = performance.now()
const promise = promiseAllSettled(functions);
               
promise.then(res =&gt; {
    const out = {t: Math.floor(performance.now() - time), values: res}
    console.log(out) // {"t":100,"values":[{"status":"fulfilled","value":15}]}
})

The returned promise resolves within 100 milliseconds. Since promise from the array functions is fulfilled, the resolved value of the returned promise is set to [{"status":"fulfilled","value":15}].
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> functions = [
    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(20), 100)), 
    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(15), 100))
]
<strong>Output: 
</strong>{
    "t":100,
    "values": [
        {"status":"fulfilled","value":20},
        {"status":"fulfilled","value":15}
    ]
}
<strong>Explanation:</strong> The returned promise resolves within 100 milliseconds, because the resolution time is determined by the promise that takes the longest time to fulfill. Since promises from the array functions are fulfilled, the resolved value of the returned promise is set to [{"status":"fulfilled","value":20},{"status":"fulfilled","value":15}].
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> functions = [
    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(30), 200)), 
    () =&gt; new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject("Error"), 100))
]
<strong>Output:</strong>
{
    "t":200,
    "values": [
        {"status":"fulfilled","value":30},
        {"status":"rejected","reason":"Error"}
    ]
}
<strong>Explanation:</strong> The returned promise resolves within 200 milliseconds, as its resolution time is determined by the promise that takes the longest time to fulfill. Since one promise from the array function is fulfilled and another is rejected, the resolved value of the returned promise is set to an array containing objects in the following order: [{"status":"fulfilled","value":30}, {"status":"rejected","reason":"Error"}]. Each object in the array corresponds to the promises in the original array function, maintaining the same order.
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= functions.length &lt;= 10
        </code>
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <ul class="uk-tab" data-uk-switcher="{connect:'#934d7971-c33d-49b9-b334-28c9380101f6'}">
       <li class="uk-active">
        <a href="solution-2795.html">
         TypeScript
        </a>
       </li>
       <li>
        <a href="solution-2795.html">
         Javascript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="934d7971-c33d-49b9-b334-28c9380101f6">
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">type</span> <span class="nx">FulfilledObj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">status</span><span class="p">:</span> <span class="dl">'</span><span class="s1">fulfilled</span><span class="dl">'</span><span class="p">;</span>
    <span class="nl">value</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">};</span>
<span class="kd">type</span> <span class="nx">RejectedObj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">status</span><span class="p">:</span> <span class="dl">'</span><span class="s1">rejected</span><span class="dl">'</span><span class="p">;</span>
    <span class="nl">reason</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">};</span>
<span class="kd">type</span> <span class="nx">Obj</span> <span class="o">=</span> <span class="nx">FulfilledObj</span> <span class="o">|</span> <span class="nx">RejectedObj</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">promiseAllSettled</span><span class="p">(</span><span class="nx">functions</span><span class="p">:</span> <span class="nb">Function</span><span class="p">[]):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">Obj</span><span class="p">[]</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="na">res</span><span class="p">:</span> <span class="nx">Obj</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">functions</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">functions</span><span class="p">[</span><span class="nx">i</span><span class="p">]()</span>
                <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="na">status</span><span class="p">:</span> <span class="dl">'</span><span class="s1">fulfilled</span><span class="dl">'</span><span class="p">,</span> <span class="nx">value</span> <span class="p">}))</span>
                <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">reason</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="na">status</span><span class="p">:</span> <span class="dl">'</span><span class="s1">rejected</span><span class="dl">'</span><span class="p">,</span> <span class="nx">reason</span> <span class="p">}))</span>
                <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">obj</span> <span class="o">=&gt;</span> <span class="p">{</span>
                    <span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="nx">count</span> <span class="o">===</span> <span class="nx">functions</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
                        <span class="nx">resolve</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="cm">/**
 * const functions = [
 *    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(15), 100))
 * ]
 * const time = performance.now()
 *
 * const promise = promiseAllSettled(functions);
 *
 * promise.then(res =&gt; {
 *     const out = {t: Math.floor(performance.now() - time), values: res}
 *     console.log(out) // {"t":100,"values":[{"status":"fulfilled","value":15}]}
 * })
 */</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-js highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * @param {Array&lt;Function&gt;} functions
 * @return {Promise}
 */</span>
<span class="kd">var</span> <span class="nx">promiseAllSettled</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">functions</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">functions</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">functions</span><span class="p">[</span><span class="nx">i</span><span class="p">]()</span>
                <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="na">status</span><span class="p">:</span> <span class="dl">'</span><span class="s1">fulfilled</span><span class="dl">'</span><span class="p">,</span> <span class="nx">value</span> <span class="p">}))</span>
                <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">reason</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="na">status</span><span class="p">:</span> <span class="dl">'</span><span class="s1">rejected</span><span class="dl">'</span><span class="p">,</span> <span class="nx">reason</span> <span class="p">}))</span>
                <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">obj</span> <span class="o">=&gt;</span> <span class="p">{</span>
                    <span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="nx">count</span> <span class="o">===</span> <span class="nx">functions</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
                        <span class="nx">resolve</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">};</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-2795.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
