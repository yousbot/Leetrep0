<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-653.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-653.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>653 - Two Sum IV - Input is a BST</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 653. Two Sum IV - Input is a BST Description Given the root of a binary search tree and an integer k, return true if there exist two elements in the BST such that their sum is equal to k, or false otherwise. &amp;nbsp; Example...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-653.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-653.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-653.html" rel="stylesheet"/>
   <link href="solution-653.html" rel="stylesheet"/>
   <link href="solution-653.html" rel="stylesheet"/>
   <link href="solution-653.html" rel="stylesheet"/>
   <link href="solution-653.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="653 - Two Sum IV - Input is a BST" property="og:title"/>
   <meta content="Leetcode 653. Two Sum IV - Input is a BST Description Given the root of a binary search tree and an integer k, return true if there exist two elements in the BST such that their sum is equal to k, or false otherwise. &amp;nbsp; Example 1: Input: root = [5,3,6,2,4,null,7], k = 9 Output: true Example 2: Input: root = [5,3,6,2,4,null,7], k = 28 Output: false &amp;nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. -104 &amp;lt;= Node.val &amp;lt;= 104 root is guaranteed to be a valid binary search tree. -105 &amp;lt;= k &amp;lt;= 105 Solution 1 - set As long as it is the question of the sum of two numbers, you must remember to try to do it with HashSet. This question is just to turn the array into a binary tree. We need to traverse the binary tree and use a HashSet. In the recursive function function, if node is empty, return false. If k minus the current node value exists in the HashSet, return true directly; otherwise, add the current node value to the HashSet, and then call the recursive function on the left and right sub-nodes and return together. Solution 2 - two pointers This solution defines two classes: BSTIterator and Solution. The BSTIterator class is designed to iterate through a binary search tree (BST) in either ascending (left-to-right) or descending (right-to-left) order. The Solution class uses two instances of BSTIterator to find if there exists two elements in the BST such that their sum equals a given target value k. Class: BSTIterator Constructor __init__: Initializes the iterator with the root of a BST and a boolean flag leftToRight indicating the direction of iteration (ascending if True, descending if False). It initializes an empty stack to facilitate controlled traversal of the BST and calls _pushUntilNone to preload the stack with the initial path from the root towards the leftmost or rightmost node, depending on the iteration direction. Method next: Returns the next integer in the sequence. It pops the top element from the stack (which is the next element in order), then, depending on the iteration direction, traverses towards the next node in that order, pushing nodes encountered along the way onto the stack. This ensures that the stack always contains the nodes that maintain the current path in the tree relevant to the iteration order. Method _pushUntilNone: Given a starting node, it iteratively traverses the tree towards the leftmost (for ascending order) or rightmost (for descending order) node, pushing all encountered nodes onto the stack. This method ensures that the next call to next will return the next correct value in the sequence. Class: Solution Method findTarget: This method checks if there are two numbers in the BST that add up to k. It initializes two BSTIterator instances, one for ascending order (left) and one for descending order (right). It then iterates through the BST from both ends simultaneously (smallest and largest values),..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2017-09-13T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2017-09-13-653-Two-Sum-IV-Input-is-a-BST/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-653.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="653 - Two Sum IV - Input is a BST" property="twitter:title"/>
   <meta content="Leetcode 653. Two Sum IV - Input is a BST Description Given the root of a binary search tree and an integer k, return true if there exist two elements in the BST such that their sum is equal to k, or false otherwise. &amp;nbsp; Example 1: Input: root = [5,3,6,2,4,null,7], k = 9 Output: true Example 2: Input: root = [5,3,6,2,4,null,7], k = 28 Output: false &amp;nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. -104 &amp;lt;= Node.val &amp;lt;= 104 root is guaranteed to be a valid binary search tree. -105 &amp;lt;= k &amp;lt;= 105 Solution 1 - set As long as it is the question of the sum of two numbers, you must remember to try to do it with HashSet. This question is just to turn the array into a binary tree. We need to traverse the binary tree and use a HashSet. In the recursive function function, if node is empty, return false. If k minus the current node value exists in the HashSet, return true directly; otherwise, add the current node value to the HashSet, and then call the recursive function on the left and right sub-nodes and return together. Solution 2 - two pointers This solution defines two classes: BSTIterator and Solution. The BSTIterator class is designed to iterate through a binary search tree (BST) in either ascending (left-to-right) or descending (right-to-left) order. The Solution class uses two instances of BSTIterator to find if there exists two elements in the BST such that their sum equals a given target value k. Class: BSTIterator Constructor __init__: Initializes the iterator with the root of a BST and a boolean flag leftToRight indicating the direction of iteration (ascending if True, descending if False). It initializes an empty stack to facilitate controlled traversal of the BST and calls _pushUntilNone to preload the stack with the initial path from the root towards the leftmost or rightmost node, depending on the iteration direction. Method next: Returns the next integer in the sequence. It pops the top element from the stack (which is the next element in order), then, depending on the iteration direction, traverses towards the next node in that order, pushing nodes encountered along the way onto the stack. This ensures that the stack always contains the nodes that maintain the current path in the tree relevant to the iteration order. Method _pushUntilNone: Given a starting node, it iteratively traverses the tree towards the leftmost (for ascending order) or rightmost (for descending order) node, pushing all encountered nodes onto the stack. This method ensures that the next call to next will return the next correct value in the sequence. Class: Solution Method findTarget: This method checks if there are two numbers in the BST that add up to k. It initializes two BSTIterator instances, one for ascending order (left) and one for descending order (right). It then iterates through the BST from both ends simultaneously (smallest and largest values),..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    653 - Two Sum IV - Input is a BST | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="653 - Two Sum IV - Input is a BST" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-653.html" rel="canonical">
          <meta content="https://leetcode.ca/2017-09-13-653-Two-Sum-IV-Input-is-a-BST/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2017-09-13T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"653 - Two Sum IV - Input is a BST","dateModified":"2017-09-13T00:00:00-07:00","datePublished":"2017-09-13T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2017-09-13-653-Two-Sum-IV-Input-is-a-BST/"},"url":"https://leetcode.ca/2017-09-13-653-Two-Sum-IV-Input-is-a-BST/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="653-two-sum-iv---input-is-a-bst">
       <a href="solution-653.html">
        653. Two Sum IV - Input is a BST
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given the
       <code>
        root
       </code>
       of a binary search tree and an integer
       <code>
        k
       </code>
       , return
       <code>
        true
       </code>
       <em>
        if there exist two elements in the BST such that their sum is equal to
       </em>
       <code>
        k
       </code>
       ,
       <em>
        or
       </em>
       <code>
        false
       </code>
       <em>
        otherwise
       </em>
       .
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0600-0699/0653.Two%20Sum%20IV%20-%20Input%20is%20a%20BST/images/sum_tree_1.jpg" style="width: 400px; height: 229px;"/>
      </p>
      <pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,7], k = 9
<strong>Output:</strong> true
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0600-0699/0653.Two%20Sum%20IV%20-%20Input%20is%20a%20BST/images/sum_tree_2.jpg" style="width: 400px; height: 229px;"/>
      </p>
      <pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,7], k = 28
<strong>Output:</strong> false
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the tree is in the range
        <code>
         [1, 10
         <sup>
          4
         </sup>
         ]
        </code>
        .
       </li>
       <li>
        <code>
         -10
         <sup>
          4
         </sup>
         &lt;= Node.val &lt;= 10
         <sup>
          4
         </sup>
        </code>
       </li>
       <li>
        <code>
         root
        </code>
        is guaranteed to be a
        <strong>
         valid
        </strong>
        binary search tree.
       </li>
       <li>
        <code>
         -10
         <sup>
          5
         </sup>
         &lt;= k &lt;= 10
         <sup>
          5
         </sup>
        </code>
       </li>
      </ul>
      <h2 id="solution-1---set">
       Solution 1 - set
      </h2>
      <p>
       As long as it is the question of the sum of two numbers, you must remember to try to do it with
       <code class="language-plaintext highlighter-rouge">
        HashSet
       </code>
       .
      </p>
      <p>
       This question is just to turn the array into a binary tree. We need to traverse the binary tree and use a HashSet. In the recursive function function,
      </p>
      <ul>
       <li>
        if node is empty, return false.
       </li>
       <li>
        If k minus the current node value exists in the HashSet, return true directly;
       </li>
       <li>
        otherwise, add the current node value to the HashSet, and then call the recursive function on the left and right sub-nodes and return together.
       </li>
      </ul>
      <h2 id="solution-2---two-pointers">
       Solution 2 - two pointers
      </h2>
      <p>
       This solution defines two classes:
       <code class="language-plaintext highlighter-rouge">
        BSTIterator
       </code>
       and
       <code class="language-plaintext highlighter-rouge">
        Solution
       </code>
       . The
       <code class="language-plaintext highlighter-rouge">
        BSTIterator
       </code>
       class is designed to iterate through a binary search tree (BST) in either ascending (left-to-right) or descending (right-to-left) order. The
       <code class="language-plaintext highlighter-rouge">
        Solution
       </code>
       class uses two instances of
       <code class="language-plaintext highlighter-rouge">
        BSTIterator
       </code>
       to find if there exists two elements in the BST such that their sum equals a given target value
       <code class="language-plaintext highlighter-rouge">
        k
       </code>
       .
      </p>
      <h3 id="class-bstiterator">
       Class:
       <code class="language-plaintext highlighter-rouge">
        BSTIterator
       </code>
      </h3>
      <ul>
       <li>
        <p>
         <strong>
          Constructor
          <code class="language-plaintext highlighter-rouge">
           __init__
          </code>
         </strong>
         : Initializes the iterator with the root of a BST and a boolean flag
         <code class="language-plaintext highlighter-rouge">
          leftToRight
         </code>
         indicating the direction of iteration (ascending if
         <code class="language-plaintext highlighter-rouge">
          True
         </code>
         , descending if
         <code class="language-plaintext highlighter-rouge">
          False
         </code>
         ). It initializes an empty stack to facilitate controlled traversal of the BST and calls
         <code class="language-plaintext highlighter-rouge">
          _pushUntilNone
         </code>
         to preload the stack with the initial path from the root towards the leftmost or rightmost node, depending on the iteration direction.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Method
          <code class="language-plaintext highlighter-rouge">
           next
          </code>
         </strong>
         : Returns the next integer in the sequence. It pops the top element from the stack (which is the next element in order), then, depending on the iteration direction, traverses towards the next node in that order, pushing nodes encountered along the way onto the stack. This ensures that the stack always contains the nodes that maintain the current path in the tree relevant to the iteration order.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Method
          <code class="language-plaintext highlighter-rouge">
           _pushUntilNone
          </code>
         </strong>
         : Given a starting node, it iteratively traverses the tree towards the leftmost (for ascending order) or rightmost (for descending order) node, pushing all encountered nodes onto the stack. This method ensures that the next call to
         <code class="language-plaintext highlighter-rouge">
          next
         </code>
         will return the next correct value in the sequence.
        </p>
       </li>
      </ul>
      <h3 id="class-solution">
       Class:
       <code class="language-plaintext highlighter-rouge">
        Solution
       </code>
      </h3>
      <ul>
       <li>
        <strong>
         Method
         <code class="language-plaintext highlighter-rouge">
          findTarget
         </code>
        </strong>
        : This method checks if there are two numbers in the BST that add up to
        <code class="language-plaintext highlighter-rouge">
         k
        </code>
        . It initializes two
        <code class="language-plaintext highlighter-rouge">
         BSTIterator
        </code>
        instances, one for ascending order (
        <code class="language-plaintext highlighter-rouge">
         left
        </code>
        ) and one for descending order (
        <code class="language-plaintext highlighter-rouge">
         right
        </code>
        ). It then iterates through the BST from both ends simultaneously (smallest and largest values), comparing their sum to
        <code class="language-plaintext highlighter-rouge">
         k
        </code>
        .
        <ul>
         <li>
          If the sum equals
          <code class="language-plaintext highlighter-rouge">
           k
          </code>
          , it returns
          <code class="language-plaintext highlighter-rouge">
           True
          </code>
          .
         </li>
         <li>
          If the sum is less than
          <code class="language-plaintext highlighter-rouge">
           k
          </code>
          , it moves the
          <code class="language-plaintext highlighter-rouge">
           left
          </code>
          iterator to the next larger value.
         </li>
         <li>
          If the sum is greater than
          <code class="language-plaintext highlighter-rouge">
           k
          </code>
          , it moves the
          <code class="language-plaintext highlighter-rouge">
           right
          </code>
          iterator to the next smaller value.
         </li>
         <li>
          This process continues until the
          <code class="language-plaintext highlighter-rouge">
           left
          </code>
          value is no longer less than the
          <code class="language-plaintext highlighter-rouge">
           right
          </code>
          value, meaning the entire BST has been examined.
         </li>
        </ul>
       </li>
      </ul>
      <p>
       By approaching from both the smallest and largest values simultaneously and narrowing down the search space based on the sum comparison, this method efficiently determines whether any two elements in the BST add up to
       <code class="language-plaintext highlighter-rouge">
        k
       </code>
       .
      </p>
      <h3 id="example-scenario">
       Example Scenario
      </h3>
      <p>
       Consider a BST with elements
       <code class="language-plaintext highlighter-rouge">
        [2, 3, 4, 5, 6, 7]
       </code>
       and a target sum
       <code class="language-plaintext highlighter-rouge">
        k = 9
       </code>
       .
      </p>
      <ul>
       <li>
        The
        <code class="language-plaintext highlighter-rouge">
         left
        </code>
        iterator starts at
        <code class="language-plaintext highlighter-rouge">
         2
        </code>
        (the smallest value), and the
        <code class="language-plaintext highlighter-rouge">
         right
        </code>
        iterator starts at
        <code class="language-plaintext highlighter-rouge">
         7
        </code>
        (the largest value).
       </li>
       <li>
        Since their sum
        <code class="language-plaintext highlighter-rouge">
         2 + 7 = 9
        </code>
        equals
        <code class="language-plaintext highlighter-rouge">
         k
        </code>
        , the method immediately returns
        <code class="language-plaintext highlighter-rouge">
         True
        </code>
        .
       </li>
      </ul>
      <p>
       This approach effectively leverages the BST property (left child &lt; parent &lt; right child) and two-pointer technique to find the target sum with optimal efficiency.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#af7b7436-2c2a-456e-858f-63393d58d366'}">
       <li class="uk-active">
        <a href="solution-653.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-653.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-653.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-653.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-653.html">
         TypeScript
        </a>
       </li>
       <li>
        <a href="solution-653.html">
         RenderScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="af7b7436-2c2a-456e-858f-63393d58d366">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Two_Sum_IV_Input_is_a_BST</span> <span class="o">{</span>
    <span class="cm">/**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode(int x) { val = x; }
     * }
     */</span>

    <span class="c1">// https://leetcode.com/problems/two-sum-iv-input-is-a-bst/solution/</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution_queue</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">findTarget</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
            <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">))</span>
                        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// time: O(N)</span>
    <span class="c1">// space: O(N)</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution_usingBST</span> <span class="o">{</span> <span class="c1">// inorder traversal to get sorted list</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">findTarget</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">List</span><span class="o">&lt;</span> <span class="nc">Integer</span> <span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="n">inorder</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">list</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">+</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span>
                    <span class="n">l</span><span class="o">++;</span>
                <span class="k">else</span>
                    <span class="n">r</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">inorder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="nc">List</span> <span class="o">&lt;</span> <span class="nc">Integer</span> <span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="n">inorder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">list</span><span class="o">);</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="n">inorder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">list</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// time: O(N)</span>
    <span class="c1">// space: O(N)</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">findTarget</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Set</span> <span class="o">&lt;</span> <span class="nc">Integer</span> <span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">();</span>
            <span class="k">return</span> <span class="nf">find</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">set</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">find</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span> <span class="nc">Integer</span> <span class="o">&gt;</span> <span class="n">set</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

            <span class="k">return</span> <span class="nf">find</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">set</span><span class="o">)</span> <span class="o">||</span> <span class="n">find</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">set</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="c1">//////</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">vis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">k</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">findTarget</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">vis</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">vis</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">||</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">findTarget</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vis</span><span class="p">;</span>

        <span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">vis</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">vis</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">||</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="p">};</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">BSTIterator</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">leftToRight</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">leftToRight</span> <span class="o">=</span> <span class="n">leftToRight</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_pushUntilNone</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">leftToRight</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_pushUntilNone</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_pushUntilNone</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>

    <span class="c1"># if passed in a None node, then None will not be pushed to stack
</span>    <span class="k">def</span> <span class="nf">_pushUntilNone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]):</span>
        <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">leftToRight</span> <span class="k">else</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findTarget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="n">left</span> <span class="o">=</span> <span class="n">BSTIterator</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">BSTIterator</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="n">l</span> <span class="o">=</span> <span class="n">left</span><span class="p">.</span><span class="nb">next</span><span class="p">()</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">right</span><span class="p">.</span><span class="nb">next</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">summ</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span>
            <span class="k">if</span> <span class="n">summ</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">summ</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">left</span><span class="p">.</span><span class="nb">next</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">right</span><span class="p">.</span><span class="nb">next</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">False</span>

<span class="c1">###########
</span>
<span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findTarget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">-</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="ow">in</span> <span class="n">vis</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="n">vis</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">or</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

        <span class="n">vis</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */</span>
<span class="k">func</span> <span class="n">findTarget</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">,</span> <span class="n">k</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="n">vis</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span><span class="p">{}</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="kt">bool</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="no">false</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">vis</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="no">true</span>
		<span class="p">}</span>
		<span class="n">vis</span><span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="p">]</span> <span class="o">=</span> <span class="no">true</span>
		<span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span> <span class="o">||</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>

<span class="kd">function</span> <span class="nx">findTarget</span><span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">k</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="nx">boolean</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">vis</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">k</span> <span class="o">-</span> <span class="nx">root</span><span class="p">.</span><span class="nx">val</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">vis</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">val</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">||</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="kd">const</span> <span class="nx">vis</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-rs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1">// Definition for a binary tree node.</span>
<span class="c1">// #[derive(Debug, PartialEq, Eq)]</span>
<span class="c1">// pub struct TreeNode {</span>
<span class="c1">//   pub val: i32,</span>
<span class="c1">//   pub left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span>
<span class="c1">//   pub right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span>
<span class="c1">// }</span>
<span class="c1">//</span>
<span class="c1">// impl TreeNode {</span>
<span class="c1">//   #[inline]</span>
<span class="c1">//   pub fn new(val: i32) -&gt; Self {</span>
<span class="c1">//     TreeNode {</span>
<span class="c1">//       val,</span>
<span class="c1">//       left: None,</span>
<span class="c1">//       right: None</span>
<span class="c1">//     }</span>
<span class="c1">//   }</span>
<span class="c1">// }</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::{</span> <span class="n">HashSet</span><span class="p">,</span> <span class="n">VecDeque</span> <span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Solution</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">find_target</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">set</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">q</span> <span class="o">=</span> <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="n">q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow_mut</span><span class="p">();</span>
                <span class="k">if</span> <span class="n">set</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="py">.val</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">set</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">node</span><span class="py">.val</span><span class="p">);</span>
                <span class="n">q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">node</span><span class="py">.left</span><span class="nf">.take</span><span class="p">());</span>
                <span class="n">q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">node</span><span class="py">.right</span><span class="nf">.take</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-653.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
