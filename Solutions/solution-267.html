<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-267.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-267.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>267 - Palindrome Permutation II</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 267. Palindrome Permutation II Description Given a string s, return all the palindromic permutations (without duplicates) of it. You may return the answer in any order. If s has no palindromic permutation, return an empty list. &amp;nbsp; Example 1: Input: s = &quot;aabb&quot; Output: [&quot;abba&quot;,&quot;baab&quot;]...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-267.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-267.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-267.html" rel="stylesheet"/>
   <link href="solution-267.html" rel="stylesheet"/>
   <link href="solution-267.html" rel="stylesheet"/>
   <link href="solution-267.html" rel="stylesheet"/>
   <link href="solution-267.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="267 - Palindrome Permutation II" property="og:title"/>
   <meta content='Leetcode 267. Palindrome Permutation II Description Given a string s, return all the palindromic permutations (without duplicates) of it. You may return the answer in any order. If s has no palindromic permutation, return an empty list. &amp;nbsp; Example 1: Input: s = "aabb" Output: ["abba","baab"] Example 2: Input: s = "abc" Output: [] &amp;nbsp; Constraints: 1 &amp;lt;= s.length &amp;lt;= 16 s consists of only lowercase English letters. Solutions Key Concepts and Steps: Count Characters: The solution starts by counting the occurrences of each character in the input string s using Counter from the collections module. This step is crucial to determine if a palindromic permutation is possible and to construct the permutations. Check for Palindrome Possibility: A string can be permuted into a palindrome if at most one character has an odd count. The loop through cnt.items() checks for this condition. If more than one character has an odd count, it returns an empty list, as no palindromic permutation is possible. If exactly one character has an odd count, it is designated as the middle character (mid) of the palindrome. Depth-First Search (DFS): The dfs function is a recursive method that builds palindromic strings. It concatenates characters around a central mid string (which is empty or contains the single odd-count character). This function operates by: Adding a character c to both ends of the current string t if c has more than one occurrence left (v &amp;gt; 1). Reducing cnt[c] by 2 to account for using two instances of c. Recursively calling dfs with the updated string. Backtracking by restoring cnt[c] after the recursive call to explore other possibilities. Base Case and Collecting Results: When the length of the constructed string t matches the length of the input string s, a palindromic permutation has been completed, and it is added to the ans list. Initialization and First Call: Before calling dfs, the code handles the special case of the middle character for odd-length palindromes by decrementing its count and sets up the initial call to dfs with mid as the starting string. Important Observations: The solution efficiently constructs palindromic permutations by ensuring symmetry around the middle character. It leverages backtracking to explore all valid permutations without repeating characters more times than they occur in the input string. The check for if v &amp;amp; 1 uses bitwise AND to determine if v is odd, contributing to the determination of the middle character of the palindrome. The decrement cnt[c] -= 1 after finding the middle character ensures that when the DFS starts, the counts accurately reflect the characters available for constructing the two halves of the palindrome. ans.append(t) directly appends the constructed string t to ans without needing to copy it, as t is newly created in each recursive call. Complexity: The time complexity is difficult to determine precisely due to the recursive generation of permutations but is heavily influenced by the number of unique characters and their counts. The space complexity is primarily affected by the...' property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-08-23T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-08-23-267-Palindrome-Permutation-II/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-267.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="267 - Palindrome Permutation II" property="twitter:title"/>
   <meta content='Leetcode 267. Palindrome Permutation II Description Given a string s, return all the palindromic permutations (without duplicates) of it. You may return the answer in any order. If s has no palindromic permutation, return an empty list. &amp;nbsp; Example 1: Input: s = "aabb" Output: ["abba","baab"] Example 2: Input: s = "abc" Output: [] &amp;nbsp; Constraints: 1 &amp;lt;= s.length &amp;lt;= 16 s consists of only lowercase English letters. Solutions Key Concepts and Steps: Count Characters: The solution starts by counting the occurrences of each character in the input string s using Counter from the collections module. This step is crucial to determine if a palindromic permutation is possible and to construct the permutations. Check for Palindrome Possibility: A string can be permuted into a palindrome if at most one character has an odd count. The loop through cnt.items() checks for this condition. If more than one character has an odd count, it returns an empty list, as no palindromic permutation is possible. If exactly one character has an odd count, it is designated as the middle character (mid) of the palindrome. Depth-First Search (DFS): The dfs function is a recursive method that builds palindromic strings. It concatenates characters around a central mid string (which is empty or contains the single odd-count character). This function operates by: Adding a character c to both ends of the current string t if c has more than one occurrence left (v &amp;gt; 1). Reducing cnt[c] by 2 to account for using two instances of c. Recursively calling dfs with the updated string. Backtracking by restoring cnt[c] after the recursive call to explore other possibilities. Base Case and Collecting Results: When the length of the constructed string t matches the length of the input string s, a palindromic permutation has been completed, and it is added to the ans list. Initialization and First Call: Before calling dfs, the code handles the special case of the middle character for odd-length palindromes by decrementing its count and sets up the initial call to dfs with mid as the starting string. Important Observations: The solution efficiently constructs palindromic permutations by ensuring symmetry around the middle character. It leverages backtracking to explore all valid permutations without repeating characters more times than they occur in the input string. The check for if v &amp;amp; 1 uses bitwise AND to determine if v is odd, contributing to the determination of the middle character of the palindrome. The decrement cnt[c] -= 1 after finding the middle character ensures that when the DFS starts, the counts accurately reflect the characters available for constructing the two halves of the palindrome. ans.append(t) directly appends the constructed string t to ans without needing to copy it, as t is newly created in each recursive call. Complexity: The time complexity is difficult to determine precisely due to the recursive generation of permutations but is heavily influenced by the number of unique characters and their counts. The space complexity is primarily affected by the...' property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    267 - Palindrome Permutation II | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="267 - Palindrome Permutation II" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-267.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-08-23-267-Palindrome-Permutation-II/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-08-23T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"267 - Palindrome Permutation II","dateModified":"2016-08-23T00:00:00-07:00","datePublished":"2016-08-23T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-08-23-267-Palindrome-Permutation-II/"},"url":"https://leetcode.ca/2016-08-23-267-Palindrome-Permutation-II/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="267-palindrome-permutation-ii">
       <a href="solution-267.html">
        267. Palindrome Permutation II
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given a string s, return
       <em>
        all the palindromic permutations (without duplicates) of it
       </em>
       .
      </p>
      <p>
       You may return the answer in
       <strong>
        any order
       </strong>
       . If
       <code>
        s
       </code>
       has no palindromic permutation, return an empty list.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre><strong>Input:</strong> s = "aabb"
<strong>Output:</strong> ["abba","baab"]
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre><strong>Input:</strong> s = "abc"
<strong>Output:</strong> []
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= s.length &lt;= 16
        </code>
       </li>
       <li>
        <code>
         s
        </code>
        consists of only lowercase English letters.
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <h3 id="key-concepts-and-steps">
       Key Concepts and Steps:
      </h3>
      <ol>
       <li>
        <p>
         <strong>
          Count Characters
         </strong>
         : The solution starts by counting the occurrences of each character in the input string
         <code class="language-plaintext highlighter-rouge">
          s
         </code>
         using
         <code class="language-plaintext highlighter-rouge">
          Counter
         </code>
         from the
         <code class="language-plaintext highlighter-rouge">
          collections
         </code>
         module. This step is crucial to determine if a palindromic permutation is possible and to construct the permutations.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Check for Palindrome Possibility
         </strong>
         : A string can be permuted into a palindrome if at most one character has an odd count. The loop through
         <code class="language-plaintext highlighter-rouge">
          cnt.items()
         </code>
         checks for this condition. If more than one character has an odd count, it returns an empty list, as no palindromic permutation is possible. If exactly one character has an odd count, it is designated as the middle character (
         <code class="language-plaintext highlighter-rouge">
          mid
         </code>
         ) of the palindrome.
        </p>
       </li>
       <li>
        <strong>
         Depth-First Search (DFS)
        </strong>
        : The
        <code class="language-plaintext highlighter-rouge">
         dfs
        </code>
        function is a recursive method that builds palindromic strings. It concatenates characters around a central
        <code class="language-plaintext highlighter-rouge">
         mid
        </code>
        string (which is empty or contains the single odd-count character). This function operates by:
        <ul>
         <li>
          Adding a character
          <code class="language-plaintext highlighter-rouge">
           c
          </code>
          to both ends of the current string
          <code class="language-plaintext highlighter-rouge">
           t
          </code>
          if
          <code class="language-plaintext highlighter-rouge">
           c
          </code>
          has more than one occurrence left (
          <code class="language-plaintext highlighter-rouge">
           v &gt; 1
          </code>
          ).
         </li>
         <li>
          Reducing
          <code class="language-plaintext highlighter-rouge">
           cnt[c]
          </code>
          by 2 to account for using two instances of
          <code class="language-plaintext highlighter-rouge">
           c
          </code>
          .
         </li>
         <li>
          Recursively calling
          <code class="language-plaintext highlighter-rouge">
           dfs
          </code>
          with the updated string.
         </li>
         <li>
          Backtracking by restoring
          <code class="language-plaintext highlighter-rouge">
           cnt[c]
          </code>
          after the recursive call to explore other possibilities.
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          Base Case and Collecting Results
         </strong>
         : When the length of the constructed string
         <code class="language-plaintext highlighter-rouge">
          t
         </code>
         matches the length of the input string
         <code class="language-plaintext highlighter-rouge">
          s
         </code>
         , a palindromic permutation has been completed, and it is added to the
         <code class="language-plaintext highlighter-rouge">
          ans
         </code>
         list.
        </p>
       </li>
       <li>
        <strong>
         Initialization and First Call
        </strong>
        : Before calling
        <code class="language-plaintext highlighter-rouge">
         dfs
        </code>
        , the code handles the special case of the middle character for odd-length palindromes by decrementing its count and sets up the initial call to
        <code class="language-plaintext highlighter-rouge">
         dfs
        </code>
        with
        <code class="language-plaintext highlighter-rouge">
         mid
        </code>
        as the starting string.
       </li>
      </ol>
      <h3 id="important-observations">
       Important Observations:
      </h3>
      <ul>
       <li>
        The solution efficiently constructs palindromic permutations by ensuring symmetry around the middle character.
       </li>
       <li>
        It leverages backtracking to explore all valid permutations without repeating characters more times than they occur in the input string.
       </li>
       <li>
        The check for
        <code class="language-plaintext highlighter-rouge">
         if v &amp; 1
        </code>
        uses bitwise AND to determine if
        <code class="language-plaintext highlighter-rouge">
         v
        </code>
        is odd, contributing to the determination of the middle character of the palindrome.
       </li>
       <li>
        The decrement
        <code class="language-plaintext highlighter-rouge">
         cnt[c] -= 1
        </code>
        after finding the middle character ensures that when the DFS starts, the counts accurately reflect the characters available for constructing the two halves of the palindrome.
       </li>
       <li>
        <code class="language-plaintext highlighter-rouge">
         ans.append(t)
        </code>
        directly appends the constructed string
        <code class="language-plaintext highlighter-rouge">
         t
        </code>
        to
        <code class="language-plaintext highlighter-rouge">
         ans
        </code>
        without needing to copy it, as
        <code class="language-plaintext highlighter-rouge">
         t
        </code>
        is newly created in each recursive call.
       </li>
      </ul>
      <h3 id="complexity">
       Complexity:
      </h3>
      <ul>
       <li>
        The time complexity is difficult to determine precisely due to the recursive generation of permutations but is heavily influenced by the number of unique characters and their counts.
       </li>
       <li>
        The space complexity is primarily affected by the storage of the palindromic permutations in
        <code class="language-plaintext highlighter-rouge">
         ans
        </code>
        , which can grow exponentially with the size of the input string for certain distributions of characters.
       </li>
      </ul>
      <ul class="uk-tab" data-uk-switcher="{connect:'#fd2fb4e3-f882-46cf-8caa-56a59efdcdb0'}">
       <li class="uk-active">
        <a href="solution-267.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-267.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-267.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-267.html">
         Go
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="fd2fb4e3-f882-46cf-8caa-56a59efdcdb0">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">generatePalindromes</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="o">++</span><span class="n">cnt</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="nc">String</span> <span class="n">mid</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cnt</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(!</span><span class="s">""</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">mid</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">mid</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="sc">'a'</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">mid</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cnt</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">c</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="sc">'a'</span><span class="o">));</span>
                <span class="n">cnt</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">;</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">t</span> <span class="o">+</span> <span class="n">c</span><span class="o">);</span>
                <span class="n">cnt</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">cnt</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">generatePalindromes</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="p">)</span> <span class="o">++</span><span class="n">cnt</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
        <span class="n">string</span> <span class="n">mid</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="o">:</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">!=</span> <span class="s">""</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">mid</span> <span class="o">+=</span> <span class="n">k</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="o">:</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">v</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">t</span> <span class="o">+</span> <span class="n">k</span><span class="p">);</span>
                <span class="n">v</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="s">'''
&gt;&gt;&gt; "sss".copy()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'str' object has no attribute 'copy'
'''</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">generatePalindromes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1"># not using t.copy()
</span>                <span class="k">return</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cnt</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">cnt</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">t</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span>
                    <span class="n">cnt</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span>

        <span class="n">cnt</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="s">''</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cnt</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mid</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[]</span>
                <span class="n">mid</span> <span class="o">=</span> <span class="n">c</span>
                <span class="n">cnt</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1"># don't forget this
</span>                <span class="c1"># actually, above is cheking 'if v &gt; 1:', so good without this line
</span>        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">generatePalindromes</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="n">cnt</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">byte</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
		<span class="n">cnt</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="n">mid</span> <span class="o">:=</span> <span class="s">""</span>
	<span class="n">ans</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
	<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">cnt</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">v</span><span class="o">%</span><span class="m">2</span> <span class="o">==</span> <span class="m">1</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">mid</span> <span class="o">!=</span> <span class="s">""</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">ans</span>
			<span class="p">}</span>
			<span class="n">mid</span> <span class="o">=</span> <span class="kt">string</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="n">t</span> <span class="kt">string</span><span class="p">)</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">t</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ans</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">cnt</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="m">1</span> <span class="p">{</span>
				<span class="n">cnt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-=</span> <span class="m">2</span>
				<span class="n">c</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
				<span class="n">dfs</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">t</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span>
				<span class="n">cnt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="m">2</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">dfs</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">ans</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-267.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
