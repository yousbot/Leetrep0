<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-1650.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-1650.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>1650 - Lowest Common Ancestor of a Binary Tree III</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode Formatted question description: https://leetcode.ca/all/1650.html 1650. Lowest Common Ancestor of a Binary Tree III Level Medium Description Given two nodes of a binary tree p and q, return their lowest common ancestor (LCA). Each node will have a reference to its parent node. The definition for...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-1650.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-1650.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-1650.html" rel="stylesheet"/>
   <link href="solution-1650.html" rel="stylesheet"/>
   <link href="solution-1650.html" rel="stylesheet"/>
   <link href="solution-1650.html" rel="stylesheet"/>
   <link href="solution-1650.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="1650 - Lowest Common Ancestor of a Binary Tree III" property="og:title"/>
   <meta content="Leetcode Formatted question description: https://leetcode.ca/all/1650.html 1650. Lowest Common Ancestor of a Binary Tree III Level Medium Description Given two nodes of a binary tree p and q, return their lowest common ancestor (LCA). Each node will have a reference to its parent node. The definition for Node is below: class Node { public int val; public Node left; public Node right; public Node parent; } According to the definition of LCA on Wikipedia: âThe lowest common ancestor of two nodes p and q in a tree T is the lowest node that has both p and q as descendants (where we allow a node to be a descendant of itself).â Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5 since a node can be a descendant of itself according to the LCA definition. Example 3: Input: root = [1,2], p = 1, q = 2 Output: 1 Constraints: The number of nodes in the tree is in the range [2, 10^5]. -10^9 &amp;lt;= Node.val &amp;lt;= 10^9 All Node.val are unique. p != q p and q exist in the tree. Solution - Set Use a set to store nodes. Start from p and obtain all the nodes from p to the root node using the nodesâ parents. Then start from q and move towards the root. If a node is already in the set, then the node is a common ancestor of p and q. The first common ancestor that is in the set is the lowest common ancestor of p and q. Solution - 2 pointers The idea is as follows: we will use 2 pointers (pointerA, pointerB) that go from nodeA and nodeB upwards respectively. Assume nodeA locates at a shallower level than nodeB, i.e. depth(nodeA) &amp;lt; depth(nodeB), pointerA will reach the top quicker than pointerB. Suppose the difference in depth between nodeA and nodeB is diff. By the time pointerA reaches the top, pointerB will be diff levels behind. Now if pointerA resets its path and continues upwards from nodeB instead of nodeA, it will need diff steps to reach the level of nodeA, by which time pointerB has already caught up and will be at the same level of pointerA (pointerB restarts from nodeA after reaching the top). Now the only thing to do is to compare pointerA and pointerB on the way up. If pointerA and pointerB points to the same node, weâve found the lowest common ancestor. Java C++ Python Go TypeScript /* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node parent; }; */ class Solution { public Node lowestCommonAncestor(Node p, Node q) { Set&amp;lt;Node&amp;gt; set = new HashSet&amp;lt;Node&amp;gt;(); Node temp = p; while (temp != null) { set.add(temp); temp..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2020-06-06T22:21:01-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2020-06-06-1650-Lowest-Common-Ancestor-of-a-Binary-Tree-III/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-1650.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="1650 - Lowest Common Ancestor of a Binary Tree III" property="twitter:title"/>
   <meta content="Leetcode Formatted question description: https://leetcode.ca/all/1650.html 1650. Lowest Common Ancestor of a Binary Tree III Level Medium Description Given two nodes of a binary tree p and q, return their lowest common ancestor (LCA). Each node will have a reference to its parent node. The definition for Node is below: class Node { public int val; public Node left; public Node right; public Node parent; } According to the definition of LCA on Wikipedia: âThe lowest common ancestor of two nodes p and q in a tree T is the lowest node that has both p and q as descendants (where we allow a node to be a descendant of itself).â Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5 since a node can be a descendant of itself according to the LCA definition. Example 3: Input: root = [1,2], p = 1, q = 2 Output: 1 Constraints: The number of nodes in the tree is in the range [2, 10^5]. -10^9 &amp;lt;= Node.val &amp;lt;= 10^9 All Node.val are unique. p != q p and q exist in the tree. Solution - Set Use a set to store nodes. Start from p and obtain all the nodes from p to the root node using the nodesâ parents. Then start from q and move towards the root. If a node is already in the set, then the node is a common ancestor of p and q. The first common ancestor that is in the set is the lowest common ancestor of p and q. Solution - 2 pointers The idea is as follows: we will use 2 pointers (pointerA, pointerB) that go from nodeA and nodeB upwards respectively. Assume nodeA locates at a shallower level than nodeB, i.e. depth(nodeA) &amp;lt; depth(nodeB), pointerA will reach the top quicker than pointerB. Suppose the difference in depth between nodeA and nodeB is diff. By the time pointerA reaches the top, pointerB will be diff levels behind. Now if pointerA resets its path and continues upwards from nodeB instead of nodeA, it will need diff steps to reach the level of nodeA, by which time pointerB has already caught up and will be at the same level of pointerA (pointerB restarts from nodeA after reaching the top). Now the only thing to do is to compare pointerA and pointerB on the way up. If pointerA and pointerB points to the same node, weâve found the lowest common ancestor. Java C++ Python Go TypeScript /* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node parent; }; */ class Solution { public Node lowestCommonAncestor(Node p, Node q) { Set&amp;lt;Node&amp;gt; set = new HashSet&amp;lt;Node&amp;gt;(); Node temp = p; while (temp != null) { set.add(temp); temp..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    1650 - Lowest Common Ancestor of a Binary Tree III | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="1650 - Lowest Common Ancestor of a Binary Tree III" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-1650.html" rel="canonical">
          <meta content="https://leetcode.ca/2020-06-06-1650-Lowest-Common-Ancestor-of-a-Binary-Tree-III/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2020-06-06T22:21:01-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"1650 - Lowest Common Ancestor of a Binary Tree III","dateModified":"2020-06-06T22:21:01-07:00","datePublished":"2020-06-06T22:21:01-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2020-06-06-1650-Lowest-Common-Ancestor-of-a-Binary-Tree-III/"},"url":"https://leetcode.ca/2020-06-06-1650-Lowest-Common-Ancestor-of-a-Binary-Tree-III/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <p>
       Formatted question description:
       <a href="solution-1650.html">
        https://leetcode.ca/all/1650.html
       </a>
      </p>
      <h1 id="1650-lowest-common-ancestor-of-a-binary-tree-iii">
       1650. Lowest Common Ancestor of a Binary Tree III
      </h1>
      <h2 id="level">
       Level
      </h2>
      <p>
       Medium
      </p>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given two nodes of a binary tree
       <code class="language-plaintext highlighter-rouge">
        p
       </code>
       and
       <code class="language-plaintext highlighter-rouge">
        q
       </code>
       , return
       <em>
        their lowest common ancestor (LCA)
       </em>
       .
      </p>
      <p>
       Each node will have a reference to its parent node. The definition for
       <code class="language-plaintext highlighter-rouge">
        Node
       </code>
       is below:
      </p>
      <div class="language-plaintext highlighter-rouge">
       <div class="highlight">
        <pre class="highlight"><code>class Node {
    public int val;
    public Node left;
    public Node right;
    public Node parent;
}
</code></pre>
       </div>
      </div>
      <p>
       According to the
       <strong>
        <a href="solution-1650.html">
         definition of LCA on Wikipedia
        </a>
       </strong>
       : âThe lowest common ancestor of two nodes p and q in a tree T is the lowest node that has both p and q as descendants (where we allow
       <strong>
        a node to be a descendant of itself
       </strong>
       ).â
      </p>
      <p>
       <strong>
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="Image text" src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png"/>
      </p>
      <p>
       <strong>
        Input:
       </strong>
       root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
      </p>
      <p>
       <strong>
        Output:
       </strong>
       3
      </p>
      <p>
       <strong>
        Explanation:
       </strong>
       The LCA of nodes 5 and 1 is 3.
      </p>
      <p>
       <strong>
        Example 2:
       </strong>
      </p>
      <p>
       <img alt="Image text" src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png"/>
      </p>
      <p>
       <strong>
        Input:
       </strong>
       root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
      </p>
      <p>
       <strong>
        Output:
       </strong>
       5
      </p>
      <p>
       <strong>
        Explanation:
       </strong>
       The LCA of nodes 5 and 4 is 5 since a node can be a descendant of itself according to the LCA definition.
      </p>
      <p>
       <strong>
        Example 3:
       </strong>
      </p>
      <p>
       <strong>
        Input:
       </strong>
       root = [1,2], p = 1, q = 2
      </p>
      <p>
       <strong>
        Output:
       </strong>
       1
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the tree is in the range
        <code class="language-plaintext highlighter-rouge">
         [2, 10^5]
        </code>
        .
       </li>
       <li>
        <code class="language-plaintext highlighter-rouge">
         -10^9 &lt;= Node.val &lt;= 10^9
        </code>
       </li>
       <li>
        All
        <code class="language-plaintext highlighter-rouge">
         Node.val
        </code>
        are
        <strong>
         unique
        </strong>
        .
       </li>
       <li>
        <code class="language-plaintext highlighter-rouge">
         p != q
        </code>
       </li>
       <li>
        <code class="language-plaintext highlighter-rouge">
         p
        </code>
        and
        <code class="language-plaintext highlighter-rouge">
         q
        </code>
        exist in the tree.
       </li>
      </ul>
      <h2 id="solution---set">
       Solution - Set
      </h2>
      <p>
       Use a set to store nodes. Start from
       <code class="language-plaintext highlighter-rouge">
        p
       </code>
       and obtain all the nodes from
       <code class="language-plaintext highlighter-rouge">
        p
       </code>
       to the root node using the nodesâ parents. Then start from
       <code class="language-plaintext highlighter-rouge">
        q
       </code>
       and move towards the root. If a node is already in the set, then the node is a common ancestor of
       <code class="language-plaintext highlighter-rouge">
        p
       </code>
       and
       <code class="language-plaintext highlighter-rouge">
        q
       </code>
       . The first common ancestor that is in the set is the lowest common ancestor of
       <code class="language-plaintext highlighter-rouge">
        p
       </code>
       and
       <code class="language-plaintext highlighter-rouge">
        q
       </code>
       .
      </p>
      <h2 id="solution---2-pointers">
       Solution - 2 pointers
      </h2>
      <p>
       The idea is as follows: we will use
       <code class="language-plaintext highlighter-rouge">
        2 pointers
       </code>
       (pointerA, pointerB) that go from nodeA and nodeB
       <code class="language-plaintext highlighter-rouge">
        upwards
       </code>
       respectively. Assume nodeA locates at a shallower level than nodeB, i.e. depth(nodeA) &lt; depth(nodeB), pointerA will reach the top quicker than pointerB.
      </p>
      <p>
       Suppose the difference in depth between nodeA and nodeB is
       <code class="language-plaintext highlighter-rouge">
        diff
       </code>
       .
      </p>
      <p>
       By the time pointerA reaches the top, pointerB will be
       <code class="language-plaintext highlighter-rouge">
        diff
       </code>
       levels behind. Now if pointerA resets its path and continues upwards from nodeB instead of nodeA, it will need
       <code class="language-plaintext highlighter-rouge">
        diff
       </code>
       steps to reach the level of nodeA, by which time pointerB has already caught up and will be at the
       <code class="language-plaintext highlighter-rouge">
        same level of pointerA
       </code>
       (pointerB restarts from nodeA after reaching the top).
      </p>
      <p>
       Now the only thing to do is to compare pointerA and pointerB on the way up. If pointerA and pointerB
       <code class="language-plaintext highlighter-rouge">
        points to the same node
       </code>
       , weâve found the
       <code class="language-plaintext highlighter-rouge">
        lowest common ancestor
       </code>
       .
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#ba2cd4ba-7cc8-49f9-87a2-f286feda26f9'}">
       <li class="uk-active">
        <a href="solution-1650.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-1650.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-1650.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-1650.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-1650.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="ba2cd4ba-7cc8-49f9-87a2-f286feda26f9">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node parent;
};
*/</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">lowestCommonAncestor</span><span class="o">(</span><span class="nc">Node</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;();</span>
        <span class="nc">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="na">parent</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">q</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">temp</span><span class="o">))</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="na">parent</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="err">############</span>

<span class="cm">/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node parent;
};
*/</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">lowestCommonAncestor</span><span class="o">(</span><span class="nc">Node</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="o">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">q</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">parent</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">q</span> <span class="o">:</span> <span class="n">a</span><span class="o">.</span><span class="na">parent</span><span class="o">;</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="na">parent</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">p</span> <span class="o">:</span> <span class="n">b</span><span class="o">.</span><span class="na">parent</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1">// OJ: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/</span>
<span class="c1">// Time: O(N)</span>
<span class="c1">// Space: O(1)</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">getLength</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="o">++</span><span class="n">ans</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">public:</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">getLength</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">b</span> <span class="o">=</span> <span class="n">getLength</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">swap</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
        <span class="n">a</span> <span class="o">-=</span> <span class="n">b</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">a</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">q</span><span class="p">)</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-python highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="s">"""
# Definition for a Node.
class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.parent = None
"""</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="s">'Node'</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="s">'Node'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s">'Node'</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span>
        <span class="k">while</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">parent</span> <span class="k">if</span> <span class="n">a</span><span class="p">.</span><span class="n">parent</span> <span class="k">else</span> <span class="n">q</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">parent</span> <span class="k">if</span> <span class="n">b</span><span class="p">.</span><span class="n">parent</span> <span class="k">else</span> <span class="n">p</span>
        <span class="k">return</span> <span class="n">a</span>

<span class="c1">############
</span>
<span class="c1"># ref: https://iamageek.medium.com/leetcode-1650-lowest-common-ancestor-of-a-binary-tree-iii-6d008b93376c
</span>
<span class="k">def</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="s">'Node'</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s">'Node'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s">'Node'</span><span class="p">:</span>
    <span class="n">ancestors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">ancestors</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">parent</span>

    <span class="k">while</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ancestors</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">parent</span>

<span class="c1"># or another one
</span><span class="k">def</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="s">'Node'</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s">'Node'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s">'Node'</span><span class="p">:</span>
    <span class="n">pointerA</span><span class="p">,</span> <span class="n">pointerB</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>

    <span class="k">while</span> <span class="n">pointerA</span> <span class="o">!=</span> <span class="n">pointerB</span><span class="p">:</span>
        <span class="n">pointerA</span> <span class="o">=</span> <span class="n">pointerA</span><span class="p">.</span><span class="n">parent</span> <span class="k">if</span> <span class="n">pointerA</span> <span class="k">else</span> <span class="n">b</span>
        <span class="n">pointerB</span> <span class="o">=</span> <span class="n">pointerB</span><span class="p">.</span><span class="n">parent</span> <span class="k">if</span> <span class="n">pointerA</span> <span class="k">else</span> <span class="n">a</span>

    <span class="k">return</span> <span class="n">pointerA</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for Node.
 * type Node struct {
 *     Val int
 *     Left *Node
 *     Right *Node
 *     Parent *Node
 * }
 */</span>

<span class="k">func</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Node</span><span class="p">,</span> <span class="n">q</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="o">*</span><span class="n">Node</span> <span class="p">{</span>
	<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span>
	<span class="k">for</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">Parent</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">Parent</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">a</span> <span class="o">=</span> <span class="n">q</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">Parent</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">Parent</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">p</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">a</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * class Node {
 *     val: number
 *     left: Node | null
 *     right: Node | null
 *     parent: Node | null
 *     constructor(val?: number, left?: Node | null, right?: Node | null, parent?: Node | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *         this.parent = (parent===undefined ? null : parent)
 *     }
 * }
 */</span>

<span class="kd">function</span> <span class="nx">lowestCommonAncestor</span><span class="p">(</span><span class="nx">p</span><span class="p">:</span> <span class="nx">Node</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">q</span><span class="p">:</span> <span class="nx">Node</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="nx">Node</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">vis</span><span class="p">:</span> <span class="nb">Set</span><span class="o">&lt;</span><span class="nx">Node</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span> <span class="nx">node</span><span class="p">;</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">parent</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">vis</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">q</span><span class="p">;</span> <span class="p">;</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">parent</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">vis</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">node</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-1650.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
