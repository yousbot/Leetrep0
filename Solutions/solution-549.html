<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-549.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-549.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>549 - Binary Tree Longest Consecutive Sequence II</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 549. Binary Tree Longest Consecutive Sequence II Description Given the root of a binary tree, return the length of the longest consecutive path in the tree. A consecutive path is a path where the values of the consecutive nodes in the path differ by one....">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-549.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-549.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-549.html" rel="stylesheet"/>
   <link href="solution-549.html" rel="stylesheet"/>
   <link href="solution-549.html" rel="stylesheet"/>
   <link href="solution-549.html" rel="stylesheet"/>
   <link href="solution-549.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="549 - Binary Tree Longest Consecutive Sequence II" property="og:title"/>
   <meta content="Leetcode 549. Binary Tree Longest Consecutive Sequence II Description Given the root of a binary tree, return the length of the longest consecutive path in the tree. A consecutive path is a path where the values of the consecutive nodes in the path differ by one. This path can be either increasing or decreasing. For example, [1,2,3,4] and [4,3,2,1] are both considered valid, but the path [1,2,4,3] is not valid. On the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order. &amp;nbsp; Example 1: Input: root = [1,2,3] Output: 2 Explanation: The longest consecutive path is [1, 2] or [2, 1]. Example 2: Input: root = [2,1,3] Output: 3 Explanation: The longest consecutive path is [1, 2, 3] or [3, 2, 1]. &amp;nbsp; Constraints: The number of nodes in the tree is in the range [1, 3 * 104]. -3 * 104 &amp;lt;= Node.val &amp;lt;= 3 * 104 Solutions Approach Overview The solution employs Depth-First Search (DFS) to traverse the tree. At each node, it calculates two things: The length of the longest increasing consecutive path (incr) ending at that node. The length of the longest decreasing consecutive path (decr) ending at that node. It returns these lengths as a pair [incr, decr] for each node. The overall longest path that can be formed is the sum of increasing and decreasing paths minus 1 (to avoid double-counting the current node) at any node. This sum is tracked globally using the variable ans. DFS Function Details Base Case: If the current node (root) is None, it returns [0, 0] indicating no consecutive path. Recursive Case: It initializes incr and decr to 1 for the current node since a node on its own forms a consecutive sequence of length 1. It then recursively calls dfs on both the left and right children of the current node, receiving their respective longest increasing and decreasing paths as [i1, d1] and [i2, d2]. For both children, it checks if the childâs value forms a consecutive sequence with the current node (root.val). If so, it updates incr or decr accordingly. If the left childâs value is one less than the current nodeâs value, incr is incremented; if itâs one more, decr is incremented. The same logic applies to the right child, with the additional step of taking the maximum between the current value of incr or decr and the value obtained from the right child. This ensures that we consider the longest path possible. It updates the global ans variable with the maximum value found so far. ans is calculated as the sum of incr and decr minus 1 (since the root node is counted in both incr and decr, it should be subtracted once to get the actual length of the path). Global Variable ans ans is used to track the maximum length of the consecutive path found at any point during the traversal of the tree. It is marked as nonlocal within the..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2017-06-01T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2017-06-01-549-Binary-Tree-Longest-Consecutive-Sequence-II/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-549.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="549 - Binary Tree Longest Consecutive Sequence II" property="twitter:title"/>
   <meta content="Leetcode 549. Binary Tree Longest Consecutive Sequence II Description Given the root of a binary tree, return the length of the longest consecutive path in the tree. A consecutive path is a path where the values of the consecutive nodes in the path differ by one. This path can be either increasing or decreasing. For example, [1,2,3,4] and [4,3,2,1] are both considered valid, but the path [1,2,4,3] is not valid. On the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order. &amp;nbsp; Example 1: Input: root = [1,2,3] Output: 2 Explanation: The longest consecutive path is [1, 2] or [2, 1]. Example 2: Input: root = [2,1,3] Output: 3 Explanation: The longest consecutive path is [1, 2, 3] or [3, 2, 1]. &amp;nbsp; Constraints: The number of nodes in the tree is in the range [1, 3 * 104]. -3 * 104 &amp;lt;= Node.val &amp;lt;= 3 * 104 Solutions Approach Overview The solution employs Depth-First Search (DFS) to traverse the tree. At each node, it calculates two things: The length of the longest increasing consecutive path (incr) ending at that node. The length of the longest decreasing consecutive path (decr) ending at that node. It returns these lengths as a pair [incr, decr] for each node. The overall longest path that can be formed is the sum of increasing and decreasing paths minus 1 (to avoid double-counting the current node) at any node. This sum is tracked globally using the variable ans. DFS Function Details Base Case: If the current node (root) is None, it returns [0, 0] indicating no consecutive path. Recursive Case: It initializes incr and decr to 1 for the current node since a node on its own forms a consecutive sequence of length 1. It then recursively calls dfs on both the left and right children of the current node, receiving their respective longest increasing and decreasing paths as [i1, d1] and [i2, d2]. For both children, it checks if the childâs value forms a consecutive sequence with the current node (root.val). If so, it updates incr or decr accordingly. If the left childâs value is one less than the current nodeâs value, incr is incremented; if itâs one more, decr is incremented. The same logic applies to the right child, with the additional step of taking the maximum between the current value of incr or decr and the value obtained from the right child. This ensures that we consider the longest path possible. It updates the global ans variable with the maximum value found so far. ans is calculated as the sum of incr and decr minus 1 (since the root node is counted in both incr and decr, it should be subtracted once to get the actual length of the path). Global Variable ans ans is used to track the maximum length of the consecutive path found at any point during the traversal of the tree. It is marked as nonlocal within the..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    549 - Binary Tree Longest Consecutive Sequence II | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="549 - Binary Tree Longest Consecutive Sequence II" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-549.html" rel="canonical">
          <meta content="https://leetcode.ca/2017-06-01-549-Binary-Tree-Longest-Consecutive-Sequence-II/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2017-06-01T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"549 - Binary Tree Longest Consecutive Sequence II","dateModified":"2017-06-01T00:00:00-07:00","datePublished":"2017-06-01T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2017-06-01-549-Binary-Tree-Longest-Consecutive-Sequence-II/"},"url":"https://leetcode.ca/2017-06-01-549-Binary-Tree-Longest-Consecutive-Sequence-II/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="549-binary-tree-longest-consecutive-sequence-ii">
       <a href="solution-549.html">
        549. Binary Tree Longest Consecutive Sequence II
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given the
       <code>
        root
       </code>
       of a binary tree, return
       <em>
        the length of the longest consecutive path in the tree
       </em>
       .
      </p>
      <p>
       A consecutive path is a path where the values of the consecutive nodes in the path differ by one. This path can be either increasing or decreasing.
      </p>
      <ul>
       <li>
        For example,
        <code>
         [1,2,3,4]
        </code>
        and
        <code>
         [4,3,2,1]
        </code>
        are both considered valid, but the path
        <code>
         [1,2,4,3]
        </code>
        is not valid.
       </li>
      </ul>
      <p>
       On the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0549.Binary%20Tree%20Longest%20Consecutive%20Sequence%20II/images/consec2-1-tree.jpg" style="width: 207px; height: 183px;"/>
      </p>
      <pre>
<strong>Input:</strong> root = [1,2,3]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The longest consecutive path is [1, 2] or [2, 1].
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0549.Binary%20Tree%20Longest%20Consecutive%20Sequence%20II/images/consec2-2-tree.jpg" style="width: 207px; height: 183px;"/>
      </p>
      <pre>
<strong>Input:</strong> root = [2,1,3]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The longest consecutive path is [1, 2, 3] or [3, 2, 1].
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the tree is in the range
        <code>
         [1, 3 * 10
         <sup>
          4
         </sup>
         ]
        </code>
        .
       </li>
       <li>
        <code>
         -3 * 10
         <sup>
          4
         </sup>
         &lt;= Node.val &lt;= 3 * 10
         <sup>
          4
         </sup>
        </code>
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <h3 id="approach-overview">
       Approach Overview
      </h3>
      <p>
       The solution employs Depth-First Search (DFS) to traverse the tree. At each node, it calculates two things:
      </p>
      <ul>
       <li>
        The length of the longest increasing consecutive path (
        <code class="language-plaintext highlighter-rouge">
         incr
        </code>
        ) ending at that node.
       </li>
       <li>
        The length of the longest decreasing consecutive path (
        <code class="language-plaintext highlighter-rouge">
         decr
        </code>
        ) ending at that node.
       </li>
      </ul>
      <p>
       It returns these lengths as a pair
       <code class="language-plaintext highlighter-rouge">
        [incr, decr]
       </code>
       for each node. The overall longest path that can be formed is the sum of increasing and decreasing paths minus 1 (to avoid double-counting the current node) at any node. This sum is tracked globally using the variable
       <code class="language-plaintext highlighter-rouge">
        ans
       </code>
       .
      </p>
      <h3 id="dfs-function-details">
       DFS Function Details
      </h3>
      <ul>
       <li>
        <p>
         <strong>
          Base Case
         </strong>
         : If the current node (
         <code class="language-plaintext highlighter-rouge">
          root
         </code>
         ) is
         <code class="language-plaintext highlighter-rouge">
          None
         </code>
         , it returns
         <code class="language-plaintext highlighter-rouge">
          [0, 0]
         </code>
         indicating no consecutive path.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Recursive Case
         </strong>
         :
        </p>
        <ul>
         <li>
          It initializes
          <code class="language-plaintext highlighter-rouge">
           incr
          </code>
          and
          <code class="language-plaintext highlighter-rouge">
           decr
          </code>
          to 1 for the current node since a node on its own forms a consecutive sequence of length 1.
         </li>
         <li>
          It then recursively calls
          <code class="language-plaintext highlighter-rouge">
           dfs
          </code>
          on both the left and right children of the current node, receiving their respective longest increasing and decreasing paths as
          <code class="language-plaintext highlighter-rouge">
           [i1, d1]
          </code>
          and
          <code class="language-plaintext highlighter-rouge">
           [i2, d2]
          </code>
          .
         </li>
         <li>
          For both children, it checks if the childâs value forms a consecutive sequence with the current node (
          <code class="language-plaintext highlighter-rouge">
           root.val
          </code>
          ). If so, it updates
          <code class="language-plaintext highlighter-rouge">
           incr
          </code>
          or
          <code class="language-plaintext highlighter-rouge">
           decr
          </code>
          accordingly. If the left childâs value is one less than the current nodeâs value,
          <code class="language-plaintext highlighter-rouge">
           incr
          </code>
          is incremented; if itâs one more,
          <code class="language-plaintext highlighter-rouge">
           decr
          </code>
          is incremented. The same logic applies to the right child, with the additional step of taking the maximum between the current value of
          <code class="language-plaintext highlighter-rouge">
           incr
          </code>
          or
          <code class="language-plaintext highlighter-rouge">
           decr
          </code>
          and the value obtained from the right child. This ensures that we consider the longest path possible.
         </li>
         <li>
          It updates the global
          <code class="language-plaintext highlighter-rouge">
           ans
          </code>
          variable with the maximum value found so far.
          <code class="language-plaintext highlighter-rouge">
           ans
          </code>
          is calculated as the sum of
          <code class="language-plaintext highlighter-rouge">
           incr
          </code>
          and
          <code class="language-plaintext highlighter-rouge">
           decr
          </code>
          minus 1 (since the root node is counted in both
          <code class="language-plaintext highlighter-rouge">
           incr
          </code>
          and
          <code class="language-plaintext highlighter-rouge">
           decr
          </code>
          , it should be subtracted once to get the actual length of the path).
         </li>
        </ul>
       </li>
      </ul>
      <h3 id="global-variable-ans">
       Global Variable
       <code class="language-plaintext highlighter-rouge">
        ans
       </code>
      </h3>
      <ul>
       <li>
        <code class="language-plaintext highlighter-rouge">
         ans
        </code>
        is used to track the maximum length of the consecutive path found at any point during the traversal of the tree. It is marked as
        <code class="language-plaintext highlighter-rouge">
         nonlocal
        </code>
        within the nested
        <code class="language-plaintext highlighter-rouge">
         dfs
        </code>
        function to update its value across recursive calls.
       </li>
      </ul>
      <ul class="uk-tab" data-uk-switcher="{connect:'#8c35ae39-4312-49e3-b9f6-8a69a9dec48d'}">
       <li class="uk-active">
        <a href="solution-549.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-549.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-549.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-549.html">
         Go
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="8c35ae39-4312-49e3-b9f6-8a69a9dec48d">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">ans</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestConsecutive</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">decr</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">incr</span> <span class="o">=</span> <span class="n">left</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">val</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">decr</span> <span class="o">=</span> <span class="n">left</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">incr</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">incr</span><span class="o">,</span> <span class="n">right</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">val</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">decr</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">decr</span><span class="o">,</span> <span class="n">right</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">incr</span> <span class="o">+</span> <span class="n">decr</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">incr</span><span class="o">,</span> <span class="n">decr</span><span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">ans</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">longestConsecutive</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
        <span class="kt">int</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">decr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="n">incr</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="n">decr</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="n">incr</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">incr</span><span class="p">,</span> <span class="n">right</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="n">decr</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">decr</span><span class="p">,</span> <span class="n">right</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">incr</span> <span class="o">+</span> <span class="n">decr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">incr</span><span class="p">,</span> <span class="n">decr</span><span class="p">};</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
</span>
<span class="s">'''
&gt;&gt;&gt; float('-inf')+1
-inf
&gt;&gt;&gt; float('-inf')-1
-inf
'''</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">longestConsecutive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="s">"""
        :type root: TreeNode
        :rtype: int
        """</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="c1"># val, increasing length, decreasing length, max length
</span>                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s">'-inf'</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="c1"># inc/dec starting from root
</span>            <span class="n">inc</span> <span class="o">=</span> <span class="n">dec</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">leftInc</span><span class="p">,</span> <span class="n">leftDec</span><span class="p">,</span> <span class="n">leftMax</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">right</span><span class="p">,</span> <span class="n">rightInc</span><span class="p">,</span> <span class="n">rightDec</span><span class="p">,</span> <span class="n">rightMax</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">left</span><span class="p">:</span>
                <span class="n">inc</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">leftInc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">left</span><span class="p">:</span>
                <span class="n">dec</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">leftDec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dec</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">inc</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rightInc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">dec</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rightDec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dec</span><span class="p">)</span>
            <span class="c1"># note: max may occur in children subtree, not current root's tree
</span>            <span class="k">return</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">inc</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">inc</span> <span class="o">+</span> <span class="n">dec</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">leftMax</span><span class="p">,</span> <span class="n">rightMax</span><span class="p">,</span> <span class="n">inc</span><span class="p">,</span> <span class="n">dec</span><span class="p">)</span>
            <span class="c1"># -1 because root is counted twice, even left/right both null
</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>

<span class="c1">############
</span>
<span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestConsecutive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">nonlocal</span> <span class="n">ans</span>
            <span class="n">incr</span> <span class="o">=</span> <span class="n">decr</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">i1</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">i2</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                    <span class="n">incr</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                    <span class="n">decr</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                    <span class="n">incr</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">incr</span><span class="p">,</span> <span class="n">i2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># incr1 and incr2 must be in different tree branches, eg. left child cannot be both increasing and decreasing. Same as decr1 and decr2
</span>                <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">val</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                    <span class="n">decr</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">decr</span><span class="p">,</span> <span class="n">d2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">incr</span> <span class="o">+</span> <span class="n">decr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># -1 because root is counted twice, even left/right both null
</span>            <span class="k">return</span> <span class="p">[</span><span class="n">incr</span><span class="p">,</span> <span class="n">decr</span><span class="p">]</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span>

<span class="c1">############
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span> <span class="c1"># issue with this solution, duplicated dfs() search
</span>    <span class="k">def</span> <span class="nf">longestConsecutive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">helper</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">diff</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

            <span class="n">left</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">-</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">diff</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">helper</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">-</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">diff</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">helper</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">helper</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># +1 is increasing, -1 is decreasing
</span>        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">longestConsecutive</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">),</span> <span class="n">longestConsecutive</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)))</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */</span>
<span class="k">func</span> <span class="n">longestConsecutive</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">ans</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">}</span>
		<span class="p">}</span>
		<span class="n">incr</span><span class="p">,</span> <span class="n">decr</span> <span class="o">:=</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span>
		<span class="n">left</span> <span class="o">:=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span>
		<span class="n">right</span> <span class="o">:=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">Left</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="o">.</span><span class="n">Val</span><span class="o">+</span><span class="m">1</span> <span class="o">==</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span> <span class="p">{</span>
				<span class="n">incr</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">+</span> <span class="m">1</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="o">.</span><span class="n">Val</span><span class="o">-</span><span class="m">1</span> <span class="o">==</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span> <span class="p">{</span>
				<span class="n">decr</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="o">+</span> <span class="m">1</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">Right</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="o">.</span><span class="n">Val</span><span class="o">+</span><span class="m">1</span> <span class="o">==</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span> <span class="p">{</span>
				<span class="n">incr</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">incr</span><span class="p">,</span> <span class="n">right</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="o">+</span><span class="m">1</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="o">.</span><span class="n">Val</span><span class="o">-</span><span class="m">1</span> <span class="o">==</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span> <span class="p">{</span>
				<span class="n">decr</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">decr</span><span class="p">,</span> <span class="n">right</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="o">+</span><span class="m">1</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">incr</span><span class="o">+</span><span class="n">decr</span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="n">incr</span><span class="p">,</span> <span class="n">decr</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">ans</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-549.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
