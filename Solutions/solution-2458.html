<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-2458.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-2458.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>2458 - Height of Binary Tree After Subtree Removal Queries</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 2458. Height of Binary Tree After Subtree Removal Queries Description You are given the root of a binary tree with n nodes. Each node is assigned a unique value from 1 to n. You are also given an array queries of size m. You have...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-2458.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-2458.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-2458.html" rel="stylesheet"/>
   <link href="solution-2458.html" rel="stylesheet"/>
   <link href="solution-2458.html" rel="stylesheet"/>
   <link href="solution-2458.html" rel="stylesheet"/>
   <link href="solution-2458.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="2458 - Height of Binary Tree After Subtree Removal Queries" property="og:title"/>
   <meta content="Leetcode 2458. Height of Binary Tree After Subtree Removal Queries Description You are given the root of a binary tree with n nodes. Each node is assigned a unique value from 1 to n. You are also given an array queries of size m. You have to perform m independent queries on the tree where in the ith query you do the following: Remove the subtree rooted at the node with the value queries[i] from the tree. It is guaranteed that queries[i] will not be equal to the value of the root. Return an array answer of size m where answer[i] is the height of the tree after performing the ith query. Note: The queries are independent, so the tree returns to its initial state after each query. The height of a tree is the number of edges in the longest simple path from the root to some node in the tree. &amp;nbsp; Example 1: Input: root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4] Output: [2] Explanation: The diagram above shows the tree after removing the subtree rooted at node with value 4. The height of the tree is 2 (The path 1 -&amp;gt; 3 -&amp;gt; 2). Example 2: Input: root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8] Output: [3,2,3,2] Explanation: We have the following queries: - Removing the subtree rooted at node with value 3. The height of the tree becomes 3 (The path 5 -&amp;gt; 8 -&amp;gt; 2 -&amp;gt; 4). - Removing the subtree rooted at node with value 2. The height of the tree becomes 2 (The path 5 -&amp;gt; 8 -&amp;gt; 1). - Removing the subtree rooted at node with value 4. The height of the tree becomes 3 (The path 5 -&amp;gt; 8 -&amp;gt; 2 -&amp;gt; 6). - Removing the subtree rooted at node with value 8. The height of the tree becomes 2 (The path 5 -&amp;gt; 9 -&amp;gt; 3). &amp;nbsp; Constraints: The number of nodes in the tree is n. 2 &amp;lt;= n &amp;lt;= 105 1 &amp;lt;= Node.val &amp;lt;= n All the values in the tree are unique. m == queries.length 1 &amp;lt;= m &amp;lt;= min(n, 104) 1 &amp;lt;= queries[i] &amp;lt;= n queries[i] != root.val Solutions Solution 1: Two DFS Traversals First, we perform a DFS traversal to determine the depth of each node, which we store in a hash table $d$, where $d[x]$ represents the depth of node $x$. Then we design a function $dfs(root, depth, rest)$, where: root represents the current node; depth represents the depth of the current node; rest represents the height of the tree after deleting the current node. The functionâs computation logic is as follows: If the node is null, return directly. Otherwise, we increment depth by $1$, and then store rest in res. Next, we recursively traverse the left and right subtrees. Before recursing into the left subtree, we calculate the depth from the root node to the deepest node in the current nodeâs right subtree, i.e., $depth+d[root.right]$, and then compare it with rest, taking the..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2022-08-23T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2022-08-23-2458-Height-of-Binary-Tree-After-Subtree-Removal-Queries/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-2458.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="2458 - Height of Binary Tree After Subtree Removal Queries" property="twitter:title"/>
   <meta content="Leetcode 2458. Height of Binary Tree After Subtree Removal Queries Description You are given the root of a binary tree with n nodes. Each node is assigned a unique value from 1 to n. You are also given an array queries of size m. You have to perform m independent queries on the tree where in the ith query you do the following: Remove the subtree rooted at the node with the value queries[i] from the tree. It is guaranteed that queries[i] will not be equal to the value of the root. Return an array answer of size m where answer[i] is the height of the tree after performing the ith query. Note: The queries are independent, so the tree returns to its initial state after each query. The height of a tree is the number of edges in the longest simple path from the root to some node in the tree. &amp;nbsp; Example 1: Input: root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4] Output: [2] Explanation: The diagram above shows the tree after removing the subtree rooted at node with value 4. The height of the tree is 2 (The path 1 -&amp;gt; 3 -&amp;gt; 2). Example 2: Input: root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8] Output: [3,2,3,2] Explanation: We have the following queries: - Removing the subtree rooted at node with value 3. The height of the tree becomes 3 (The path 5 -&amp;gt; 8 -&amp;gt; 2 -&amp;gt; 4). - Removing the subtree rooted at node with value 2. The height of the tree becomes 2 (The path 5 -&amp;gt; 8 -&amp;gt; 1). - Removing the subtree rooted at node with value 4. The height of the tree becomes 3 (The path 5 -&amp;gt; 8 -&amp;gt; 2 -&amp;gt; 6). - Removing the subtree rooted at node with value 8. The height of the tree becomes 2 (The path 5 -&amp;gt; 9 -&amp;gt; 3). &amp;nbsp; Constraints: The number of nodes in the tree is n. 2 &amp;lt;= n &amp;lt;= 105 1 &amp;lt;= Node.val &amp;lt;= n All the values in the tree are unique. m == queries.length 1 &amp;lt;= m &amp;lt;= min(n, 104) 1 &amp;lt;= queries[i] &amp;lt;= n queries[i] != root.val Solutions Solution 1: Two DFS Traversals First, we perform a DFS traversal to determine the depth of each node, which we store in a hash table $d$, where $d[x]$ represents the depth of node $x$. Then we design a function $dfs(root, depth, rest)$, where: root represents the current node; depth represents the depth of the current node; rest represents the height of the tree after deleting the current node. The functionâs computation logic is as follows: If the node is null, return directly. Otherwise, we increment depth by $1$, and then store rest in res. Next, we recursively traverse the left and right subtrees. Before recursing into the left subtree, we calculate the depth from the root node to the deepest node in the current nodeâs right subtree, i.e., $depth+d[root.right]$, and then compare it with rest, taking the..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    2458 - Height of Binary Tree After Subtree Removal Queries | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="2458 - Height of Binary Tree After Subtree Removal Queries" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-2458.html" rel="canonical">
          <meta content="https://leetcode.ca/2022-08-23-2458-Height-of-Binary-Tree-After-Subtree-Removal-Queries/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2022-08-23T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"2458 - Height of Binary Tree After Subtree Removal Queries","dateModified":"2022-08-23T00:00:00-07:00","datePublished":"2022-08-23T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2022-08-23-2458-Height-of-Binary-Tree-After-Subtree-Removal-Queries/"},"url":"https://leetcode.ca/2022-08-23-2458-Height-of-Binary-Tree-After-Subtree-Removal-Queries/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="2458-height-of-binary-tree-after-subtree-removal-queries">
       <a href="solution-2458.html">
        2458. Height of Binary Tree After Subtree Removal Queries
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       You are given the
       <code>
        root
       </code>
       of a
       <strong>
        binary tree
       </strong>
       with
       <code>
        n
       </code>
       nodes. Each node is assigned a unique value from
       <code>
        1
       </code>
       to
       <code>
        n
       </code>
       . You are also given an array
       <code>
        queries
       </code>
       of size
       <code>
        m
       </code>
       .
      </p>
      <p>
       You have to perform
       <code>
        m
       </code>
       <strong>
        independent
       </strong>
       queries on the tree where in the
       <code>
        i
        <sup>
         th
        </sup>
       </code>
       query you do the following:
      </p>
      <ul>
       <li>
        <strong>
         Remove
        </strong>
        the subtree rooted at the node with the value
        <code>
         queries[i]
        </code>
        from the tree. It is
        <strong>
         guaranteed
        </strong>
        that
        <code>
         queries[i]
        </code>
        will
        <strong>
         not
        </strong>
        be equal to the value of the root.
       </li>
      </ul>
      <p>
       Return
       <em>
        an array
       </em>
       <code>
        answer
       </code>
       <em>
        of size
       </em>
       <code>
        m
       </code>
       <em>
        where
       </em>
       <code>
        answer[i]
       </code>
       <em>
        is the height of the tree after performing the
       </em>
       <code>
        i
        <sup>
         th
        </sup>
       </code>
       <em>
        query
       </em>
       .
      </p>
      <p>
       <strong>
        Note
       </strong>
       :
      </p>
      <ul>
       <li>
        The queries are independent, so the tree returns to its
        <strong>
         initial
        </strong>
        state after each query.
       </li>
       <li>
        The height of a tree is the
        <strong>
         number of edges in the longest simple path
        </strong>
        from the root to some node in the tree.
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2400-2499/2458.Height%20of%20Binary%20Tree%20After%20Subtree%20Removal%20Queries/images/binaryytreeedrawio-1.png" style="width: 495px; height: 281px;"/>
      </p>
      <pre>
<strong>Input:</strong> root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]
<strong>Output:</strong> [2]
<strong>Explanation:</strong> The diagram above shows the tree after removing the subtree rooted at node with value 4.
The height of the tree is 2 (The path 1 -&gt; 3 -&gt; 2).
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2400-2499/2458.Height%20of%20Binary%20Tree%20After%20Subtree%20Removal%20Queries/images/binaryytreeedrawio-2.png" style="width: 301px; height: 284px;"/>
      </p>
      <pre>
<strong>Input:</strong> root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]
<strong>Output:</strong> [3,2,3,2]
<strong>Explanation:</strong> We have the following queries:
- Removing the subtree rooted at node with value 3. The height of the tree becomes 3 (The path 5 -&gt; 8 -&gt; 2 -&gt; 4).
- Removing the subtree rooted at node with value 2. The height of the tree becomes 2 (The path 5 -&gt; 8 -&gt; 1).
- Removing the subtree rooted at node with value 4. The height of the tree becomes 3 (The path 5 -&gt; 8 -&gt; 2 -&gt; 6).
- Removing the subtree rooted at node with value 8. The height of the tree becomes 2 (The path 5 -&gt; 9 -&gt; 3).
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the tree is
        <code>
         n
        </code>
        .
       </li>
       <li>
        <code>
         2 &lt;= n &lt;= 10
         <sup>
          5
         </sup>
        </code>
       </li>
       <li>
        <code>
         1 &lt;= Node.val &lt;= n
        </code>
       </li>
       <li>
        All the values in the tree are
        <strong>
         unique
        </strong>
        .
       </li>
       <li>
        <code>
         m == queries.length
        </code>
       </li>
       <li>
        <code>
         1 &lt;= m &lt;= min(n, 10
         <sup>
          4
         </sup>
         )
        </code>
       </li>
       <li>
        <code>
         1 &lt;= queries[i] &lt;= n
        </code>
       </li>
       <li>
        <code>
         queries[i] != root.val
        </code>
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       <strong>
        Solution 1: Two DFS Traversals
       </strong>
      </p>
      <p>
       First, we perform a DFS traversal to determine the depth of each node, which we store in a hash table $d$, where $d[x]$ represents the depth of node $x$.
      </p>
      <p>
       Then we design a function $dfs(root, depth, rest)$, where:
      </p>
      <ul>
       <li>
        <code class="language-plaintext highlighter-rouge">
         root
        </code>
        represents the current node;
       </li>
       <li>
        <code class="language-plaintext highlighter-rouge">
         depth
        </code>
        represents the depth of the current node;
       </li>
       <li>
        <code class="language-plaintext highlighter-rouge">
         rest
        </code>
        represents the height of the tree after deleting the current node.
       </li>
      </ul>
      <p>
       The functionâs computation logic is as follows:
      </p>
      <p>
       If the node is null, return directly. Otherwise, we increment
       <code class="language-plaintext highlighter-rouge">
        depth
       </code>
       by $1$, and then store
       <code class="language-plaintext highlighter-rouge">
        rest
       </code>
       in
       <code class="language-plaintext highlighter-rouge">
        res
       </code>
       .
      </p>
      <p>
       Next, we recursively traverse the left and right subtrees.
      </p>
      <p>
       Before recursing into the left subtree, we calculate the depth from the root node to the deepest node in the current nodeâs right subtree, i.e., $depth+d[root.right]$, and then compare it with
       <code class="language-plaintext highlighter-rouge">
        rest
       </code>
       , taking the larger value as the
       <code class="language-plaintext highlighter-rouge">
        rest
       </code>
       for the left subtree.
      </p>
      <p>
       Before recursing into the right subtree, we calculate the depth from the root node to the deepest node in the current nodeâs left subtree, i.e., $depth+d[root.left]$, and then compare it with
       <code class="language-plaintext highlighter-rouge">
        rest
       </code>
       , taking the larger value as the
       <code class="language-plaintext highlighter-rouge">
        rest
       </code>
       for the right subtree.
      </p>
      <p>
       Finally, we return the result values corresponding to each query node.
      </p>
      <p>
       The time complexity is $O(n+m)$, and the space complexity is $O(n)$. Here, $n$ and $m$ are the number of nodes in the tree and the number of queries, respectively.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#c4b10170-fb7c-45d4-9dd8-6c1919a6a6a3'}">
       <li class="uk-active">
        <a href="solution-2458.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-2458.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-2458.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-2458.html">
         Go
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="c4b10170-fb7c-45d4-9dd8-6c1919a6a6a3">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">treeQueries</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">queries</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">f</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">d</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="n">d</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">queries</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ans</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">[</span><span class="n">queries</span><span class="o">[</span><span class="n">i</span><span class="o">]];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">,</span> <span class="kt">int</span> <span class="n">rest</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="o">++</span><span class="n">depth</span><span class="o">;</span>
        <span class="n">res</span><span class="o">[</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">]</span> <span class="o">=</span> <span class="n">rest</span><span class="o">;</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">depth</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">rest</span><span class="o">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="n">d</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">)));</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">depth</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">rest</span><span class="o">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="n">d</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">f</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">),</span> <span class="n">r</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="n">d</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">treeQueries</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">queries</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">;</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">),</span> <span class="n">r</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="n">d</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">root</span><span class="p">];</span>
        <span class="p">};</span>
        <span class="n">f</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rest</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
            <span class="o">++</span><span class="n">depth</span><span class="p">;</span>
            <span class="n">res</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">rest</span><span class="p">;</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">]));</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">]));</span>
        <span class="p">};</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">queries</span><span class="p">)</span> <span class="n">ans</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">treeQueries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">queries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">rest</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">res</span><span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">rest</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">]))</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">]))</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">f</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">res</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">queries</span><span class="p">]</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */</span>
<span class="k">func</span> <span class="n">treeQueries</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">,</span> <span class="n">queries</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">ans</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">d</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="k">var</span> <span class="n">f</span> <span class="k">func</span><span class="p">(</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="kt">int</span>
	<span class="n">f</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="m">0</span>
		<span class="p">}</span>
		<span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">f</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
		<span class="n">d</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="m">1</span> <span class="o">+</span> <span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="n">f</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
	<span class="n">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">+</span><span class="m">1</span><span class="p">)</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">rest</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="n">depth</span><span class="o">++</span>
		<span class="n">res</span><span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="p">]</span> <span class="o">=</span> <span class="n">rest</span>
		<span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="n">d</span><span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="p">]))</span>
		<span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="n">d</span><span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="p">]))</span>
	<span class="p">}</span>
	<span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">-</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">queries</span> <span class="p">{</span>
		<span class="n">ans</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-2458.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
