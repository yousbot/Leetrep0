<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-1810.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-1810.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>1810 - Minimum Path Cost in a Hidden Grid</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 1810. Minimum Path Cost in a Hidden Grid Description This is an interactive problem. There is a robot in a hidden grid, and you are trying to get it from its starting cell to the target cell in this grid. The grid is of size...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-1810.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-1810.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-1810.html" rel="stylesheet"/>
   <link href="solution-1810.html" rel="stylesheet"/>
   <link href="solution-1810.html" rel="stylesheet"/>
   <link href="solution-1810.html" rel="stylesheet"/>
   <link href="solution-1810.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="1810 - Minimum Path Cost in a Hidden Grid" property="og:title"/>
   <meta content="Leetcode 1810. Minimum Path Cost in a Hidden Grid Description This is an interactive problem. There is a robot in a hidden grid, and you are trying to get it from its starting cell to the target cell in this grid. The grid is of size m x n, and each cell in the grid is either empty or blocked. It is guaranteed that the starting cell and the target cell are different, and neither of them is blocked. Each cell has a cost that you need to pay each time you move to the cell. The starting cell&amp;#39;s cost is not applied before the robot moves. You want to find the minimum total cost to move the robot to the target cell. However, you do not know the grid&amp;#39;s dimensions, the starting cell, nor the target cell. You are only allowed to ask queries to the GridMaster object. The GridMaster class has the following functions: boolean canMove(char direction) Returns true if the robot can move in that direction. Otherwise, it returns false. int move(char direction) Moves the robot in that direction and returns the cost of moving to that cell. If this move would move the robot to a blocked cell or off the grid, the move will be ignored, the robot will remain in the same position, and the function will return -1. boolean isTarget() Returns true if the robot is currently on the target cell. Otherwise, it returns false. Note that direction in the above functions should be a character from {&amp;#39;U&amp;#39;,&amp;#39;D&amp;#39;,&amp;#39;L&amp;#39;,&amp;#39;R&amp;#39;}, representing the directions up, down, left, and right, respectively. Return the minimum total cost to get the robot from its initial starting cell to the target cell. If there is no valid path between the cells, return -1. Custom testing: The test input is read as a 2D matrix grid of size m x n and four integers r1, c1, r2, and c2 where: grid[i][j] == 0 indicates that the cell (i, j) is blocked. grid[i][j] &amp;gt;= 1 indicates that the cell (i, j) is empty and grid[i][j] is the cost to move to that cell. (r1, c1) is the starting cell of the robot. (r2, c2) is the target cell of the robot. Remember that you will not have this information in your code. &amp;nbsp; Example 1: Input: grid = [[2,3],[1,1]], r1 = 0, c1 = 1, r2 = 1, c2 = 0 Output: 2 Explanation: One possible interaction is described below: The robot is initially standing on cell (0, 1), denoted by the 3. - master.canMove(&amp;#39;U&amp;#39;) returns false. - master.canMove(&amp;#39;D&amp;#39;) returns true. - master.canMove(&amp;#39;L&amp;#39;) returns true. - master.canMove(&amp;#39;R&amp;#39;) returns false. - master.move(&amp;#39;L&amp;#39;) moves the robot to the cell (0, 0) and returns 2. - master.isTarget() returns false. - master.canMove(&amp;#39;U&amp;#39;) returns false. - master.canMove(&amp;#39;D&amp;#39;) returns true. - master.canMove(&amp;#39;L&amp;#39;) returns false. - master.canMove(&amp;#39;R&amp;#39;) returns true. - master.move(&amp;#39;D&amp;#39;) moves the robot to the cell (1, 0) and returns 1. - master.isTarget() returns true. - master.move(&amp;#39;L&amp;#39;) doesn&amp;#39;t move the robot and returns -1...." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2020-11-13T00:00:00-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2020-11-13-1810-Minimum-Path-Cost-in-a-Hidden-Grid/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-1810.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="1810 - Minimum Path Cost in a Hidden Grid" property="twitter:title"/>
   <meta content="Leetcode 1810. Minimum Path Cost in a Hidden Grid Description This is an interactive problem. There is a robot in a hidden grid, and you are trying to get it from its starting cell to the target cell in this grid. The grid is of size m x n, and each cell in the grid is either empty or blocked. It is guaranteed that the starting cell and the target cell are different, and neither of them is blocked. Each cell has a cost that you need to pay each time you move to the cell. The starting cell&amp;#39;s cost is not applied before the robot moves. You want to find the minimum total cost to move the robot to the target cell. However, you do not know the grid&amp;#39;s dimensions, the starting cell, nor the target cell. You are only allowed to ask queries to the GridMaster object. The GridMaster class has the following functions: boolean canMove(char direction) Returns true if the robot can move in that direction. Otherwise, it returns false. int move(char direction) Moves the robot in that direction and returns the cost of moving to that cell. If this move would move the robot to a blocked cell or off the grid, the move will be ignored, the robot will remain in the same position, and the function will return -1. boolean isTarget() Returns true if the robot is currently on the target cell. Otherwise, it returns false. Note that direction in the above functions should be a character from {&amp;#39;U&amp;#39;,&amp;#39;D&amp;#39;,&amp;#39;L&amp;#39;,&amp;#39;R&amp;#39;}, representing the directions up, down, left, and right, respectively. Return the minimum total cost to get the robot from its initial starting cell to the target cell. If there is no valid path between the cells, return -1. Custom testing: The test input is read as a 2D matrix grid of size m x n and four integers r1, c1, r2, and c2 where: grid[i][j] == 0 indicates that the cell (i, j) is blocked. grid[i][j] &amp;gt;= 1 indicates that the cell (i, j) is empty and grid[i][j] is the cost to move to that cell. (r1, c1) is the starting cell of the robot. (r2, c2) is the target cell of the robot. Remember that you will not have this information in your code. &amp;nbsp; Example 1: Input: grid = [[2,3],[1,1]], r1 = 0, c1 = 1, r2 = 1, c2 = 0 Output: 2 Explanation: One possible interaction is described below: The robot is initially standing on cell (0, 1), denoted by the 3. - master.canMove(&amp;#39;U&amp;#39;) returns false. - master.canMove(&amp;#39;D&amp;#39;) returns true. - master.canMove(&amp;#39;L&amp;#39;) returns true. - master.canMove(&amp;#39;R&amp;#39;) returns false. - master.move(&amp;#39;L&amp;#39;) moves the robot to the cell (0, 0) and returns 2. - master.isTarget() returns false. - master.canMove(&amp;#39;U&amp;#39;) returns false. - master.canMove(&amp;#39;D&amp;#39;) returns true. - master.canMove(&amp;#39;L&amp;#39;) returns false. - master.canMove(&amp;#39;R&amp;#39;) returns true. - master.move(&amp;#39;D&amp;#39;) moves the robot to the cell (1, 0) and returns 1. - master.isTarget() returns true. - master.move(&amp;#39;L&amp;#39;) doesn&amp;#39;t move the robot and returns -1...." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    1810 - Minimum Path Cost in a Hidden Grid | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="1810 - Minimum Path Cost in a Hidden Grid" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-1810.html" rel="canonical">
          <meta content="https://leetcode.ca/2020-11-13-1810-Minimum-Path-Cost-in-a-Hidden-Grid/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2020-11-13T00:00:00-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"1810 - Minimum Path Cost in a Hidden Grid","dateModified":"2020-11-13T00:00:00-08:00","datePublished":"2020-11-13T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2020-11-13-1810-Minimum-Path-Cost-in-a-Hidden-Grid/"},"url":"https://leetcode.ca/2020-11-13-1810-Minimum-Path-Cost-in-a-Hidden-Grid/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="1810-minimum-path-cost-in-a-hidden-grid">
       <a href="solution-1810.html">
        1810. Minimum Path Cost in a Hidden Grid
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       This is an
       <strong>
        interactive problem
       </strong>
       .
      </p>
      <p>
       There is a robot in a hidden grid, and you are trying to get it from its starting cell to the target cell in this grid. The grid is of size
       <code>
        m x n
       </code>
       , and each cell in the grid is either empty or blocked. It is
       <strong>
        guaranteed
       </strong>
       that the starting cell and the target cell are different, and neither of them is blocked.
      </p>
      <p>
       Each cell has a
       <strong>
        cost
       </strong>
       that you need to pay each time you
       <strong>
        move
       </strong>
       to the cell. The starting cell's cost is
       <strong>
        not
       </strong>
       applied before the robot moves.
      </p>
      <p>
       You want to find the minimum total cost to move the robot to the target cell. However, you
       <strong>
        do not know
       </strong>
       the grid's dimensions, the starting cell, nor the target cell. You are only allowed to ask queries to the
       <code>
        GridMaster
       </code>
       object.
      </p>
      <p>
       The
       <code>
        GridMaster
       </code>
       class has the following functions:
      </p>
      <ul>
       <li>
        <code>
         boolean canMove(char direction)
        </code>
        Returns
        <code>
         true
        </code>
        if the robot can move in that direction. Otherwise, it returns
        <code>
         false
        </code>
        .
       </li>
       <li>
        <code>
         int move(char direction)
        </code>
        Moves the robot in that direction and returns the cost of moving to that cell. If this move would move the robot to a blocked cell or off the grid, the move will be
        <strong>
         ignored
        </strong>
        , the robot will remain in the same position, and the function will return
        <code>
         -1
        </code>
        .
       </li>
       <li>
        <code>
         boolean isTarget()
        </code>
        Returns
        <code>
         true
        </code>
        if the robot is currently on the target cell. Otherwise, it returns
        <code>
         false
        </code>
        .
       </li>
      </ul>
      <p>
       Note that
       <code>
        direction
       </code>
       in the above functions should be a character from
       <code>
        {'U','D','L','R'}
       </code>
       , representing the directions up, down, left, and right, respectively.
      </p>
      <p>
       Return
       <em>
        the
        <strong>
         minimum total cost
        </strong>
        to get the robot from its initial starting cell to the target cell. If there is no valid path between the cells, return
       </em>
       <code>
        -1
       </code>
       .
      </p>
      <p>
       <strong>
        Custom testing:
       </strong>
      </p>
      <p>
       The test input is read as a 2D matrix
       <code>
        grid
       </code>
       of size
       <code>
        m x n
       </code>
       and four integers
       <code>
        r1
       </code>
       ,
       <code>
        c1
       </code>
       ,
       <code>
        r2
       </code>
       , and
       <code>
        <font face="monospace">
         c2
        </font>
       </code>
       where:
      </p>
      <ul>
       <li>
        <code>
         grid[i][j] == 0
        </code>
        indicates that the cell
        <code>
         (i, j)
        </code>
        is blocked.
       </li>
       <li>
        <code>
         grid[i][j] &gt;= 1
        </code>
        indicates that the cell
        <code>
         (i, j)
        </code>
        is empty and
        <code>
         grid[i][j]
        </code>
        is the
        <strong>
         cost
        </strong>
        to move to that cell.
       </li>
       <li>
        <code>
         (r1, c1)
        </code>
        is the starting cell of the robot.
       </li>
       <li>
        <code>
         (r2, c2)
        </code>
        is the target cell of the robot.
       </li>
      </ul>
      <p>
       Remember that you will
       <strong>
        not
       </strong>
       have this information in your code.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> grid = [[2,3],[1,1]], r1 = 0, c1 = 1, r2 = 1, c2 = 0
<strong>Output:</strong> 2
<strong>Explanation:</strong> One possible interaction is described below:
The robot is initially standing on cell (0, 1), denoted by the 3.
- master.canMove('U') returns false.
- master.canMove('D') returns true.
- master.canMove('L') returns true.
- master.canMove('R') returns false.
- master.move('L') moves the robot to the cell (0, 0) and returns 2.
- master.isTarget() returns false.
- master.canMove('U') returns false.
- master.canMove('D') returns true.
- master.canMove('L') returns false.
- master.canMove('R') returns true.
- master.move('D') moves the robot to the cell (1, 0) and returns 1.
- master.isTarget() returns true.
- master.move('L') doesn't move the robot and returns -1.
- master.move('R') moves the robot to the cell (1, 1) and returns 1.
We now know that the target is the cell (1, 0), and the minimum total cost to reach it is 2. </pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> grid = [[0,3,1],[3,4,2],[1,2,0]], r1 = 2, c1 = 0, r2 = 0, c2 = 2
<strong>Output:</strong> 9
<strong>Explanation:</strong> The minimum cost path is (2,0) -&gt; (2,1) -&gt; (1,1) -&gt; (1,2) -&gt; (0,2).
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> grid = [[1,0],[0,1]], r1 = 0, c1 = 0, r2 = 1, c2 = 1
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is no path from the robot to the target cell.
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= n, m &lt;= 100
        </code>
       </li>
       <li>
        <code>
         m == grid.length
        </code>
       </li>
       <li>
        <code>
         n == grid[i].length
        </code>
       </li>
       <li>
        <code>
         0 &lt;= grid[i][j] &lt;= 100
        </code>
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <ul class="uk-tab" data-uk-switcher="{connect:'#6cacedff-ed67-4539-a2dc-ead8dae3393f'}">
       <li class="uk-active">
        <a href="solution-1810.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-1810.html">
         Python
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="6cacedff-ed67-4539-a2dc-ead8dae3393f">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * // This is the GridMaster's API interface.
 * // You should not implement it, or speculate about its implementation
 * class GridMaster {
 *     boolean canMove(char direction);
 *     int move(char direction);
 *     boolean isTarget();
 * }
 */</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">char</span><span class="o">[]</span> <span class="n">dir</span> <span class="o">=</span> <span class="o">{</span><span class="sc">'U'</span><span class="o">,</span> <span class="sc">'R'</span><span class="o">,</span> <span class="sc">'D'</span><span class="o">,</span> <span class="sc">'L'</span><span class="o">};</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">char</span><span class="o">[]</span> <span class="n">ndir</span> <span class="o">=</span> <span class="o">{</span><span class="sc">'D'</span><span class="o">,</span> <span class="sc">'L'</span><span class="o">,</span> <span class="sc">'U'</span><span class="o">,</span> <span class="sc">'R'</span><span class="o">};</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dirs</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="mi">200</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">INF</span> <span class="o">=</span> <span class="mh">0x3f3f3f3f</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">g</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">dist</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">target</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findShortestPath</span><span class="o">(</span><span class="nc">GridMaster</span> <span class="n">master</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">target</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="no">INF</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">dfs</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="mi">100</span><span class="o">,</span> <span class="n">master</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">target</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">target</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="nc">Comparator</span><span class="o">.</span><span class="na">comparingInt</span><span class="o">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">100</span><span class="o">,</span> <span class="mi">100</span><span class="o">});</span>
        <span class="n">dist</span><span class="o">[</span><span class="mi">100</span><span class="o">][</span><span class="mi">100</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">p</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">j</span> <span class="o">=</span> <span class="n">p</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">target</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="n">target</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">w</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dirs</span><span class="o">[</span><span class="n">k</span><span class="o">],</span> <span class="n">y</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">dirs</span><span class="o">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">g</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">w</span> <span class="o">+</span> <span class="n">g</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">dist</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="n">w</span> <span class="o">+</span> <span class="n">g</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">];</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">dist</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">],</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">});</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">,</span> <span class="nc">GridMaster</span> <span class="n">master</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">master</span><span class="o">.</span><span class="na">isTarget</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">target</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">};</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">d</span> <span class="o">=</span> <span class="n">dir</span><span class="o">[</span><span class="n">k</span><span class="o">],</span> <span class="n">nd</span> <span class="o">=</span> <span class="n">ndir</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dirs</span><span class="o">[</span><span class="n">k</span><span class="o">],</span> <span class="n">y</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">dirs</span><span class="o">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">master</span><span class="o">.</span><span class="na">canMove</span><span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">g</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">g</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="n">master</span><span class="o">.</span><span class="na">move</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">master</span><span class="o">);</span>
                <span class="n">master</span><span class="o">.</span><span class="na">move</span><span class="o">(</span><span class="n">nd</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># """
# This is GridMaster's API interface.
# You should not implement it, or speculate about its implementation
# """
# class GridMaster(object):
#    def canMove(self, direction: str) -&gt; bool:
#
#
#    def move(self, direction: str) -&gt; int:
#
#
#    def isTarget(self) -&gt; None:
#
#
</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">findShortestPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">master</span><span class="p">:</span> <span class="s">'GridMaster'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">target</span>
            <span class="k">if</span> <span class="n">master</span><span class="p">.</span><span class="n">isTarget</span><span class="p">():</span>
                <span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">for</span> <span class="nb">dir</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ndir</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">a</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">b</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="ow">and</span> <span class="n">master</span><span class="p">.</span><span class="n">canMove</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span> <span class="ow">and</span> <span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">master</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                    <span class="n">master</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">ndir</span><span class="p">)</span>

        <span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="mi">200</span>
        <span class="n">INF</span> <span class="o">=</span> <span class="mh">0x3F3F3F3F</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
        <span class="n">dirs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">'U'</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">'D'</span><span class="p">),</span>
            <span class="s">'D'</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">'U'</span><span class="p">),</span>
            <span class="s">'L'</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s">'R'</span><span class="p">),</span>
            <span class="s">'R'</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'L'</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="n">dfs</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)]</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="p">[[</span><span class="n">INF</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
        <span class="n">dist</span><span class="p">[</span><span class="mi">100</span><span class="p">][</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">w</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">w</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">a</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">b</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">N</span>
                    <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">N</span>
                    <span class="ow">and</span> <span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="ow">and</span> <span class="n">dist</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">w</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>
                    <span class="n">heappush</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="k">return</span> <span class="mi">0</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-1810.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
