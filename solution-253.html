<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-253.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-253.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>253 - Meeting Rooms II</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 253. Meeting Rooms II Description Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required. &amp;nbsp; Example 1: Input: intervals = [[0,30],[5,10],[15,20]] Output: 2 Example 2: Input: intervals = [[7,10],[2,4]] Output: 1 &amp;nbsp; Constraints:...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-253.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-253.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-253.html" rel="stylesheet"/>
   <link href="solution-253.html" rel="stylesheet"/>
   <link href="solution-253.html" rel="stylesheet"/>
   <link href="solution-253.html" rel="stylesheet"/>
   <link href="solution-253.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="253 - Meeting Rooms II" property="og:title"/>
   <meta content="Leetcode 253. Meeting Rooms II Description Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required. &amp;nbsp; Example 1: Input: intervals = [[0,30],[5,10],[15,20]] Output: 2 Example 2: Input: intervals = [[7,10],[2,4]] Output: 1 &amp;nbsp; Constraints: 1 &amp;lt;=&amp;nbsp;intervals.length &amp;lt;= 104 0 &amp;lt;= starti &amp;lt; endi &amp;lt;= 106 Solutions The solution employs a technique using a concept similar to the line sweep algorithm and partial sum accumulation. How it Works: Initialize a Large Array: delta = [0] * 1000010 creates an array (or list in Python terms) of size 1,000,010, initialized with zeros. This array acts as a map, where the index represents a time point and the value at each index represents the net change in the number of ongoing meetings at that time. Populate the delta Array: For each meeting defined by its start and end times, the code increments the value at the start index by 1 and decrements the value at the end index by 1 in the delta array. This increment and decrement operation effectively marks the beginning and end of a meeting, respectively. The positive value at the start time indicates new meetings starting, and the negative value at the end time indicates meetings ending. Accumulate Changes: The expression accumulate(delta) computes the cumulative sum of the delta array. This step calculates the net number of meetings ongoing at each time point, based on the previously marked start and end times. After accumulation, each value in the delta array represents the total number of meetings ongoing at the corresponding time point. Find the Maximum Value: The maximum value in the accumulated delta array represents the peak number of simultaneous meetings. This peak value is the minimum number of conference rooms needed to accommodate all meetings without any overlap. Example: Given intervals = [[1,5],[9,11],[3,10],[2,7]], the solution works as follows: Initially, delta is all zeros. After processing the intervals, delta at relevant indices would be updated as follows: delta[1] becomes 1 (meeting starting at time 1), delta[5] becomes -1 (meeting ending at time 5), and so on for other intervals. The accumulation step then calculates the running total of meetings at each time, effectively tracking how many meetings are ongoing at any given time. The maximum value in this accumulated array gives the highest number of simultaneous meetings, which in this case would require an equal number of meeting rooms. Efficiency: This solution is efficient because it condenses the problem into a single pass through a fixed-size array (assuming meeting times are bounded by the arrayâs size) and a single pass to accumulate changes, both of which are linear operations. The overall time complexity is (O(N + T)), where (N) is the number of intervals and (T) is the fixed size of the delta array, making it highly efficient for the given problem constraints. Java C++ Python Go RenderScript class Solution { public int minMeetingRooms(int[][] intervals) { int n = 1000010; int[] delta =..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-08-09T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-08-09-253-Meeting-Rooms-II/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-253.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="253 - Meeting Rooms II" property="twitter:title"/>
   <meta content="Leetcode 253. Meeting Rooms II Description Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required. &amp;nbsp; Example 1: Input: intervals = [[0,30],[5,10],[15,20]] Output: 2 Example 2: Input: intervals = [[7,10],[2,4]] Output: 1 &amp;nbsp; Constraints: 1 &amp;lt;=&amp;nbsp;intervals.length &amp;lt;= 104 0 &amp;lt;= starti &amp;lt; endi &amp;lt;= 106 Solutions The solution employs a technique using a concept similar to the line sweep algorithm and partial sum accumulation. How it Works: Initialize a Large Array: delta = [0] * 1000010 creates an array (or list in Python terms) of size 1,000,010, initialized with zeros. This array acts as a map, where the index represents a time point and the value at each index represents the net change in the number of ongoing meetings at that time. Populate the delta Array: For each meeting defined by its start and end times, the code increments the value at the start index by 1 and decrements the value at the end index by 1 in the delta array. This increment and decrement operation effectively marks the beginning and end of a meeting, respectively. The positive value at the start time indicates new meetings starting, and the negative value at the end time indicates meetings ending. Accumulate Changes: The expression accumulate(delta) computes the cumulative sum of the delta array. This step calculates the net number of meetings ongoing at each time point, based on the previously marked start and end times. After accumulation, each value in the delta array represents the total number of meetings ongoing at the corresponding time point. Find the Maximum Value: The maximum value in the accumulated delta array represents the peak number of simultaneous meetings. This peak value is the minimum number of conference rooms needed to accommodate all meetings without any overlap. Example: Given intervals = [[1,5],[9,11],[3,10],[2,7]], the solution works as follows: Initially, delta is all zeros. After processing the intervals, delta at relevant indices would be updated as follows: delta[1] becomes 1 (meeting starting at time 1), delta[5] becomes -1 (meeting ending at time 5), and so on for other intervals. The accumulation step then calculates the running total of meetings at each time, effectively tracking how many meetings are ongoing at any given time. The maximum value in this accumulated array gives the highest number of simultaneous meetings, which in this case would require an equal number of meeting rooms. Efficiency: This solution is efficient because it condenses the problem into a single pass through a fixed-size array (assuming meeting times are bounded by the arrayâs size) and a single pass to accumulate changes, both of which are linear operations. The overall time complexity is (O(N + T)), where (N) is the number of intervals and (T) is the fixed size of the delta array, making it highly efficient for the given problem constraints. Java C++ Python Go RenderScript class Solution { public int minMeetingRooms(int[][] intervals) { int n = 1000010; int[] delta =..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    253 - Meeting Rooms II | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="253 - Meeting Rooms II" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-253.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-08-09-253-Meeting-Rooms-II/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-08-09T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"253 - Meeting Rooms II","dateModified":"2016-08-09T00:00:00-07:00","datePublished":"2016-08-09T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-08-09-253-Meeting-Rooms-II/"},"url":"https://leetcode.ca/2016-08-09-253-Meeting-Rooms-II/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="253-meeting-rooms-ii">
       <a href="solution-253.html">
        253. Meeting Rooms II
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given an array of meeting time intervals
       <code>
        intervals
       </code>
       where
       <code>
        intervals[i] = [start
        <sub>
         i
        </sub>
        , end
        <sub>
         i
        </sub>
        ]
       </code>
       , return
       <em>
        the minimum number of conference rooms required
       </em>
       .
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre><strong>Input:</strong> intervals = [[0,30],[5,10],[15,20]]
<strong>Output:</strong> 2
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre><strong>Input:</strong> intervals = [[7,10],[2,4]]
<strong>Output:</strong> 1
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= intervals.length &lt;= 10
         <sup>
          4
         </sup>
        </code>
       </li>
       <li>
        <code>
         0 &lt;= start
         <sub>
          i
         </sub>
         &lt; end
         <sub>
          i
         </sub>
         &lt;= 10
         <sup>
          6
         </sup>
        </code>
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       The solution employs a technique using a concept similar to the
       <code class="language-plaintext highlighter-rouge">
        line sweep
       </code>
       algorithm and partial sum accumulation.
      </p>
      <h3 id="how-it-works">
       How it Works:
      </h3>
      <ol>
       <li>
        <p>
         <strong>
          Initialize a Large Array
         </strong>
         :
         <code class="language-plaintext highlighter-rouge">
          delta = [0] * 1000010
         </code>
         creates an array (or list in Python terms) of size 1,000,010, initialized with zeros. This array acts as a map, where the index represents a time point and the value at each index represents the net change in the number of ongoing meetings at that time.
        </p>
       </li>
       <li>
        <strong>
         Populate the
         <code class="language-plaintext highlighter-rouge">
          delta
         </code>
         Array
        </strong>
        :
        <ul>
         <li>
          For each meeting defined by its
          <code class="language-plaintext highlighter-rouge">
           start
          </code>
          and
          <code class="language-plaintext highlighter-rouge">
           end
          </code>
          times, the code increments the value at the
          <code class="language-plaintext highlighter-rouge">
           start
          </code>
          index by 1 and decrements the value at the
          <code class="language-plaintext highlighter-rouge">
           end
          </code>
          index by 1 in the
          <code class="language-plaintext highlighter-rouge">
           delta
          </code>
          array.
         </li>
         <li>
          This increment and decrement operation effectively marks the beginning and end of a meeting, respectively. The positive value at the
          <code class="language-plaintext highlighter-rouge">
           start
          </code>
          time indicates new meetings starting, and the negative value at the
          <code class="language-plaintext highlighter-rouge">
           end
          </code>
          time indicates meetings ending.
         </li>
        </ul>
       </li>
       <li>
        <strong>
         Accumulate Changes
        </strong>
        :
        <ul>
         <li>
          The expression
          <code class="language-plaintext highlighter-rouge">
           accumulate(delta)
          </code>
          computes the cumulative sum of the
          <code class="language-plaintext highlighter-rouge">
           delta
          </code>
          array. This step calculates the net number of meetings ongoing at each time point, based on the previously marked start and end times.
         </li>
         <li>
          After accumulation, each value in the
          <code class="language-plaintext highlighter-rouge">
           delta
          </code>
          array represents the total number of meetings ongoing at the corresponding time point.
         </li>
        </ul>
       </li>
       <li>
        <strong>
         Find the Maximum Value
        </strong>
        :
        <ul>
         <li>
          The maximum value in the accumulated
          <code class="language-plaintext highlighter-rouge">
           delta
          </code>
          array represents the peak number of simultaneous meetings. This peak value is the minimum number of conference rooms needed to accommodate all meetings without any overlap.
         </li>
        </ul>
       </li>
      </ol>
      <h3 id="example">
       Example:
      </h3>
      <p>
       Given
       <code class="language-plaintext highlighter-rouge">
        intervals = [[1,5],[9,11],[3,10],[2,7]]
       </code>
       , the solution works as follows:
      </p>
      <ul>
       <li>
        Initially,
        <code class="language-plaintext highlighter-rouge">
         delta
        </code>
        is all zeros.
       </li>
       <li>
        After processing the intervals,
        <code class="language-plaintext highlighter-rouge">
         delta
        </code>
        at relevant indices would be updated as follows:
        <ul>
         <li>
          <code class="language-plaintext highlighter-rouge">
           delta[1]
          </code>
          becomes 1 (meeting starting at time 1),
         </li>
         <li>
          <code class="language-plaintext highlighter-rouge">
           delta[5]
          </code>
          becomes -1 (meeting ending at time 5),
         </li>
         <li>
          and so on for other intervals.
         </li>
        </ul>
       </li>
       <li>
        The accumulation step then calculates the running total of meetings at each time, effectively tracking how many meetings are ongoing at any given time.
       </li>
       <li>
        The maximum value in this accumulated array gives the highest number of simultaneous meetings, which in this case would require an equal number of meeting rooms.
       </li>
      </ul>
      <h3 id="efficiency">
       Efficiency:
      </h3>
      <p>
       This solution is efficient because it condenses the problem into a single pass through a fixed-size array (assuming meeting times are bounded by the arrayâs size) and a single pass to accumulate changes, both of which are linear operations. The overall time complexity is (O(N + T)), where (N) is the number of intervals and (T) is the fixed size of the
       <code class="language-plaintext highlighter-rouge">
        delta
       </code>
       array, making it highly efficient for the given problem constraints.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#d148e584-64dd-4175-8365-ec46586d9f94'}">
       <li class="uk-active">
        <a href="solution-253.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-253.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-253.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-253.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-253.html">
         RenderScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="d148e584-64dd-4175-8365-ec46586d9f94">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minMeetingRooms</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1000010</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">delta</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">e</span> <span class="o">:</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">++</span><span class="n">delta</span><span class="o">[</span><span class="n">e</span><span class="o">[</span><span class="mi">0</span><span class="o">]];</span>
            <span class="o">--</span><span class="n">delta</span><span class="o">[</span><span class="n">e</span><span class="o">[</span><span class="mi">1</span><span class="o">]];</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">delta</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">delta</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">delta</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">delta</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">minMeetingRooms</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">intervals</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1000010</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">delta</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">e</span> <span class="o">:</span> <span class="n">intervals</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">++</span><span class="n">delta</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
            <span class="o">--</span><span class="n">delta</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]];</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">delta</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">max_element</span><span class="p">(</span><span class="n">delta</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">delta</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="s">'''
data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]

list(accumulate(data, operator.mul))     # running product
[3, 12, 72, 144, 144, 1296, 0, 0, 0, 0]

list(accumulate(data, max))              # running maximum
[3, 4, 6, 6, 6, 9, 9, 9, 9, 9]


&gt;&gt;&gt; from itertools import accumulate
&gt;&gt;&gt; data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]
&gt;&gt;&gt; accumulate(data)
&lt;itertools.accumulate object at 0x10fd78440&gt;
&gt;&gt;&gt; list(accumulate(data))
[3, 7, 13, 15, 16, 25, 25, 32, 37, 45]
&gt;&gt;&gt; max(accumulate(data))
45

https://docs.python.org/3/library/itertools.html#itertools.accumulate


# Amortize a 5% loan of 1000 with 4 annual payments of 90
cashflows = [1000, -90, -90, -90, -90]
list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt))
[1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001]
'''</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minMeetingRooms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1000010</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">:</span>
            <span class="n">delta</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">delta</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">accumulate</span><span class="p">(</span><span class="n">delta</span><span class="p">))</span>
        <span class="c1"># why not delta.sort()?
</span>        <span class="c1"># because accumulate() will go by order from index 0 to index final
</span>        <span class="c1"># just like, from sortedcontainers import SortedDict
</span>
<span class="c1">############
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">minMeetingRooms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">):</span>
    <span class="s">"""
    :type intervals: List[Interval]
    :rtype: int
    """</span>
    <span class="n">meetings</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">:</span>
      <span class="n">meetings</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
      <span class="n">meetings</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">.</span><span class="n">end</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">meetings</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">meeting</span> <span class="ow">in</span> <span class="n">meetings</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">meeting</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ans</span>


</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">minMeetingRooms</span><span class="p">(</span><span class="n">intervals</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="m">1000010</span>
	<span class="n">delta</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">intervals</span> <span class="p">{</span>
		<span class="n">delta</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="m">0</span><span class="p">]]</span><span class="o">++</span>
		<span class="n">delta</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="m">1</span><span class="p">]]</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">slices</span><span class="o">.</span><span class="n">Max</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-rs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::{</span> <span class="nn">collections</span><span class="p">::</span><span class="n">BinaryHeap</span><span class="p">,</span> <span class="nn">cmp</span><span class="p">::</span><span class="n">Reverse</span> <span class="p">};</span>

<span class="k">impl</span> <span class="n">Solution</span> <span class="p">{</span>
    <span class="nd">#[allow(dead_code)]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">min_meeting_rooms</span><span class="p">(</span><span class="n">intervals</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="c1">// The min heap that stores the earliest ending time among all meeting rooms</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">pq</span> <span class="o">=</span> <span class="nn">BinaryHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">intervals</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">intervals</span><span class="nf">.len</span><span class="p">();</span>

        <span class="c1">// Let's first sort the intervals vector</span>
        <span class="n">intervals</span><span class="nf">.sort_by</span><span class="p">(|</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">|</span> <span class="p">{</span> <span class="n">lhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">});</span>

        <span class="c1">// Push the first end time to the heap</span>
        <span class="n">pq</span><span class="nf">.push</span><span class="p">(</span><span class="nf">Reverse</span><span class="p">(</span><span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]));</span>

        <span class="c1">// Traverse the intervals vector</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
            <span class="c1">// Get the current top element from the heap</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="nf">Reverse</span><span class="p">(</span><span class="n">end_time</span><span class="p">))</span> <span class="o">=</span> <span class="n">pq</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">end_time</span> <span class="o">&lt;=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
                    <span class="c1">// If the end time is early than the current begin time</span>
                    <span class="k">let</span> <span class="n">new_end_time</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
                    <span class="n">pq</span><span class="nf">.push</span><span class="p">(</span><span class="nf">Reverse</span><span class="p">(</span><span class="n">new_end_time</span><span class="p">));</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// Otherwise, push the end time back and we also need a new room</span>
                    <span class="n">pq</span><span class="nf">.push</span><span class="p">(</span><span class="nf">Reverse</span><span class="p">(</span><span class="n">end_time</span><span class="p">));</span>
                    <span class="n">pq</span><span class="nf">.push</span><span class="p">(</span><span class="nf">Reverse</span><span class="p">(</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]));</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">pq</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">i32</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-253.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
