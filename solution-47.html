<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-47.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-47.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>47 - Permutations II</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 47. Permutations II Description Given a collection of numbers, nums,&amp;nbsp;that might contain duplicates, return all possible unique permutations in any order. &amp;nbsp; Example 1: Input: nums = [1,1,2] Output: [[1,1,2], [1,2,1], [2,1,1]] Example 2: Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] &amp;nbsp; Constraints: 1 &amp;lt;= nums.length...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-47.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-47.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-47.html" rel="stylesheet"/>
   <link href="solution-47.html" rel="stylesheet"/>
   <link href="solution-47.html" rel="stylesheet"/>
   <link href="solution-47.html" rel="stylesheet"/>
   <link href="solution-47.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="47 - Permutations II" property="og:title"/>
   <meta content="Leetcode 47. Permutations II Description Given a collection of numbers, nums,&amp;nbsp;that might contain duplicates, return all possible unique permutations in any order. &amp;nbsp; Example 1: Input: nums = [1,1,2] Output: [[1,1,2], [1,2,1], [2,1,1]] Example 2: Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] &amp;nbsp; Constraints: 1 &amp;lt;= nums.length &amp;lt;= 8 -10 &amp;lt;= nums[i] &amp;lt;= 10 Solutions Solution 1: Sorting + Backtracking We can first sort the array, which allows us to place duplicate numbers together, making it easier for us to remove duplicates. Next, we design a function $dfs(i)$, indicating that we need to fill in the number at the $i$th position. The specific implementation of the function is as follows: If $i = n$, it means we have finished filling in, add the current permutation to the answer array, and then return. Otherwise, we enumerate the number $nums[j]$ at the $i$th position, where the range of $j$ is $[0, n - 1]$. We need to ensure that $nums[j]$ has not been used and is different from the number enumerated before, so as to ensure that the current permutation is not repeated. If the conditions are met, we can fill in $nums[j]$, and continue to recursively fill in the next position, that is, call $dfs(i + 1)$. After the recursive call ends, we need to mark $nums[j]$ as unused for later enumeration. In the main function, we first sort the array, then call $dfs(0)$, that is, start filling from the 0th position, and finally return the answer array. The time complexity is $O(n \times n!)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array. We need to enumerate $n!$ times, and each enumeration takes $O(n)$ time to judge whether it is repeated. In addition, we need a marker array to mark whether each position has been used, so the space complexity is $O(n)$. In python solution, why conditional statement if i &amp;gt; 0 and perm[i - 1] == num: The conditional statement if i &amp;gt; 0 and perm[i - 1] == num: in the provided code is crucial for eliminating duplicate permutations when generating all unique permutations of a list of numbers, some of which may be duplicates. This line is the key to handling duplicates effectively, ensuring that each unique permutation is only added once to the result. Explanation with Example Suppose nums = [1, 1, 2]. After sorting, nums remains [1, 1, 2]. Initially, res = [[]], meaning we start with an empty permutation. When the first 1 is processed, it can be inserted into the empty list in one position, resulting in [[1]]. As we process the second 1, the condition if i &amp;gt; 0 and perm[i - 1] == num: becomes important. Without this check, inserting the second 1 into [1] would produce two identical permutations: [1, 1] and [1, 1], because the second 1 can be placed at two different positions (at the start and after the first 1), but both positions result in the same list due..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-01-16T00:00:00-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-01-16-47-Permutations-II/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-47.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="47 - Permutations II" property="twitter:title"/>
   <meta content="Leetcode 47. Permutations II Description Given a collection of numbers, nums,&amp;nbsp;that might contain duplicates, return all possible unique permutations in any order. &amp;nbsp; Example 1: Input: nums = [1,1,2] Output: [[1,1,2], [1,2,1], [2,1,1]] Example 2: Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] &amp;nbsp; Constraints: 1 &amp;lt;= nums.length &amp;lt;= 8 -10 &amp;lt;= nums[i] &amp;lt;= 10 Solutions Solution 1: Sorting + Backtracking We can first sort the array, which allows us to place duplicate numbers together, making it easier for us to remove duplicates. Next, we design a function $dfs(i)$, indicating that we need to fill in the number at the $i$th position. The specific implementation of the function is as follows: If $i = n$, it means we have finished filling in, add the current permutation to the answer array, and then return. Otherwise, we enumerate the number $nums[j]$ at the $i$th position, where the range of $j$ is $[0, n - 1]$. We need to ensure that $nums[j]$ has not been used and is different from the number enumerated before, so as to ensure that the current permutation is not repeated. If the conditions are met, we can fill in $nums[j]$, and continue to recursively fill in the next position, that is, call $dfs(i + 1)$. After the recursive call ends, we need to mark $nums[j]$ as unused for later enumeration. In the main function, we first sort the array, then call $dfs(0)$, that is, start filling from the 0th position, and finally return the answer array. The time complexity is $O(n \times n!)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array. We need to enumerate $n!$ times, and each enumeration takes $O(n)$ time to judge whether it is repeated. In addition, we need a marker array to mark whether each position has been used, so the space complexity is $O(n)$. In python solution, why conditional statement if i &amp;gt; 0 and perm[i - 1] == num: The conditional statement if i &amp;gt; 0 and perm[i - 1] == num: in the provided code is crucial for eliminating duplicate permutations when generating all unique permutations of a list of numbers, some of which may be duplicates. This line is the key to handling duplicates effectively, ensuring that each unique permutation is only added once to the result. Explanation with Example Suppose nums = [1, 1, 2]. After sorting, nums remains [1, 1, 2]. Initially, res = [[]], meaning we start with an empty permutation. When the first 1 is processed, it can be inserted into the empty list in one position, resulting in [[1]]. As we process the second 1, the condition if i &amp;gt; 0 and perm[i - 1] == num: becomes important. Without this check, inserting the second 1 into [1] would produce two identical permutations: [1, 1] and [1, 1], because the second 1 can be placed at two different positions (at the start and after the first 1), but both positions result in the same list due..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    47 - Permutations II | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="47 - Permutations II" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-47.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-01-16-47-Permutations-II/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-01-16T00:00:00-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"47 - Permutations II","dateModified":"2016-01-16T00:00:00-08:00","datePublished":"2016-01-16T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-01-16-47-Permutations-II/"},"url":"https://leetcode.ca/2016-01-16-47-Permutations-II/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="47-permutations-ii">
       <a href="solution-47.html">
        47. Permutations II
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given a collection of numbers,
       <code>
        nums
       </code>
       , that might contain duplicates, return
       <em>
        all possible unique permutations
        <strong>
         in any order
        </strong>
        .
       </em>
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> nums = [1,1,2]
<strong>Output:</strong>
[[1,1,2],
 [1,2,1],
 [2,1,1]]
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= nums.length &lt;= 8
        </code>
       </li>
       <li>
        <code>
         -10 &lt;= nums[i] &lt;= 10
        </code>
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       <strong>
        Solution 1: Sorting + Backtracking
       </strong>
      </p>
      <p>
       We can first sort the array, which allows us to place duplicate numbers together, making it easier for us to remove duplicates.
      </p>
      <p>
       Next, we design a function $dfs(i)$, indicating that we need to fill in the number at the $i$th position. The specific implementation of the function is as follows:
      </p>
      <ul>
       <li>
        If $i = n$, it means we have finished filling in, add the current permutation to the answer array, and then return.
       </li>
       <li>
        Otherwise, we enumerate the number $nums[j]$ at the $i$th position, where the range of $j$ is $[0, n - 1]$. We need to ensure that $nums[j]$ has not been used and is different from the number enumerated before, so as to ensure that the current permutation is not repeated. If the conditions are met, we can fill in $nums[j]$, and continue to recursively fill in the next position, that is, call $dfs(i + 1)$. After the recursive call ends, we need to mark $nums[j]$ as unused for later enumeration.
       </li>
      </ul>
      <p>
       In the main function, we first sort the array, then call $dfs(0)$, that is, start filling from the 0th position, and finally return the answer array.
      </p>
      <p>
       The time complexity is $O(n \times n!)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array. We need to enumerate $n!$ times, and each enumeration takes $O(n)$ time to judge whether it is repeated. In addition, we need a marker array to mark whether each position has been used, so the space complexity is $O(n)$.
      </p>
      <h3 id="in-python-solution-why-conditional-statement-if-i--0-and-permi---1--num">
       In python solution, why conditional statement
       <code class="language-plaintext highlighter-rouge">
        if i &gt; 0 and perm[i - 1] == num:
       </code>
      </h3>
      <p>
       The conditional statement
       <code class="language-plaintext highlighter-rouge">
        if i &gt; 0 and perm[i - 1] == num:
       </code>
       in the provided code is crucial for eliminating duplicate permutations when generating all unique permutations of a list of numbers, some of which may be duplicates. This line is the
       <code class="language-plaintext highlighter-rouge">
        key to handling duplicates
       </code>
       effectively, ensuring that each unique permutation is only added once to the result.
      </p>
      <h3 id="explanation-with-example">
       Explanation with Example
      </h3>
      <p>
       Suppose
       <code class="language-plaintext highlighter-rouge">
        nums = [1, 1, 2]
       </code>
       . After sorting,
       <code class="language-plaintext highlighter-rouge">
        nums
       </code>
       remains
       <code class="language-plaintext highlighter-rouge">
        [1, 1, 2]
       </code>
       .
      </p>
      <ul>
       <li>
        Initially,
        <code class="language-plaintext highlighter-rouge">
         res = [[]]
        </code>
        , meaning we start with an empty permutation.
       </li>
       <li>
        When the first
        <code class="language-plaintext highlighter-rouge">
         1
        </code>
        is processed, it can be inserted into the empty list in one position, resulting in
        <code class="language-plaintext highlighter-rouge">
         [[1]]
        </code>
        .
       </li>
       <li>
        As we process the second
        <code class="language-plaintext highlighter-rouge">
         1
        </code>
        , the condition
        <code class="language-plaintext highlighter-rouge">
         if i &gt; 0 and perm[i - 1] == num:
        </code>
        becomes important. Without this check, inserting the second
        <code class="language-plaintext highlighter-rouge">
         1
        </code>
        into
        <code class="language-plaintext highlighter-rouge">
         [1]
        </code>
        would produce two identical permutations:
        <code class="language-plaintext highlighter-rouge">
         [1, 1]
        </code>
        and
        <code class="language-plaintext highlighter-rouge">
         [1, 1]
        </code>
        , because the second
        <code class="language-plaintext highlighter-rouge">
         1
        </code>
        can be placed at two different positions (at the start and after the first
        <code class="language-plaintext highlighter-rouge">
         1
        </code>
        ), but both positions result in the same list due to the numbers being identical.
       </li>
      </ul>
      <h3 id="why-the-condition-works">
       Why the Condition Works
      </h3>
      <ul>
       <li>
        <strong>
         <code class="language-plaintext highlighter-rouge">
          i &gt; 0
         </code>
        </strong>
        : This ensures the check is only made if thereâs a previous element in the current permutation to compare with. It prevents an index out of range error and ensures weâre only checking for duplicates when thereâs something to compare to.
       </li>
       <li>
        <strong>
         <code class="language-plaintext highlighter-rouge">
          perm[i - 1] == num
         </code>
        </strong>
        : This checks if the current number (
        <code class="language-plaintext highlighter-rouge">
         num
        </code>
        ) is the same as the number immediately before the current insertion point (
        <code class="language-plaintext highlighter-rouge">
         perm[i - 1]
        </code>
        ). If true, it means inserting
        <code class="language-plaintext highlighter-rouge">
         num
        </code>
        at this point would result in a duplicate permutation thatâs already been or will be generated by inserting
        <code class="language-plaintext highlighter-rouge">
         num
        </code>
        at an earlier point.
       </li>
      </ul>
      <p>
       By breaking the loop when this condition is met, we skip over any insertion points that would lead to duplicate permutations, as any further insertions of the same number would only replicate sequences already considered.
      </p>
      <h3 id="result">
       Result
      </h3>
      <ul>
       <li>
        The loop
        <code class="language-plaintext highlighter-rouge">
         break
        </code>
        effectively prunes the search space, preventing the generation of duplicate permutations and ensuring the uniqueness of each permutation in
        <code class="language-plaintext highlighter-rouge">
         res
        </code>
        .
       </li>
      </ul>
      <h3 id="detailed-walkthrough">
       Detailed Walkthrough
      </h3>
      <ul>
       <li>
        For
        <code class="language-plaintext highlighter-rouge">
         nums = [1, 1, 2]
        </code>
        , and currently processing the second
        <code class="language-plaintext highlighter-rouge">
         1
        </code>
        , we attempt to insert it into existing permutations of
        <code class="language-plaintext highlighter-rouge">
         res
        </code>
        .
       </li>
       <li>
        The first insertion position is before the first
        <code class="language-plaintext highlighter-rouge">
         1
        </code>
        in
        <code class="language-plaintext highlighter-rouge">
         [1]
        </code>
        , yielding
        <code class="language-plaintext highlighter-rouge">
         [1, 1]
        </code>
        .
       </li>
       <li>
        The second possible position is after the first
        <code class="language-plaintext highlighter-rouge">
         1
        </code>
        in
        <code class="language-plaintext highlighter-rouge">
         [1]
        </code>
        , but
        <code class="language-plaintext highlighter-rouge">
         if i &gt; 0 and perm[i - 1] == num:
        </code>
        triggers because
        <code class="language-plaintext highlighter-rouge">
         perm[i - 1]
        </code>
        is also
        <code class="language-plaintext highlighter-rouge">
         1
        </code>
        . The condition tells us inserting
        <code class="language-plaintext highlighter-rouge">
         1
        </code>
        here would duplicate the permutation just created, so we
        <code class="language-plaintext highlighter-rouge">
         break
        </code>
        and avoid further insertions.
       </li>
      </ul>
      <p>
       This strategy ensures the algorithm generates all unique permutations of a set, including when duplicates are present, by methodically avoiding duplicate sequence generation through strategic pruning.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#06424752-d3c5-45e0-a2b1-ea95c3891f11'}">
       <li class="uk-active">
        <a href="solution-47.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-47.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-47.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-47.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-47.html">
         TypeScript
        </a>
       </li>
       <li>
        <a href="solution-47.html">
         C#
        </a>
       </li>
       <li>
        <a href="solution-47.html">
         RenderScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="06424752-d3c5-45e0-a2b1-ea95c3891f11">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">vis</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">permuteUnique</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nums</span> <span class="o">=</span> <span class="n">nums</span><span class="o">;</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="n">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">t</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">vis</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">||</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vis</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]))</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">t</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
            <span class="n">vis</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">vis</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">t</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">permuteUnique</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">vis</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ans</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                <span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>
        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span> <span class="c1"># iterative, if new_perm not in new_res
</span>    <span class="k">def</span> <span class="nf">permuteUnique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[[]]</span>

        <span class="k">if</span> <span class="n">nums</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="n">new_res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">new_perm</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">+</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
                    <span class="k">if</span> <span class="n">new_perm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_res</span><span class="p">:</span>  <span class="c1"># Check for uniqueness
</span>                        <span class="n">new_res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_perm</span><span class="p">)</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">new_res</span>

        <span class="k">return</span> <span class="n">res</span>

<span class="c1">##############
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span> <span class="c1"># iterative
</span>    <span class="k">def</span> <span class="nf">permuteUnique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">nums</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span> <span class="c1"># sort the input to handle duplicates
</span>        <span class="n">res</span> <span class="o">=</span> <span class="p">[[]]</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="n">new_res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">:</span>
                    <span class="c1"># added for lc-47, as explained above "Why the Condition Works"
</span>                        <span class="k">break</span> <span class="c1"># skip duplicate
</span>                    <span class="n">new_perm</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">+</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
                    <span class="c1"># or perm.insert(index, num), like in lc-46
</span>                    <span class="n">new_res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_perm</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">new_res</span>
        <span class="k">return</span> <span class="n">res</span>

<span class="c1">############
</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span> <span class="c1"># dfs
</span>    <span class="k">def</span> <span class="nf">permuteUnique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[:])</span>
                <span class="k">return</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">or</span> <span class="p">(</span><span class="n">j</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>
                    <span class="k">continue</span>
                <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">nums</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">permuteUnique</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">ans</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">sort</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
	<span class="n">t</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="n">vis</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">bool</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span> <span class="p">{</span>
			<span class="n">ans</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">slices</span><span class="o">.</span><span class="n">Clone</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="m">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="m">1</span><span class="p">])</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="no">true</span>
			<span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
			<span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="m">1</span><span class="p">)</span>
			<span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="no">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">dfs</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">function</span> <span class="nx">permuteUnique</span><span class="p">(</span><span class="nx">nums</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]):</span> <span class="kr">number</span><span class="p">[][]</span> <span class="p">{</span>
    <span class="nx">nums</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">ans</span><span class="p">:</span> <span class="kr">number</span><span class="p">[][]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">const</span> <span class="nx">t</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">vis</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">i</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">ans</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">slice</span><span class="p">());</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="o">++</span><span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">vis</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">===</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">vis</span><span class="p">[</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
            <span class="nx">vis</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
            <span class="nx">dfs</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="nx">vis</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="nx">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">ans</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">IList</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;&gt;</span> <span class="n">ans</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">IList</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;&gt;();</span>
    <span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>
    <span class="k">private</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">nums</span><span class="p">;</span>
    <span class="k">private</span> <span class="kt">bool</span><span class="p">[]</span> <span class="n">vis</span><span class="p">;</span>

    <span class="k">public</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IList</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;&gt;</span> <span class="nf">PermuteUnique</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Array</span><span class="p">.</span><span class="nf">Sort</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
        <span class="n">vis</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">bool</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
        <span class="k">this</span><span class="p">.</span><span class="n">nums</span> <span class="p">=</span> <span class="n">nums</span><span class="p">;</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="m">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">==</span> <span class="n">nums</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ans</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="n">t</span><span class="p">));</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="p">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="p">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">||</span> <span class="p">(</span><span class="n">j</span> <span class="p">&gt;</span> <span class="m">0</span> <span class="p">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span> <span class="p">-</span> <span class="m">1</span><span class="p">]</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">vis</span><span class="p">[</span><span class="n">j</span> <span class="p">-</span> <span class="m">1</span><span class="p">]))</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">t</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
            <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">);</span>
            <span class="n">t</span><span class="p">.</span><span class="nf">RemoveAt</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">Count</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
            <span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-rs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Solution</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">res</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span> <span class="p">{</span>
            <span class="n">res</span><span class="nf">.push</span><span class="p">(</span><span class="n">nums</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">set</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="n">i</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">set</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">set</span><span class="nf">.insert</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
            <span class="n">nums</span><span class="nf">.swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
            <span class="k">Self</span><span class="p">::</span><span class="nf">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
            <span class="n">nums</span><span class="nf">.swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">permute_unique</span><span class="p">(</span><span class="k">mut</span> <span class="n">nums</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
        <span class="k">Self</span><span class="p">::</span><span class="nf">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">nums</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">res</span><span class="p">);</span>
        <span class="n">res</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-47.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
