<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-291.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-291.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>291 - Word Pattern II</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 291. Word Pattern II Description Given a pattern and a string s, return true if s matches the pattern. A string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-291.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-291.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-291.html" rel="stylesheet"/>
   <link href="solution-291.html" rel="stylesheet"/>
   <link href="solution-291.html" rel="stylesheet"/>
   <link href="solution-291.html" rel="stylesheet"/>
   <link href="solution-291.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="291 - Word Pattern II" property="og:title"/>
   <meta content="Leetcode 291. Word Pattern II Description Given a pattern and a string s, return true if s matches the pattern. A string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings. &amp;nbsp; Example 1: Input: pattern = &amp;quot;abab&amp;quot;, s = &amp;quot;redblueredblue&amp;quot; Output: true Explanation: One possible mapping is as follows: &amp;#39;a&amp;#39; -&amp;gt; &amp;quot;red&amp;quot; &amp;#39;b&amp;#39; -&amp;gt; &amp;quot;blue&amp;quot; Example 2: Input: pattern = &amp;quot;aaaa&amp;quot;, s = &amp;quot;asdasdasdasd&amp;quot; Output: true Explanation: One possible mapping is as follows: &amp;#39;a&amp;#39; -&amp;gt; &amp;quot;asd&amp;quot; Example 3: Input: pattern = &amp;quot;aabb&amp;quot;, s = &amp;quot;xyzabcxzyabc&amp;quot; Output: false &amp;nbsp; Constraints: 1 &amp;lt;= pattern.length, s.length &amp;lt;= 20 pattern and s consist of only lowercase English letters. Solutions This solution code defines a solution to a pattern matching problem, where the goal is to determine if a given string s can be segmented in a way that matches a given pattern pattern. Each character in pattern represents a distinct part of s, and the same character in pattern should map to the same segment in s. The solution employs Depth-First Search (DFS) to explore all possible ways of segmenting s to match the pattern. Hereâs a detailed breakdown of how the code works: Function: wordPatternMatch Parameters: It takes a pattern (a string where each character represents a pattern to match) and s (the string to be matched against the pattern). Helper Function: dfs Purpose: The dfs function is a recursive helper function that attempts to match the pattern with segments of s. It uses two additional lists, pathp and paths, to keep track of the current segment mappings from pattern to s. Base Case: The recursion ends successfully (return True) if both p (remaining pattern) and s (remaining string) are empty, meaning a complete match has been found. It returns False if p is empty but s is not, or if the remaining pattern length is greater than the remaining string length, indicating a mismatch. Recursion and Backtracking: The function iterates through s, trying to match the current character in pattern (p[0]) with every possible leading segment of s. At each iteration, it adds the current pattern character to pathp and the current segment being considered (s[:i + 1]) to paths. It checks for a valid mapping: if the lengths of pathp and paths are equal, and the number of unique elements in paths, pathp, and their zipped combination (pairs of pattern and corresponding segment) are the same. This condition ensures that each character in the pattern maps to a unique and consistent segment in s. If the condition is met, it recursively calls dfs with the next character in the pattern and the remaining string, excluding the current segment. If the recursive call returns True, indicating a successful..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-09-16T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-09-16-291-Word-Pattern-II/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-291.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="291 - Word Pattern II" property="twitter:title"/>
   <meta content="Leetcode 291. Word Pattern II Description Given a pattern and a string s, return true if s matches the pattern. A string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings. &amp;nbsp; Example 1: Input: pattern = &amp;quot;abab&amp;quot;, s = &amp;quot;redblueredblue&amp;quot; Output: true Explanation: One possible mapping is as follows: &amp;#39;a&amp;#39; -&amp;gt; &amp;quot;red&amp;quot; &amp;#39;b&amp;#39; -&amp;gt; &amp;quot;blue&amp;quot; Example 2: Input: pattern = &amp;quot;aaaa&amp;quot;, s = &amp;quot;asdasdasdasd&amp;quot; Output: true Explanation: One possible mapping is as follows: &amp;#39;a&amp;#39; -&amp;gt; &amp;quot;asd&amp;quot; Example 3: Input: pattern = &amp;quot;aabb&amp;quot;, s = &amp;quot;xyzabcxzyabc&amp;quot; Output: false &amp;nbsp; Constraints: 1 &amp;lt;= pattern.length, s.length &amp;lt;= 20 pattern and s consist of only lowercase English letters. Solutions This solution code defines a solution to a pattern matching problem, where the goal is to determine if a given string s can be segmented in a way that matches a given pattern pattern. Each character in pattern represents a distinct part of s, and the same character in pattern should map to the same segment in s. The solution employs Depth-First Search (DFS) to explore all possible ways of segmenting s to match the pattern. Hereâs a detailed breakdown of how the code works: Function: wordPatternMatch Parameters: It takes a pattern (a string where each character represents a pattern to match) and s (the string to be matched against the pattern). Helper Function: dfs Purpose: The dfs function is a recursive helper function that attempts to match the pattern with segments of s. It uses two additional lists, pathp and paths, to keep track of the current segment mappings from pattern to s. Base Case: The recursion ends successfully (return True) if both p (remaining pattern) and s (remaining string) are empty, meaning a complete match has been found. It returns False if p is empty but s is not, or if the remaining pattern length is greater than the remaining string length, indicating a mismatch. Recursion and Backtracking: The function iterates through s, trying to match the current character in pattern (p[0]) with every possible leading segment of s. At each iteration, it adds the current pattern character to pathp and the current segment being considered (s[:i + 1]) to paths. It checks for a valid mapping: if the lengths of pathp and paths are equal, and the number of unique elements in paths, pathp, and their zipped combination (pairs of pattern and corresponding segment) are the same. This condition ensures that each character in the pattern maps to a unique and consistent segment in s. If the condition is met, it recursively calls dfs with the next character in the pattern and the remaining string, excluding the current segment. If the recursive call returns True, indicating a successful..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    291 - Word Pattern II | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="291 - Word Pattern II" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-291.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-09-16-291-Word-Pattern-II/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-09-16T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"291 - Word Pattern II","dateModified":"2016-09-16T00:00:00-07:00","datePublished":"2016-09-16T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-09-16-291-Word-Pattern-II/"},"url":"https://leetcode.ca/2016-09-16-291-Word-Pattern-II/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="291-word-pattern-ii">
       <a href="solution-291.html">
        291. Word Pattern II
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given a
       <code>
        pattern
       </code>
       and a string
       <code>
        s
       </code>
       , return
       <code>
        true
       </code>
       <em>
        if
       </em>
       <code>
        s
       </code>
       <em>
        <strong>
         matches
        </strong>
        the
       </em>
       <code>
        pattern
       </code>
       <em>
        .
       </em>
      </p>
      <p>
       A string
       <code>
        s
       </code>
       <b>
        matches
       </b>
       a
       <code>
        pattern
       </code>
       if there is some
       <strong>
        bijective mapping
       </strong>
       of single characters to
       <strong>
        non-empty
       </strong>
       strings such that if each character in
       <code>
        pattern
       </code>
       is replaced by the string it maps to, then the resulting string is
       <code>
        s
       </code>
       . A
       <strong>
        bijective mapping
       </strong>
       means that no two characters map to the same string, and no character maps to two different strings.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> pattern = "abab", s = "redblueredblue"
<strong>Output:</strong> true
<strong>Explanation:</strong> One possible mapping is as follows:
'a' -&gt; "red"
'b' -&gt; "blue"</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> pattern = "aaaa", s = "asdasdasdasd"
<strong>Output:</strong> true
<strong>Explanation:</strong> One possible mapping is as follows:
'a' -&gt; "asd"
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> pattern = "aabb", s = "xyzabcxzyabc"
<strong>Output:</strong> false
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= pattern.length, s.length &lt;= 20
        </code>
       </li>
       <li>
        <code>
         pattern
        </code>
        and
        <code>
         s
        </code>
        consist of only lowercase English letters.
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       This solution code defines a solution to a pattern matching problem, where the goal is to determine if a given string
       <code class="language-plaintext highlighter-rouge">
        s
       </code>
       can be segmented in a way that matches a given pattern
       <code class="language-plaintext highlighter-rouge">
        pattern
       </code>
       . Each character in
       <code class="language-plaintext highlighter-rouge">
        pattern
       </code>
       represents a distinct part of
       <code class="language-plaintext highlighter-rouge">
        s
       </code>
       , and the same character in
       <code class="language-plaintext highlighter-rouge">
        pattern
       </code>
       should map to the same segment in
       <code class="language-plaintext highlighter-rouge">
        s
       </code>
       .
      </p>
      <p>
       The solution employs Depth-First Search (DFS) to explore all possible ways of segmenting
       <code class="language-plaintext highlighter-rouge">
        s
       </code>
       to match the
       <code class="language-plaintext highlighter-rouge">
        pattern
       </code>
       . Hereâs a detailed breakdown of how the code works:
      </p>
      <h3 id="function-wordpatternmatch">
       Function:
       <code class="language-plaintext highlighter-rouge">
        wordPatternMatch
       </code>
      </h3>
      <ul>
       <li>
        <strong>
         Parameters
        </strong>
        : It takes a
        <code class="language-plaintext highlighter-rouge">
         pattern
        </code>
        (a string where each character represents a pattern to match) and
        <code class="language-plaintext highlighter-rouge">
         s
        </code>
        (the string to be matched against the pattern).
       </li>
      </ul>
      <h3 id="helper-function-dfs">
       Helper Function:
       <code class="language-plaintext highlighter-rouge">
        dfs
       </code>
      </h3>
      <ul>
       <li>
        <p>
         <strong>
          Purpose
         </strong>
         : The
         <code class="language-plaintext highlighter-rouge">
          dfs
         </code>
         function is a recursive helper function that attempts to match the
         <code class="language-plaintext highlighter-rouge">
          pattern
         </code>
         with segments of
         <code class="language-plaintext highlighter-rouge">
          s
         </code>
         . It uses two additional lists,
         <code class="language-plaintext highlighter-rouge">
          pathp
         </code>
         and
         <code class="language-plaintext highlighter-rouge">
          paths
         </code>
         , to keep track of the current segment mappings from
         <code class="language-plaintext highlighter-rouge">
          pattern
         </code>
         to
         <code class="language-plaintext highlighter-rouge">
          s
         </code>
         .
        </p>
       </li>
       <li>
        <p>
         <strong>
          Base Case
         </strong>
         : The recursion ends successfully (
         <code class="language-plaintext highlighter-rouge">
          return True
         </code>
         ) if both
         <code class="language-plaintext highlighter-rouge">
          p
         </code>
         (remaining pattern) and
         <code class="language-plaintext highlighter-rouge">
          s
         </code>
         (remaining string) are empty, meaning a complete match has been found. It returns
         <code class="language-plaintext highlighter-rouge">
          False
         </code>
         if
         <code class="language-plaintext highlighter-rouge">
          p
         </code>
         is empty but
         <code class="language-plaintext highlighter-rouge">
          s
         </code>
         is not, or if the remaining pattern length is greater than the remaining string length, indicating a mismatch.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Recursion and Backtracking
         </strong>
         :
        </p>
        <ul>
         <li>
          The function iterates through
          <code class="language-plaintext highlighter-rouge">
           s
          </code>
          , trying to match the current character in
          <code class="language-plaintext highlighter-rouge">
           pattern
          </code>
          (
          <code class="language-plaintext highlighter-rouge">
           p[0]
          </code>
          ) with every possible leading segment of
          <code class="language-plaintext highlighter-rouge">
           s
          </code>
          .
         </li>
         <li>
          At each iteration, it adds the current pattern character to
          <code class="language-plaintext highlighter-rouge">
           pathp
          </code>
          and the current segment being considered (
          <code class="language-plaintext highlighter-rouge">
           s[:i + 1]
          </code>
          ) to
          <code class="language-plaintext highlighter-rouge">
           paths
          </code>
          .
         </li>
         <li>
          It checks for a valid mapping: if the lengths of
          <code class="language-plaintext highlighter-rouge">
           pathp
          </code>
          and
          <code class="language-plaintext highlighter-rouge">
           paths
          </code>
          are equal, and the number of unique elements in
          <code class="language-plaintext highlighter-rouge">
           paths
          </code>
          ,
          <code class="language-plaintext highlighter-rouge">
           pathp
          </code>
          , and their zipped combination (pairs of pattern and corresponding segment) are the same. This condition ensures that each character in the pattern maps to a unique and consistent segment in
          <code class="language-plaintext highlighter-rouge">
           s
          </code>
          .
          <ul>
           <li>
            If the condition is met, it recursively calls
            <code class="language-plaintext highlighter-rouge">
             dfs
            </code>
            with the next character in the pattern and the remaining string, excluding the current segment.
           </li>
           <li>
            If the recursive call returns
            <code class="language-plaintext highlighter-rouge">
             True
            </code>
            , indicating a successful match for the remaining pattern and string, the current call also returns
            <code class="language-plaintext highlighter-rouge">
             True
            </code>
            .
           </li>
          </ul>
         </li>
         <li>
          Implements backtracking by removing the last added elements from
          <code class="language-plaintext highlighter-rouge">
           pathp
          </code>
          and
          <code class="language-plaintext highlighter-rouge">
           paths
          </code>
          before moving to the next iteration.
         </li>
         <li>
          Returns
          <code class="language-plaintext highlighter-rouge">
           False
          </code>
          if no valid mapping is found for any segment of
          <code class="language-plaintext highlighter-rouge">
           s
          </code>
          against the current character in
          <code class="language-plaintext highlighter-rouge">
           pattern
          </code>
          .
         </li>
        </ul>
       </li>
      </ul>
      <h3 id="return-value">
       Return Value
      </h3>
      <ul>
       <li>
        The initial call to
        <code class="language-plaintext highlighter-rouge">
         dfs
        </code>
        starts with the full
        <code class="language-plaintext highlighter-rouge">
         pattern
        </code>
        and
        <code class="language-plaintext highlighter-rouge">
         s
        </code>
        , along with empty lists for
        <code class="language-plaintext highlighter-rouge">
         pathp
        </code>
        and
        <code class="language-plaintext highlighter-rouge">
         paths
        </code>
        . The return value of this call determines whether a valid pattern match exists for the entire string
        <code class="language-plaintext highlighter-rouge">
         s
        </code>
        .
       </li>
      </ul>
      <ul class="uk-tab" data-uk-switcher="{connect:'#e3c59827-d031-4463-ae01-49a1cb548efa'}">
       <li class="uk-active">
        <a href="solution-291.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-291.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-291.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-291.html">
         Go
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="e3c59827-d031-4463-ae01-49a1cb548efa">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">vis</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">d</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">p</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">s</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">m</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">wordPatternMatch</span><span class="o">(</span><span class="nc">String</span> <span class="n">pattern</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">p</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">m</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span> <span class="o">||</span> <span class="n">m</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="s">""</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="n">t</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">k</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">d</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vis</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">t</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">d</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
                <span class="n">vis</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">k</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">vis</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
                <span class="n">d</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">wordPatternMatch</span><span class="p">(</span><span class="n">string</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">vis</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">vis</span><span class="p">,</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">m</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span> <span class="o">||</span> <span class="n">m</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">string</span> <span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">j</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vis</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
                <span class="n">vis</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">vis</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
                <span class="n">d</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">wordPatternMatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="s">"""
    :type pattern: str
    :type s: str
    :rtype: bool
    """</span>

    <span class="c1"># pathp: path for pattern
</span>    <span class="c1"># paths: path for matched strings
</span>    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">pathp</span><span class="p">,</span> <span class="n">paths</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
        <span class="n">pathp</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">paths</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">[:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="c1"># same as in Word-Pattern-I, for checking if valid
</span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pathp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">paths</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pathp</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">pathp</span><span class="p">))):</span>
          <span class="k">if</span> <span class="n">dfs</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">pathp</span><span class="p">,</span> <span class="n">paths</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="n">pathp</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">paths</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
      <span class="k">return</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[])</span>

<span class="c1">############
</span>
<span class="s">'''
&gt;&gt;&gt; d = {}
&gt;&gt;&gt; d.get('a')
&gt;&gt;&gt;
&gt;&gt;&gt; r = d.get('a')
&gt;&gt;&gt; r
&gt;&gt;&gt;
&gt;&gt;&gt; if not r:
...     print('aa')
aa
'''</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">wordPatternMatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">-</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">-</span> <span class="n">i</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">:</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">d</span> <span class="ow">and</span> <span class="n">d</span><span class="p">[</span><span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">return</span> <span class="bp">True</span>
                <span class="k">elif</span> <span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span> <span class="ow">and</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vis</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">t</span>
                    <span class="n">vis</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">return</span> <span class="bp">True</span>
                    <span class="n">d</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">vis</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">wordPatternMatch</span><span class="p">(</span><span class="n">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
	<span class="n">vis</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">{}</span>
	<span class="n">d</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">byte</span><span class="p">]</span><span class="kt">string</span><span class="p">{}</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span> <span class="p">{</span>
			<span class="k">return</span> <span class="no">true</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span> <span class="o">||</span> <span class="n">m</span><span class="o">-</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">-</span><span class="n">j</span> <span class="p">{</span>
			<span class="k">return</span> <span class="no">false</span>
		<span class="p">}</span>
		<span class="n">c</span> <span class="o">:=</span> <span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="k">for</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">j</span> <span class="o">+</span> <span class="m">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">t</span> <span class="o">:=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="o">:</span><span class="n">k</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">v</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">];</span> <span class="n">ok</span> <span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="o">==</span> <span class="n">t</span> <span class="p">{</span>
				<span class="k">if</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">return</span> <span class="no">true</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">];</span> <span class="o">!</span><span class="n">ok</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="p">{</span>
				<span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
				<span class="n">vis</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="no">true</span>
				<span class="k">if</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">return</span> <span class="no">true</span>
				<span class="p">}</span>
				<span class="nb">delete</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
				<span class="n">vis</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="no">false</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="no">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-291.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
