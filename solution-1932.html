<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-1932.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-1932.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>1932 - Merge BSTs to Create Single BST</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 1932. Merge BSTs to Create Single BST Description You are given n BST (binary search tree) root nodes for n separate BSTs stored in an array trees (0-indexed). Each BST in trees has at most 3 nodes, and no two roots have the same value....">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-1932.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-1932.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-1932.html" rel="stylesheet"/>
   <link href="solution-1932.html" rel="stylesheet"/>
   <link href="solution-1932.html" rel="stylesheet"/>
   <link href="solution-1932.html" rel="stylesheet"/>
   <link href="solution-1932.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="1932 - Merge BSTs to Create Single BST" property="og:title"/>
   <meta content="Leetcode 1932. Merge BSTs to Create Single BST Description You are given n BST (binary search tree) root nodes for n separate BSTs stored in an array trees (0-indexed). Each BST in trees has at most 3 nodes, and no two roots have the same value. In one operation, you can: Select two distinct indices i and j such that the value stored at one of the leaves of trees[i] is equal to the root value of trees[j]. Replace the leaf node in trees[i] with trees[j]. Remove trees[j] from trees. Return the root of the resulting BST if it is possible to form a valid BST after performing n - 1 operations, or null if it is impossible to create a valid BST. A BST (binary search tree) is a binary tree where each node satisfies the following property: Every node in the node&amp;#39;s left subtree has a value&amp;nbsp;strictly less&amp;nbsp;than the node&amp;#39;s value. Every node in the node&amp;#39;s right subtree has a value&amp;nbsp;strictly greater&amp;nbsp;than the node&amp;#39;s value. A leaf is a node that has no children. &amp;nbsp; Example 1: Input: trees = [[2,1],[3,2,5],[5,4]] Output: [3,2,5,1,null,4] Explanation: In the first operation, pick i=1 and j=0, and merge trees[0] into trees[1]. Delete trees[0], so trees = [[3,2,5,1],[5,4]]. In the second operation, pick i=0 and j=1, and merge trees[1] into trees[0]. Delete trees[1], so trees = [[3,2,5,1,null,4]]. The resulting tree, shown above, is a valid BST, so return its root. Example 2: Input: trees = [[5,3,8],[3,2,6]] Output: [] Explanation: Pick i=0 and j=1 and merge trees[1] into trees[0]. Delete trees[1], so trees = [[5,3,8,2,6]]. The resulting tree is shown above. This is the only valid operation that can be performed, but the resulting tree is not a valid BST, so return null. Example 3: Input: trees = [[5,4],[3]] Output: [] Explanation: It is impossible to perform any operations. &amp;nbsp; Constraints: n == trees.length 1 &amp;lt;= n &amp;lt;= 5 * 104 The number of nodes in each tree is in the range [1, 3]. Each node in the input may have children but no grandchildren. No two roots of trees have the same value. All the trees in the input are valid BSTs. 1 &amp;lt;= TreeNode.val &amp;lt;= 5 * 104. Solution Obviously, all leaf nodes except root nodes of all trees must have different values. Otherwise, there will be nodes with the same value in the merged tree, which is not a binary search tree. Therefore, loop over all trees and count the number of occurrences of all leaf nodesâ values. If there exists a value that occurs more than once, return null. Use a hash map to store each rootâs value and the corresponding root. Then for each leaf, if there exists a root with the same value as the leaf, replace the leaf with the root. Finally, there should be only one tree remaining. Otherwise, return null. For the remaining tree, check whether it is a binary search tree, and return the tree if it is a binary..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2021-03-15T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2021-03-15-1932-Merge-BSTs-to-Create-Single-BST/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-1932.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="1932 - Merge BSTs to Create Single BST" property="twitter:title"/>
   <meta content="Leetcode 1932. Merge BSTs to Create Single BST Description You are given n BST (binary search tree) root nodes for n separate BSTs stored in an array trees (0-indexed). Each BST in trees has at most 3 nodes, and no two roots have the same value. In one operation, you can: Select two distinct indices i and j such that the value stored at one of the leaves of trees[i] is equal to the root value of trees[j]. Replace the leaf node in trees[i] with trees[j]. Remove trees[j] from trees. Return the root of the resulting BST if it is possible to form a valid BST after performing n - 1 operations, or null if it is impossible to create a valid BST. A BST (binary search tree) is a binary tree where each node satisfies the following property: Every node in the node&amp;#39;s left subtree has a value&amp;nbsp;strictly less&amp;nbsp;than the node&amp;#39;s value. Every node in the node&amp;#39;s right subtree has a value&amp;nbsp;strictly greater&amp;nbsp;than the node&amp;#39;s value. A leaf is a node that has no children. &amp;nbsp; Example 1: Input: trees = [[2,1],[3,2,5],[5,4]] Output: [3,2,5,1,null,4] Explanation: In the first operation, pick i=1 and j=0, and merge trees[0] into trees[1]. Delete trees[0], so trees = [[3,2,5,1],[5,4]]. In the second operation, pick i=0 and j=1, and merge trees[1] into trees[0]. Delete trees[1], so trees = [[3,2,5,1,null,4]]. The resulting tree, shown above, is a valid BST, so return its root. Example 2: Input: trees = [[5,3,8],[3,2,6]] Output: [] Explanation: Pick i=0 and j=1 and merge trees[1] into trees[0]. Delete trees[1], so trees = [[5,3,8,2,6]]. The resulting tree is shown above. This is the only valid operation that can be performed, but the resulting tree is not a valid BST, so return null. Example 3: Input: trees = [[5,4],[3]] Output: [] Explanation: It is impossible to perform any operations. &amp;nbsp; Constraints: n == trees.length 1 &amp;lt;= n &amp;lt;= 5 * 104 The number of nodes in each tree is in the range [1, 3]. Each node in the input may have children but no grandchildren. No two roots of trees have the same value. All the trees in the input are valid BSTs. 1 &amp;lt;= TreeNode.val &amp;lt;= 5 * 104. Solution Obviously, all leaf nodes except root nodes of all trees must have different values. Otherwise, there will be nodes with the same value in the merged tree, which is not a binary search tree. Therefore, loop over all trees and count the number of occurrences of all leaf nodesâ values. If there exists a value that occurs more than once, return null. Use a hash map to store each rootâs value and the corresponding root. Then for each leaf, if there exists a root with the same value as the leaf, replace the leaf with the root. Finally, there should be only one tree remaining. Otherwise, return null. For the remaining tree, check whether it is a binary search tree, and return the tree if it is a binary..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    1932 - Merge BSTs to Create Single BST | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="1932 - Merge BSTs to Create Single BST" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-1932.html" rel="canonical">
          <meta content="https://leetcode.ca/2021-03-15-1932-Merge-BSTs-to-Create-Single-BST/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2021-03-15T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"1932 - Merge BSTs to Create Single BST","dateModified":"2021-03-15T00:00:00-07:00","datePublished":"2021-03-15T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2021-03-15-1932-Merge-BSTs-to-Create-Single-BST/"},"url":"https://leetcode.ca/2021-03-15-1932-Merge-BSTs-to-Create-Single-BST/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="1932-merge-bsts-to-create-single-bst">
       <a href="solution-1932.html">
        1932. Merge BSTs to Create Single BST
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       You are given
       <code>
        n
       </code>
       <strong>
        BST (binary search tree) root nodes
       </strong>
       for
       <code>
        n
       </code>
       separate BSTs stored in an array
       <code>
        trees
       </code>
       (
       <strong>
        0-indexed
       </strong>
       ). Each BST in
       <code>
        trees
       </code>
       has
       <strong>
        at most 3 nodes
       </strong>
       , and no two roots have the same value. In one operation, you can:
      </p>
      <ul>
       <li>
        Select two
        <strong>
         distinct
        </strong>
        indices
        <code>
         i
        </code>
        and
        <code>
         j
        </code>
        such that the value stored at one of the
        <strong>
         leaves
        </strong>
        of
        <code>
         trees[i]
        </code>
        is equal to the
        <strong>
         root value
        </strong>
        of
        <code>
         trees[j]
        </code>
        .
       </li>
       <li>
        Replace the leaf node in
        <code>
         trees[i]
        </code>
        with
        <code>
         trees[j]
        </code>
        .
       </li>
       <li>
        Remove
        <code>
         trees[j]
        </code>
        from
        <code>
         trees
        </code>
        .
       </li>
      </ul>
      <p>
       Return
       <em>
        the
        <strong>
         root
        </strong>
        of the resulting BST if it is possible to form a valid BST after performing
       </em>
       <code>
        n - 1
       </code>
       <em>
        operations, or
       </em>
       <em>
       </em>
       <code>
        null
       </code>
       <i>
        if it is impossible to create a valid BST
       </i>
       .
      </p>
      <p>
       A BST (binary search tree) is a binary tree where each node satisfies the following property:
      </p>
      <ul>
       <li>
        Every node in the node's left subtree has a value
        <strong>
         strictly less
        </strong>
        than the node's value.
       </li>
       <li>
        Every node in the node's right subtree has a value
        <strong>
         strictly greater
        </strong>
        than the node's value.
       </li>
      </ul>
      <p>
       A leaf is a node that has no children.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1900-1999/1932.Merge%20BSTs%20to%20Create%20Single%20BST/images/d1.png" style="width: 450px; height: 163px;"/>
      </p>
      <pre>
<strong>Input:</strong> trees = [[2,1],[3,2,5],[5,4]]
<strong>Output:</strong> [3,2,5,1,null,4]
<strong>Explanation:</strong>
In the first operation, pick i=1 and j=0, and merge trees[0] into trees[1].
Delete trees[0], so trees = [[3,2,5,1],[5,4]].
<img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1900-1999/1932.Merge%20BSTs%20to%20Create%20Single%20BST/images/diagram.png" style="width: 450px; height: 181px;"/>
In the second operation, pick i=0 and j=1, and merge trees[1] into trees[0].
Delete trees[1], so trees = [[3,2,5,1,null,4]].
<img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1900-1999/1932.Merge%20BSTs%20to%20Create%20Single%20BST/images/diagram-2.png" style="width: 220px; height: 165px;"/>
The resulting tree, shown above, is a valid BST, so return its root.</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1900-1999/1932.Merge%20BSTs%20to%20Create%20Single%20BST/images/d2.png" style="width: 450px; height: 171px;"/>
      </p>
      <pre>
<strong>Input:</strong> trees = [[5,3,8],[3,2,6]]
<strong>Output:</strong> []
<strong>Explanation:</strong>
Pick i=0 and j=1 and merge trees[1] into trees[0].
Delete trees[1], so trees = [[5,3,8,2,6]].
<img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1900-1999/1932.Merge%20BSTs%20to%20Create%20Single%20BST/images/diagram-3.png" style="width: 240px; height: 196px;"/>
The resulting tree is shown above. This is the only valid operation that can be performed, but the resulting tree is not a valid BST, so return null.
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1900-1999/1932.Merge%20BSTs%20to%20Create%20Single%20BST/images/d3.png" style="width: 430px; height: 168px;"/>
      </p>
      <pre>
<strong>Input:</strong> trees = [[5,4],[3]]
<strong>Output:</strong> []
<strong>Explanation:</strong> It is impossible to perform any operations.
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         n == trees.length
        </code>
       </li>
       <li>
        <code>
         1 &lt;= n &lt;= 5 * 10
         <sup>
          4
         </sup>
        </code>
       </li>
       <li>
        The number of nodes in each tree is in the range
        <code>
         [1, 3]
        </code>
        .
       </li>
       <li>
        Each node in the input may have children but no grandchildren.
       </li>
       <li>
        No two roots of
        <code>
         trees
        </code>
        have the same value.
       </li>
       <li>
        All the trees in the input are
        <strong>
         valid BSTs
        </strong>
        .
       </li>
       <li>
        <code>
         1 &lt;= TreeNode.val &lt;= 5 * 10
         <sup>
          4
         </sup>
        </code>
        .
       </li>
      </ul>
      <h2 id="solution">
       Solution
      </h2>
      <p>
       Obviously, all leaf nodes except root nodes of all trees must have different values. Otherwise, there will be nodes with the same value in the merged tree, which is not a binary search tree. Therefore, loop over all trees and count the number of occurrences of all leaf nodesâ values. If there exists a value that occurs more than once, return
       <code class="language-plaintext highlighter-rouge">
        null
       </code>
       .
      </p>
      <p>
       Use a hash map to store each rootâs value and the corresponding root. Then for each leaf, if there exists a root with the same value as the leaf, replace the leaf with the root.
      </p>
      <p>
       Finally, there should be only one tree remaining. Otherwise, return
       <code class="language-plaintext highlighter-rouge">
        null
       </code>
       . For the remaining tree, check whether it is a binary search tree, and return the tree if it is a binary search tree or
       <code class="language-plaintext highlighter-rouge">
        null
       </code>
       otherwise.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#2ff5f43d-e3e2-4172-a834-5a95a3a0908a'}">
       <li class="uk-active">
        <a href="solution-1932.html">
         Java
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="2ff5f43d-e3e2-4172-a834-5a95a3a0908a">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">canMerge</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">trees</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">valRootMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">TreeNode</span><span class="o">&gt;();</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">minMaxMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]&gt;();</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">legalRangeMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span> <span class="o">:</span> <span class="n">trees</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">valRootMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
            <span class="n">getMinMax</span><span class="o">(</span><span class="n">minMaxMap</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
            <span class="n">getLegalRange</span><span class="o">(</span><span class="n">legalRangeMap</span><span class="o">,</span> <span class="n">root</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">leavesCountMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span> <span class="n">tree</span> <span class="o">:</span> <span class="n">trees</span><span class="o">)</span>
            <span class="n">visitLeaves</span><span class="o">(</span><span class="n">leavesCountMap</span><span class="o">,</span> <span class="n">tree</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">leavesCountMap</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;(</span><span class="n">trees</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span> <span class="o">:</span> <span class="n">trees</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isLeaf</span><span class="o">(</span><span class="n">root</span><span class="o">))</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="nc">TreeNode</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">getLeafParent</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
            <span class="nc">TreeNode</span> <span class="n">left</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">valRootMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">left</span><span class="o">.</span><span class="na">val</span><span class="o">))</span> <span class="o">{</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">legalRange</span> <span class="o">=</span> <span class="n">legalRangeMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">left</span><span class="o">);</span>
                <span class="nc">TreeNode</span> <span class="n">prevRoot</span> <span class="o">=</span> <span class="n">valRootMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">left</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">minMax</span> <span class="o">=</span> <span class="n">minMaxMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">prevRoot</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">minMax</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">legalRange</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">||</span> <span class="n">minMax</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">legalRange</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span>
                    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">parent</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">prevRoot</span><span class="o">;</span>
                <span class="n">legalRangeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">prevRoot</span><span class="o">,</span> <span class="n">legalRange</span><span class="o">);</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">parentMinMax</span> <span class="o">=</span> <span class="n">minMaxMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">newMinMax</span> <span class="o">=</span> <span class="o">{</span><span class="n">minMax</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">parentMinMax</span><span class="o">[</span><span class="mi">1</span><span class="o">]};</span>
                <span class="n">minMaxMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">prevRoot</span><span class="o">,</span> <span class="n">newMinMax</span><span class="o">);</span>
                <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">prevRoot</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">valRootMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">right</span><span class="o">.</span><span class="na">val</span><span class="o">))</span> <span class="o">{</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">legalRange</span> <span class="o">=</span> <span class="n">legalRangeMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
                <span class="nc">TreeNode</span> <span class="n">prevRoot</span> <span class="o">=</span> <span class="n">valRootMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">right</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">minMax</span> <span class="o">=</span> <span class="n">minMaxMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">prevRoot</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">minMax</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">legalRange</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">||</span> <span class="n">minMax</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">legalRange</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span>
                    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">parent</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">prevRoot</span><span class="o">;</span>
                <span class="n">legalRangeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">prevRoot</span><span class="o">,</span> <span class="n">legalRange</span><span class="o">);</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">parentMinMax</span> <span class="o">=</span> <span class="n">minMaxMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">newMinMax</span> <span class="o">=</span> <span class="o">{</span><span class="n">parentMinMax</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">minMax</span><span class="o">[</span><span class="mi">1</span><span class="o">]};</span>
                <span class="n">minMaxMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">prevRoot</span><span class="o">,</span> <span class="n">newMinMax</span><span class="o">);</span>
                <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">prevRoot</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">remain</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;(</span><span class="n">set</span><span class="o">);</span>
        <span class="nc">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="n">remain</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isValidBST</span><span class="o">(</span><span class="n">root</span><span class="o">))</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">getMinMax</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">minMaxMap</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">TreeNode</span> <span class="n">minNode</span> <span class="o">=</span> <span class="n">root</span><span class="o">,</span> <span class="n">maxNode</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">minNode</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">minNode</span> <span class="o">=</span> <span class="n">minNode</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">maxNode</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">maxNode</span> <span class="o">=</span> <span class="n">maxNode</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="n">minMaxMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">minNode</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="n">maxNode</span><span class="o">.</span><span class="na">val</span><span class="o">});</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">getLegalRange</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">legalRangeMap</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">min</span><span class="o">,</span> <span class="kt">int</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="n">legalRangeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">min</span><span class="o">,</span> <span class="n">max</span><span class="o">});</span>
        <span class="n">getLegalRange</span><span class="o">(</span><span class="n">legalRangeMap</span><span class="o">,</span> <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">min</span><span class="o">,</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">getLegalRange</span><span class="o">(</span><span class="n">legalRangeMap</span><span class="o">,</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visitLeaves</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">leavesCountMap</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">node</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isRoot</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isLeaf</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">isRoot</span><span class="o">)</span>
                <span class="n">leavesCountMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="n">leavesCountMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">visitLeaves</span><span class="o">(</span><span class="n">leavesCountMap</span><span class="o">,</span> <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">visitLeaves</span><span class="o">(</span><span class="n">leavesCountMap</span><span class="o">,</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isLeaf</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">getLeafParent</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isLeaf</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">))</span>
                <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isLeaf</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">))</span>
                <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValidBST</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="nc">TreeNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;();</span>
        <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="nc">TreeNode</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">prev</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;=</span> <span class="n">curr</span><span class="o">.</span><span class="na">val</span><span class="o">)</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-1932.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
