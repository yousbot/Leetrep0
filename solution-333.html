<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-333.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-333.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>333 - Largest BST Subtree</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 333. Largest BST Subtree Description Given the root of a binary tree, find the largest subtree, which is also a Binary Search Tree (BST), where the largest means subtree has the largest number of nodes. A Binary Search Tree (BST) is a tree in which...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-333.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-333.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-333.html" rel="stylesheet"/>
   <link href="solution-333.html" rel="stylesheet"/>
   <link href="solution-333.html" rel="stylesheet"/>
   <link href="solution-333.html" rel="stylesheet"/>
   <link href="solution-333.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="333 - Largest BST Subtree" property="og:title"/>
   <meta content="Leetcode 333. Largest BST Subtree Description Given the root of a binary tree, find the largest subtree, which is also a Binary Search Tree (BST), where the largest means subtree has the largest number of nodes. A Binary Search Tree (BST) is a tree in which all the nodes follow the below-mentioned properties: The left subtree values are less than the value of their parent (root) node&amp;#39;s value. The right subtree values are greater than the value of their parent (root) node&amp;#39;s value. Note: A subtree must include all of its descendants. &amp;nbsp; Example 1: Input: root = [10,5,15,1,8,null,7] Output: 3 Explanation: The Largest BST Subtree in this case is the highlighted one. The return value is the subtree&amp;#39;s size, which is 3. Example 2: Input: root = [4,2,7,2,3,5,null,2,null,null,null,null,null,1] Output: 2 &amp;nbsp; Constraints: The number of nodes in the tree is in the range [0, 104]. -104 &amp;lt;= Node.val &amp;lt;= 104 &amp;nbsp; Follow up: Can you figure out ways to solve it with O(n) time complexity? Solutions The solution uses a depth-first search (DFS) strategy to explore the tree, with a use of recursion that evaluates whether each subtree meets BST criteria and calculates its size. Core Concept For a subtree to be considered a BST, all nodes in the left subtree must be less than the rootâs value, and all nodes in the right subtree must be greater than the rootâs value. Additionally, both the left and right subtrees must themselves be BSTs. DFS Function The dfs function is designed to return three values for each subtree it explores: Minimum Value (lmi, rmi): The smallest value in the subtree. Maximum Value (lmx, rmx): The largest value in the subtree. Number of Nodes (ln, rn): The size of the largest BST within the subtree. For a node with value None (i.e., an empty subtree), the function returns inf, -inf, and 0 to indicate that there are no values in the subtree and its size is 0. Checking Subtree Validity The core logic checks if the current nodeâs value is greater than the maximum value in the left subtree (lmx) and less than the minimum value in the right subtree (rmi). This condition ensures that the current node and its subtrees satisfy the BST property: If the condition holds, the current subtree rooted at root is a BST. The size of this subtree (ln + rn + 1) is considered for the answer (ans), which tracks the size of the largest BST found so far. The function then returns the minimum value found in the subtree (which will be the minimum of the left subtree or the current nodeâs value if the left subtree is empty), the maximum value found in the subtree (which will be the maximum of the right subtree or the current nodeâs value), and the size of the subtree. Handling Non-BST Subtrees If the BST property is violated (i.e., lmx &amp;gt;= root.val or root.val &amp;gt;= rmi), the current subtree cannot be a BST...." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-10-28T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-10-28-333-Largest-BST-Subtree/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-333.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="333 - Largest BST Subtree" property="twitter:title"/>
   <meta content="Leetcode 333. Largest BST Subtree Description Given the root of a binary tree, find the largest subtree, which is also a Binary Search Tree (BST), where the largest means subtree has the largest number of nodes. A Binary Search Tree (BST) is a tree in which all the nodes follow the below-mentioned properties: The left subtree values are less than the value of their parent (root) node&amp;#39;s value. The right subtree values are greater than the value of their parent (root) node&amp;#39;s value. Note: A subtree must include all of its descendants. &amp;nbsp; Example 1: Input: root = [10,5,15,1,8,null,7] Output: 3 Explanation: The Largest BST Subtree in this case is the highlighted one. The return value is the subtree&amp;#39;s size, which is 3. Example 2: Input: root = [4,2,7,2,3,5,null,2,null,null,null,null,null,1] Output: 2 &amp;nbsp; Constraints: The number of nodes in the tree is in the range [0, 104]. -104 &amp;lt;= Node.val &amp;lt;= 104 &amp;nbsp; Follow up: Can you figure out ways to solve it with O(n) time complexity? Solutions The solution uses a depth-first search (DFS) strategy to explore the tree, with a use of recursion that evaluates whether each subtree meets BST criteria and calculates its size. Core Concept For a subtree to be considered a BST, all nodes in the left subtree must be less than the rootâs value, and all nodes in the right subtree must be greater than the rootâs value. Additionally, both the left and right subtrees must themselves be BSTs. DFS Function The dfs function is designed to return three values for each subtree it explores: Minimum Value (lmi, rmi): The smallest value in the subtree. Maximum Value (lmx, rmx): The largest value in the subtree. Number of Nodes (ln, rn): The size of the largest BST within the subtree. For a node with value None (i.e., an empty subtree), the function returns inf, -inf, and 0 to indicate that there are no values in the subtree and its size is 0. Checking Subtree Validity The core logic checks if the current nodeâs value is greater than the maximum value in the left subtree (lmx) and less than the minimum value in the right subtree (rmi). This condition ensures that the current node and its subtrees satisfy the BST property: If the condition holds, the current subtree rooted at root is a BST. The size of this subtree (ln + rn + 1) is considered for the answer (ans), which tracks the size of the largest BST found so far. The function then returns the minimum value found in the subtree (which will be the minimum of the left subtree or the current nodeâs value if the left subtree is empty), the maximum value found in the subtree (which will be the maximum of the right subtree or the current nodeâs value), and the size of the subtree. Handling Non-BST Subtrees If the BST property is violated (i.e., lmx &amp;gt;= root.val or root.val &amp;gt;= rmi), the current subtree cannot be a BST...." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    333 - Largest BST Subtree | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="333 - Largest BST Subtree" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-333.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-10-28-333-Largest-BST-Subtree/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-10-28T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"333 - Largest BST Subtree","dateModified":"2016-10-28T00:00:00-07:00","datePublished":"2016-10-28T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-10-28-333-Largest-BST-Subtree/"},"url":"https://leetcode.ca/2016-10-28-333-Largest-BST-Subtree/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="333-largest-bst-subtree">
       <a href="solution-333.html">
        333. Largest BST Subtree
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given the root of a binary tree, find the largest
       <span data-keyword="subtree">
        subtree
       </span>
       , which is also a Binary Search Tree (BST), where the largest means subtree has the largest number of nodes.
      </p>
      <p>
       A
       <strong>
        Binary Search Tree (BST)
       </strong>
       is a tree in which all the nodes follow the below-mentioned properties:
      </p>
      <ul>
       <li>
        The left subtree values are less than the value of their parent (root) node's value.
       </li>
       <li>
        The right subtree values are greater than the value of their parent (root) node's value.
       </li>
      </ul>
      <p>
       <strong>
        Note:
       </strong>
       A subtree must include all of its descendants.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <strong>
        <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0300-0399/0333.Largest%20BST%20Subtree/images/tmp.jpg" style="width: 571px; height: 302px;"/>
       </strong>
      </p>
      <pre>
<strong>Input:</strong> root = [10,5,15,1,8,null,7]
<strong>Output:</strong> 3
<strong>Explanation: </strong>The Largest BST Subtree in this case is the highlighted one. The return value is the subtree's size, which is 3.</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> root = [4,2,7,2,3,5,null,2,null,null,null,null,null,1]
<strong>Output:</strong> 2
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the tree is in the range
        <code>
         [0, 10
         <sup>
          4
         </sup>
         ]
        </code>
        .
       </li>
       <li>
        <code>
         -10
         <sup>
          4
         </sup>
         &lt;= Node.val &lt;= 10
         <sup>
          4
         </sup>
        </code>
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong>
        Follow up:
       </strong>
       Can you figure out ways to solve it with
       <code>
        O(n)
       </code>
       time complexity?
      </p>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       The solution uses a depth-first search (DFS) strategy to explore the tree, with a use of recursion that evaluates whether each subtree meets BST criteria and calculates its size.
      </p>
      <h3 id="core-concept">
       Core Concept
      </h3>
      <p>
       For a subtree to be considered a BST, all nodes in the left subtree must be less than the rootâs value, and all nodes in the right subtree must be greater than the rootâs value. Additionally, both the left and right subtrees must themselves be BSTs.
      </p>
      <h3 id="dfs-function">
       DFS Function
      </h3>
      <p>
       The
       <code class="language-plaintext highlighter-rouge">
        dfs
       </code>
       function is designed to return three values for each subtree it explores:
      </p>
      <ol>
       <li>
        <strong>
         Minimum Value (
         <code class="language-plaintext highlighter-rouge">
          lmi
         </code>
         ,
         <code class="language-plaintext highlighter-rouge">
          rmi
         </code>
         )
        </strong>
        : The smallest value in the subtree.
       </li>
       <li>
        <strong>
         Maximum Value (
         <code class="language-plaintext highlighter-rouge">
          lmx
         </code>
         ,
         <code class="language-plaintext highlighter-rouge">
          rmx
         </code>
         )
        </strong>
        : The largest value in the subtree.
       </li>
       <li>
        <strong>
         Number of Nodes (
         <code class="language-plaintext highlighter-rouge">
          ln
         </code>
         ,
         <code class="language-plaintext highlighter-rouge">
          rn
         </code>
         )
        </strong>
        : The size of the largest BST within the subtree.
       </li>
      </ol>
      <p>
       For a node with value
       <code class="language-plaintext highlighter-rouge">
        None
       </code>
       (i.e., an empty subtree), the function returns
       <code class="language-plaintext highlighter-rouge">
        inf
       </code>
       ,
       <code class="language-plaintext highlighter-rouge">
        -inf
       </code>
       , and
       <code class="language-plaintext highlighter-rouge">
        0
       </code>
       to indicate that there are no values in the subtree and its size is 0.
      </p>
      <h3 id="checking-subtree-validity">
       Checking Subtree Validity
      </h3>
      <p>
       The core logic checks if the current nodeâs value is greater than the maximum value in the left subtree (
       <code class="language-plaintext highlighter-rouge">
        lmx
       </code>
       ) and less than the minimum value in the right subtree (
       <code class="language-plaintext highlighter-rouge">
        rmi
       </code>
       ). This condition ensures that the current node and its subtrees satisfy the BST property:
      </p>
      <ul>
       <li>
        If the condition holds, the current subtree rooted at
        <code class="language-plaintext highlighter-rouge">
         root
        </code>
        is a BST. The size of this subtree (
        <code class="language-plaintext highlighter-rouge">
         ln + rn + 1
        </code>
        ) is considered for the answer (
        <code class="language-plaintext highlighter-rouge">
         ans
        </code>
        ), which tracks the size of the largest BST found so far.
       </li>
       <li>
        The function then returns the minimum value found in the subtree (which will be the minimum of the left subtree or the current nodeâs value if the left subtree is empty), the maximum value found in the subtree (which will be the maximum of the right subtree or the current nodeâs value), and the size of the subtree.
       </li>
      </ul>
      <h3 id="handling-non-bst-subtrees">
       Handling Non-BST Subtrees
      </h3>
      <p>
       If the BST property is violated (i.e.,
       <code class="language-plaintext highlighter-rouge">
        lmx &gt;= root.val
       </code>
       or
       <code class="language-plaintext highlighter-rouge">
        root.val &gt;= rmi
       </code>
       ), the current subtree cannot be a BST. In such cases, the function returns
       <code class="language-plaintext highlighter-rouge">
        -inf
       </code>
       ,
       <code class="language-plaintext highlighter-rouge">
        inf
       </code>
       , and
       <code class="language-plaintext highlighter-rouge">
        0
       </code>
       to ensure that any parent nodes will recognize this subtree as invalid for forming a BST.
      </p>
      <h3 id="global-variable-ans">
       Global Variable
       <code class="language-plaintext highlighter-rouge">
        ans
       </code>
      </h3>
      <p>
       The variable
       <code class="language-plaintext highlighter-rouge">
        ans
       </code>
       is declared as
       <code class="language-plaintext highlighter-rouge">
        nonlocal
       </code>
       within the
       <code class="language-plaintext highlighter-rouge">
        dfs
       </code>
       function, allowing it to keep track of the largest BST size found during the traversal. After exploring the entire tree,
       <code class="language-plaintext highlighter-rouge">
        ans
       </code>
       holds the size of the largest BST subtree.
      </p>
      <h3 id="return-value">
       Return Value
      </h3>
      <p>
       After calling
       <code class="language-plaintext highlighter-rouge">
        dfs(root)
       </code>
       , the solution returns the value of
       <code class="language-plaintext highlighter-rouge">
        ans
       </code>
       , which by then represents the size of the largest BST contained within the original binary tree.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#3b5e3243-f9e1-4037-8090-72d3ff510fa8'}">
       <li class="uk-active">
        <a href="solution-333.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-333.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-333.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-333.html">
         Go
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="3b5e3243-f9e1-4037-8090-72d3ff510fa8">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">ans</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">largestBSTSubtree</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">left</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">left</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="n">right</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span>
                <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="n">left</span><span class="o">[</span><span class="mi">0</span><span class="o">]),</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="n">right</span><span class="o">[</span><span class="mi">1</span><span class="o">]),</span> <span class="n">left</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="n">right</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">};</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">ans</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">largestBSTSubtree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span><span class="n">INT_MAX</span><span class="p">,</span> <span class="n">INT_MIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
        <span class="k">auto</span> <span class="n">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">left</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">right</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">min</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">left</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">max</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">right</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">left</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">right</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">};</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="s">'''
&gt;&gt;&gt; float("inf")
inf
&gt;&gt;&gt; float("inf") + 1
inf
&gt;&gt;&gt; import math
&gt;&gt;&gt; float("inf") == math.inf
True
'''</span>
<span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">largestBSTSubtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="mi">0</span>
            <span class="n">lmi</span><span class="p">,</span> <span class="n">lmx</span><span class="p">,</span> <span class="n">ln</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">rmi</span><span class="p">,</span> <span class="n">rmx</span><span class="p">,</span> <span class="n">rn</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">nonlocal</span> <span class="n">ans</span>
            <span class="c1"># this if can check if left/right is a bst
</span>            <span class="c1"># eg. if left is not bst, the returned lmi=-inf and lmx=inf, so 'lmx &lt; root.val &lt; rmi' is false
</span>            <span class="k">if</span> <span class="n">lmx</span> <span class="o">&lt;</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">rmi</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">ln</span> <span class="o">+</span> <span class="n">rn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="c1"># lmi is guranteed &lt; root.val, except when left(right) is None
</span>                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">lmi</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">rmx</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">),</span> <span class="n">ln</span> <span class="o">+</span> <span class="n">rn</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="mi">0</span> <span class="c1"># if this one not bst, then all parents will not be bst
</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span>

<span class="c1">############
</span>
<span class="c1"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">largestBSTSubtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="s">"""
    :type root: TreeNode
    :rtype: int
    """</span>

    <span class="k">def</span> <span class="nf">helper</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s">"inf"</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s">"-inf"</span><span class="p">))</span>  <span class="c1"># numBST, maxNumBST, min, max
</span>      <span class="n">lnumBST</span><span class="p">,</span> <span class="n">lmaxNumBST</span><span class="p">,</span> <span class="n">lmin</span><span class="p">,</span> <span class="n">lmax</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
      <span class="n">rnumBST</span><span class="p">,</span> <span class="n">rmaxNumBST</span><span class="p">,</span> <span class="n">rmin</span><span class="p">,</span> <span class="n">rmax</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
      <span class="n">numBST</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
      <span class="k">if</span> <span class="n">lmax</span> <span class="o">&lt;</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">rmin</span> <span class="ow">and</span> <span class="n">lnumBST</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">rnumBST</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">numBST</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">lnumBST</span> <span class="o">+</span> <span class="n">rnumBST</span>
      <span class="n">maxNumBST</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">lmaxNumBST</span><span class="p">,</span> <span class="n">rmaxNumBST</span><span class="p">,</span> <span class="n">numBST</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">numBST</span><span class="p">,</span> <span class="n">maxNumBST</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">lmin</span><span class="p">,</span> <span class="n">rmin</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lmax</span><span class="p">,</span> <span class="n">rmax</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">helper</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */</span>
<span class="k">func</span> <span class="n">largestBSTSubtree</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">ans</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="n">math</span><span class="o">.</span><span class="n">MaxInt32</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">MinInt32</span><span class="p">,</span> <span class="m">0</span><span class="p">}</span>
		<span class="p">}</span>
		<span class="n">left</span> <span class="o">:=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span>
		<span class="n">right</span> <span class="o">:=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">left</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">{</span>
			<span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">left</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="o">+</span><span class="n">right</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="o">+</span><span class="m">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="n">min</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="p">,</span> <span class="n">left</span><span class="p">[</span><span class="m">0</span><span class="p">]),</span> <span class="n">max</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="p">,</span> <span class="n">right</span><span class="p">[</span><span class="m">1</span><span class="p">]),</span> <span class="n">left</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">right</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="o">+</span> <span class="m">1</span><span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="n">math</span><span class="o">.</span><span class="n">MinInt32</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">MaxInt32</span><span class="p">,</span> <span class="m">0</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">ans</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-333.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
