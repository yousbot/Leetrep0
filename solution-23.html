<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-23.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-23.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>23 - Merge k Sorted Lists</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode Formatted question description: https://leetcode.ca/all/23.html 23 - Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: Input: [ 1-&amp;gt;4-&amp;gt;5, 1-&amp;gt;3-&amp;gt;4, 2-&amp;gt;6 ] Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6 MergeSort solution The initial approach one might consider is...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-23.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-23.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-23.html" rel="stylesheet"/>
   <link href="solution-23.html" rel="stylesheet"/>
   <link href="solution-23.html" rel="stylesheet"/>
   <link href="solution-23.html" rel="stylesheet"/>
   <link href="solution-23.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="23 - Merge k Sorted Lists" property="og:title"/>
   <meta content="Leetcode Formatted question description: https://leetcode.ca/all/23.html 23 - Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: Input: [ 1-&amp;gt;4-&amp;gt;5, 1-&amp;gt;3-&amp;gt;4, 2-&amp;gt;6 ] Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6 MergeSort solution The initial approach one might consider is to merge the linked lists two at a time. That is, first merge the first two lists, then merge the result with the third list, and continue this process until the kth list. While this approach is theoretically sound, it proves to be inefficient for passing online judgment (OJ) systems due to its higher time complexity. Therefore, a shift in strategy is essential, leading us to adopt the Divide and Conquer method. In essence, this method involves repeatedly dividing the task into smaller, more manageable chunks. Specifically, the k linked lists are initially divided into tasks of merging k/2 pairs of linked lists. This process continues recursively, dividing the lists until we are left with tasks that involve merging only one or two linked lists, at which point the actual merging begins. Consider the task of merging 6 linked lists. Using the divide and conquer strategy, the first step would be to merge lists 0 and 3, 1 and 4, and 2 and 5, respectively. In the next iteration, you would only need to merge 3 linked lists, further merging lists 1 and 3, and finally merging this result with list 2. The variable k in the code is determined using the formula (n+1)/2. The addition of 1 serves a specific purpose: It ensures that when n is odd, k starts from the latter half of the list array. For instance, if n=5, then k=3. This setup leads to the merging of lists 0 and 3, and 1 and 4, leaving list 2 untouched initially. When n is even, adding 1 has no effect. For example, with n=4, k=2 aligns perfectly for the merging process: lists 0 and 2 are merged, as are lists 1 and 3. This adjustment elegantly addresses the challenge of merging an odd number of lists and demonstrates the efficiency of the Divide and Conquer approach in solving the problem of merging k linked lists. big-o analysis time-complex O(N*logK) N is the total number of nodes k is the number of linked lists. public ListNode merge(ListNode[] lists, int start, int end) { int mid = (end - start) / 2 + start; ListNode leftHalf = merge(lists, start, mid); ListNode rightHalf = merge(lists, mid + 1, end); } Reference: https://leetcode.com/problems/merge-k-sorted-lists/solution/ We can merge two sorted linked list in O(n) time where n is the total number of nodes in two lists. Sum up the merge process and we can get: sum all nodes logk times (height of tree) =&amp;gt; O(Nlogk) Heap-Based Solution To efficiently merge k sorted linked lists, a heap-based solution leverages the properties of a priority queue, specifically a min heap. This approach involves the following steps: Initialization: Place the smallest node (head node) from..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2015-12-23T21:21:01-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2015-12-23-23-Merge-k-Sorted-Lists/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-23.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="23 - Merge k Sorted Lists" property="twitter:title"/>
   <meta content="Leetcode Formatted question description: https://leetcode.ca/all/23.html 23 - Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: Input: [ 1-&amp;gt;4-&amp;gt;5, 1-&amp;gt;3-&amp;gt;4, 2-&amp;gt;6 ] Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6 MergeSort solution The initial approach one might consider is to merge the linked lists two at a time. That is, first merge the first two lists, then merge the result with the third list, and continue this process until the kth list. While this approach is theoretically sound, it proves to be inefficient for passing online judgment (OJ) systems due to its higher time complexity. Therefore, a shift in strategy is essential, leading us to adopt the Divide and Conquer method. In essence, this method involves repeatedly dividing the task into smaller, more manageable chunks. Specifically, the k linked lists are initially divided into tasks of merging k/2 pairs of linked lists. This process continues recursively, dividing the lists until we are left with tasks that involve merging only one or two linked lists, at which point the actual merging begins. Consider the task of merging 6 linked lists. Using the divide and conquer strategy, the first step would be to merge lists 0 and 3, 1 and 4, and 2 and 5, respectively. In the next iteration, you would only need to merge 3 linked lists, further merging lists 1 and 3, and finally merging this result with list 2. The variable k in the code is determined using the formula (n+1)/2. The addition of 1 serves a specific purpose: It ensures that when n is odd, k starts from the latter half of the list array. For instance, if n=5, then k=3. This setup leads to the merging of lists 0 and 3, and 1 and 4, leaving list 2 untouched initially. When n is even, adding 1 has no effect. For example, with n=4, k=2 aligns perfectly for the merging process: lists 0 and 2 are merged, as are lists 1 and 3. This adjustment elegantly addresses the challenge of merging an odd number of lists and demonstrates the efficiency of the Divide and Conquer approach in solving the problem of merging k linked lists. big-o analysis time-complex O(N*logK) N is the total number of nodes k is the number of linked lists. public ListNode merge(ListNode[] lists, int start, int end) { int mid = (end - start) / 2 + start; ListNode leftHalf = merge(lists, start, mid); ListNode rightHalf = merge(lists, mid + 1, end); } Reference: https://leetcode.com/problems/merge-k-sorted-lists/solution/ We can merge two sorted linked list in O(n) time where n is the total number of nodes in two lists. Sum up the merge process and we can get: sum all nodes logk times (height of tree) =&amp;gt; O(Nlogk) Heap-Based Solution To efficiently merge k sorted linked lists, a heap-based solution leverages the properties of a priority queue, specifically a min heap. This approach involves the following steps: Initialization: Place the smallest node (head node) from..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    23 - Merge k Sorted Lists | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="23 - Merge k Sorted Lists" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-23.html" rel="canonical">
          <meta content="https://leetcode.ca/2015-12-23-23-Merge-k-Sorted-Lists/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2015-12-23T21:21:01-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"23 - Merge k Sorted Lists","dateModified":"2015-12-23T21:21:01-08:00","datePublished":"2015-12-23T21:21:01-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2015-12-23-23-Merge-k-Sorted-Lists/"},"url":"https://leetcode.ca/2015-12-23-23-Merge-k-Sorted-Lists/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <p>
       Formatted question description:
       <a href="solution-23.html">
        https://leetcode.ca/all/23.html
       </a>
      </p>
      <h1 id="23---merge-k-sorted-lists">
       <a href="solution-23.html">
        23 - Merge k Sorted Lists
       </a>
      </h1>
      <p>
       Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
      </p>
      <p>
       Example:
      </p>
      <p>
       Input:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
      </p>
      <p>
       Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
      </p>
      <h3 id="mergesort-solution">
       MergeSort solution
      </h3>
      <p>
       The initial approach one might consider is to merge the linked lists two at a time. That is, first merge the first two lists, then merge the result with the third list, and continue this process until the kth list. While this approach is theoretically sound, it proves to be inefficient for passing online judgment (OJ) systems due to its higher time complexity. Therefore, a shift in strategy is essential, leading us to adopt the Divide and Conquer method.
      </p>
      <p>
       In essence, this method involves repeatedly dividing the task into smaller, more manageable chunks. Specifically, the k linked lists are initially divided into tasks of merging
       <code class="language-plaintext highlighter-rouge">
        k/2
       </code>
       pairs of linked lists. This process continues recursively, dividing the lists until we are left with tasks that involve merging only one or two linked lists, at which point the actual merging begins.
      </p>
      <p>
       Consider the task of merging 6 linked lists. Using the divide and conquer strategy, the first step would be to merge lists 0 and 3, 1 and 4, and 2 and 5, respectively. In the next iteration, you would only need to merge 3 linked lists, further merging lists 1 and 3, and finally merging this result with list 2.
      </p>
      <p>
       The variable k in the code is determined using the formula
       <code class="language-plaintext highlighter-rouge">
        (n+1)/2
       </code>
       . The addition of 1 serves a specific purpose:
      </p>
      <ul>
       <li>
        It ensures that when n is odd, k starts from the latter half of the list array. For instance, if n=5, then k=3. This setup leads to the merging of lists 0 and 3, and 1 and 4, leaving list 2 untouched initially.
       </li>
       <li>
        When n is even, adding 1 has no effect. For example, with n=4, k=2 aligns perfectly for the merging process: lists 0 and 2 are merged, as are lists 1 and 3.
       </li>
      </ul>
      <p>
       This adjustment elegantly addresses the challenge of merging an odd number of lists and demonstrates the efficiency of the Divide and Conquer approach in solving the problem of merging k linked lists.
      </p>
      <h5 id="big-o-analysis">
       big-o analysis
      </h5>
      <p>
       time-complex
       <code class="language-plaintext highlighter-rouge">
        O(N*logK)
       </code>
      </p>
      <ul>
       <li>
        <code class="language-plaintext highlighter-rouge">
         N
        </code>
        is the total number of nodes
       </li>
       <li>
        <p>
         <code class="language-plaintext highlighter-rouge">
          k
         </code>
         is the number of linked lists.
        </p>
        <div class="language-plaintext highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code>      public ListNode merge(ListNode[] lists, int start, int end) {

          int mid = (end - start) / 2 + start;
          ListNode leftHalf = merge(lists, start, mid);
          ListNode rightHalf = merge(lists, mid + 1, end);

      }
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      <p>
       Reference:
       <a href="solution-23.html">
        https://leetcode.com/problems/merge-k-sorted-lists/solution/
       </a>
      </p>
      <p>
       <img alt="i" src="https://leetcode.com/problems/merge-k-sorted-lists/Figures/23/23_divide_and_conquer_new.png"/>
      </p>
      <ul>
       <li>
        We can merge two sorted linked list in
        <code class="language-plaintext highlighter-rouge">
         O(n)
        </code>
        time where n is the total number of nodes in two lists.
       </li>
       <li>
        Sum up the merge process and we can get: sum all nodes
        <code class="language-plaintext highlighter-rouge">
         logk
        </code>
        times (height of tree) =&gt;
        <code class="language-plaintext highlighter-rouge">
         O(Nlogk)
        </code>
       </li>
      </ul>
      <h3 id="heap-based-solution">
       Heap-Based Solution
      </h3>
      <p>
       To efficiently merge k sorted linked lists, a heap-based solution leverages the properties of a priority queue, specifically a min heap. This approach involves the following steps:
      </p>
      <ol>
       <li>
        <p>
         <strong>
          Initialization:
         </strong>
         Place the smallest node (head node) from each of the k lists into a min heap. This ensures that the heap always contains the smallest available nodes from each list at any given time.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Process Nodes:
         </strong>
        </p>
        <ul>
         <li>
          Extract (poll) the smallest node from the heap.
         </li>
         <li>
          If the polled node has a successor (i.e.,
          <code class="language-plaintext highlighter-rouge">
           polled.next
          </code>
          is not null) in its corresponding list, insert that successor node into the heap.
         </li>
         <li>
          Continue this process until the heap is empty, indicating that all nodes have been processed and merged into a single sorted list.
         </li>
        </ul>
       </li>
      </ol>
      <p>
       Itâs important to note that the heapâs size is maintained at k, the number of lists, since we only insert the smallest node of each list into the heap initially and replace it with the next node from the same list as we poll nodes from the heap. The insertion operation has a complexity of O(log k), and since we insert a total of nk nodes (n being the average number of nodes in each list), the overall time complexity of this solution is
       <code class="language-plaintext highlighter-rouge">
        O(n * k * log k)
       </code>
       .
      </p>
      <h5 id="key-implementation-details">
       Key Implementation Details
      </h5>
      <ul>
       <li>
        <p>
         <strong>
          Heap Operations:
         </strong>
         We use
         <code class="language-plaintext highlighter-rouge">
          heap.offer()
         </code>
         to add new nodes to the heap. Itâs crucial to check that the node to be offered is not null since the
         <code class="language-plaintext highlighter-rouge">
          offer()
         </code>
         method does not accept null values. This check is performed with
         <code class="language-plaintext highlighter-rouge">
          if (polled.next != null)
         </code>
         before calling
         <code class="language-plaintext highlighter-rouge">
          heap.offer(polled.next)
         </code>
         .
        </p>
       </li>
       <li>
        <p>
         <strong>
          Complexity Analysis:
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           Time Complexity:
          </strong>
          The solution has a time complexity of
          <code class="language-plaintext highlighter-rouge">
           O(n * k * log k)
          </code>
          due to the log k complexity of heap insertions (offer) and nk total insertions.
         </li>
         <li>
          <strong>
           Space Complexity:
          </strong>
          The space complexity is
          <code class="language-plaintext highlighter-rouge">
           O(k)
          </code>
          because the heap size does not exceed k, the number of linked lists.
         </li>
        </ul>
       </li>
      </ul>
      <h5 id="example">
       Example
      </h5>
      <p>
       Consider merging three linked lists with a total of n nodes. The smallest node from each list is initially added to the heap. When a node is polled from the heap, its successor (if any) is added to the heap. This process ensures that at every step, the heap helps us find the next smallest node to be added to the merged list.
      </p>
      <h5 id="conclusion">
       Conclusion
      </h5>
      <p>
       The heap-based solution for merging k sorted linked lists is efficient and elegant, leveraging the min heapâs properties to ensure that the merged list is sorted with optimal time and space complexity. This method stands out for its ability to handle multiple lists simultaneously while maintaining a manageable heap size.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#29d3cce6-0c04-4698-bd9f-576bfd49366f'}">
       <li class="uk-active">
        <a href="solution-23.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-23.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-23.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-23.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-23.html">
         TypeScript
        </a>
       </li>
       <li>
        <a href="solution-23.html">
         Javascript
        </a>
       </li>
       <li>
        <a href="solution-23.html">
         Ruby
        </a>
       </li>
       <li>
        <a href="solution-23.html">
         C#
        </a>
       </li>
       <li>
        <a href="solution-23.html">
         RenderScript
        </a>
       </li>
       <li>
        <a href="solution-23.html">
         Php
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="29d3cce6-0c04-4698-bd9f-576bfd49366f">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Merge_k_Sorted_Lists</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">Merge_k_Sorted_Lists</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Merge_k_Sorted_Lists</span><span class="o">();</span>
        <span class="nc">Solution</span> <span class="n">s</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="na">new</span> <span class="nf">Solution</span><span class="o">();</span>

        <span class="nc">ListNode</span> <span class="n">l1</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">l2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

        <span class="n">s</span><span class="o">.</span><span class="na">mergeKLists</span><span class="o">(</span><span class="k">new</span> <span class="nc">ListNode</span><span class="o">[]{</span><span class="n">l1</span><span class="o">,</span> <span class="n">l2</span><span class="o">});</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">mergeKLists</span><span class="o">(</span><span class="nc">ListNode</span><span class="o">[]</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">lists</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">lists</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// same as merge sort array</span>
            <span class="k">return</span> <span class="nf">merge</span><span class="o">(</span><span class="n">lists</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">lists</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">merge</span><span class="o">(</span><span class="nc">ListNode</span><span class="o">[]</span> <span class="n">lists</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>

            <span class="c1">// single list</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">lists</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>
            <span class="o">}</span>

            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">start</span><span class="o">;</span>
            <span class="nc">ListNode</span> <span class="n">leftHalf</span> <span class="o">=</span> <span class="n">merge</span><span class="o">(</span><span class="n">lists</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>
            <span class="nc">ListNode</span> <span class="n">rightHalf</span> <span class="o">=</span> <span class="n">merge</span><span class="o">(</span><span class="n">lists</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>

            <span class="k">return</span> <span class="nf">mergeTwoLists</span><span class="o">(</span><span class="n">leftHalf</span><span class="o">,</span> <span class="n">rightHalf</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// from previous question: 21 Merge Two Sorted Lists</span>
        <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">mergeTwoLists</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">l2</span><span class="o">)</span> <span class="o">{</span>

            <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="nc">ListNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>

            <span class="k">while</span> <span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">v1</span> <span class="o">=</span> <span class="o">(</span><span class="n">l1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">:</span> <span class="n">l1</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="kt">int</span> <span class="n">v2</span> <span class="o">=</span> <span class="o">(</span><span class="n">l2</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">:</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">v1</span> <span class="o">&lt;</span> <span class="n">v2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l1</span><span class="o">;</span>
                    <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l2</span><span class="o">;</span>
                    <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> <span class="c1">// now current is the new end node, but still pointing to next node</span>
                <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// @note: key, cut this node from l1 or l2</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="c1">//////</span>

<span class="kd">class</span> <span class="nc">Solution_Heap</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">mergeKLists</span><span class="o">(</span><span class="nc">ListNode</span><span class="o">[]</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>

		<span class="k">if</span> <span class="o">(</span><span class="n">lists</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">lists</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
		<span class="o">}</span>

		<span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
		<span class="nc">ListNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>

		<span class="c1">// put 1st of each list to heap</span>
		<span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">ListNode</span><span class="o">&gt;</span> <span class="n">heap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span>
			<span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">val</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="na">val</span>
		<span class="o">);</span>

		<span class="c1">//</span>
		<span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">lists</span><span class="o">).</span><span class="na">filter</span><span class="o">(</span><span class="nl">Objects:</span><span class="o">:</span><span class="n">nonNull</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="nl">heap:</span><span class="o">:</span><span class="n">offer</span><span class="o">);</span>

		<span class="k">while</span> <span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="nc">ListNode</span> <span class="n">polled</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>

			<span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">polled</span><span class="o">;</span>
			<span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

			<span class="k">if</span> <span class="o">(</span><span class="n">polled</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">heap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">polled</span><span class="o">.</span><span class="na">next</span><span class="o">);</span> <span class="c1">// @note: heap.offer()åæ°ä¸è½æ¯null</span>
			<span class="o">}</span>
		<span class="o">}</span>

		<span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">//////</span>

<span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">mergeKLists</span><span class="o">(</span><span class="nc">ListNode</span><span class="o">[]</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">lists</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">lists</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">mergeLists</span><span class="o">(</span><span class="n">lists</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">lists</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">lists</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">ListNode</span> <span class="nf">mergeLists</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">l2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">();</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;=</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l1</span><span class="o">;</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l2</span><span class="o">;</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">l2</span> <span class="o">:</span> <span class="n">l1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1">// OJ: https://leetcode.com/problems/merge-k-sorted-lists/</span>
<span class="c1">// Time: O(NlogK)</span>
<span class="c1">// Space: O(K)</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">mergeKLists</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">*&gt;&amp;</span> <span class="n">lists</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="n">dummy</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">cmp</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span> <span class="p">};</span>
        <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">*</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">*&gt;</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">cmp</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">(</span><span class="n">cmp</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">list</span> <span class="o">:</span> <span class="n">lists</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">list</span><span class="p">);</span> <span class="c1">// avoid pushing NULL list.</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-python highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeKLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">ListNode</span><span class="p">,</span> <span class="s">"__lt__"</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="p">[</span><span class="n">head</span> <span class="k">for</span> <span class="n">head</span> <span class="ow">in</span> <span class="n">lists</span> <span class="k">if</span> <span class="n">head</span><span class="p">]</span>
        <span class="n">heapify</span><span class="p">(</span><span class="n">pq</span><span class="p">)</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">pq</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">pq</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
                <span class="n">heappush</span><span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">)</span>
            <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span>


<span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span>
<span class="c1">######
</span>

<span class="kn">import</span> <span class="nn">heapq</span>


<span class="s">'''
__lt__(self, other) for &lt;
__le__(self,other) for &lt;=
__gt__(self, other) for &gt;
__ge__(self, other) for &gt;=
'''</span>

<span class="s">'''
# or create a wrapper class, without modifying existing node class
class NodeWrapper:
    def __init__(self, node):
        self.node = node
    
    def __lt__(self, other):
        return self.node.val &lt; other.node.val

'''</span>

<span class="c1"># overwrite the comparison function, so the node can be comparable
# or else, error, TypeError: '&lt;' not supported between instances of 'ListNode' and 'ListNode'
</span>
<span class="c1"># define 'gt' will also work, so either lt or gt will do the compare job for ListNode
# ListNode.__gt__ = lambda x, y: (x.val &gt; y.val)
</span>
<span class="n">ListNode</span><span class="p">.</span><span class="n">__lt__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">mergeKLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">current</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lists</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
                <span class="c1"># need to override
</span>                <span class="c1"># or else error: TypeError: '&lt;' not supported between instances of 'ListNode' and 'ListNode'
</span>                <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">heap</span><span class="p">:</span>
            <span class="n">anode</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>

            <span class="n">current</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">anode</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>

            <span class="k">if</span> <span class="n">anode</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
                <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">anode</span><span class="p">.</span><span class="nb">next</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span>

<span class="s">'''
tried to use node.val to order heap, but still got error TypeError: '&lt;' not supported between instances of 'ListNode' and 'ListNode': 

heapq.heappush(heap, (node.val, node))

'''</span>

<span class="c1">######
</span>
<span class="c1"># based on merge 2 lists
# note for empty input
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeKLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">lists</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">mergeKListsHelper</span><span class="p">(</span><span class="n">lists</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mergeKListsHelper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]],</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>

        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lists</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>

        <span class="n">mid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">mergeKListsHelper</span><span class="p">(</span><span class="n">lists</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span>
        <span class="c1"># print(left)
</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">mergeKListsHelper</span><span class="p">(</span><span class="n">lists</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="c1"># print(right)
</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">],</span> <span class="n">list2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">dummy</span>
        <span class="c1"># print("merging: ", list1)
</span>        <span class="c1"># print("merging: ", list2)
</span>        <span class="k">while</span> <span class="n">list1</span> <span class="ow">or</span> <span class="n">list2</span><span class="p">:</span>
            <span class="n">v1</span> <span class="o">=</span> <span class="n">list1</span><span class="p">.</span><span class="n">val</span> <span class="k">if</span> <span class="n">list1</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">list2</span><span class="p">.</span><span class="n">val</span> <span class="k">if</span> <span class="n">list2</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">v1</span> <span class="o">&lt;</span> <span class="n">v2</span><span class="p">:</span>
                <span class="n">current</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">list1</span>
                <span class="n">list1</span> <span class="o">=</span> <span class="n">list1</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">list2</span>
                <span class="n">list2</span> <span class="o">=</span> <span class="n">list2</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>

        <span class="c1"># print("merging result: ", dummy.next)
</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span>

<span class="c1">############
</span>
<span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeKLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span> <span class="c1"># this is o(N) times of merge, while if use divide-mid-mere then it's o(logN) times of merge
</span>            <span class="n">lists</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lists</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">,</span> <span class="n">l2</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">dummy</span>
        <span class="k">while</span> <span class="n">l1</span> <span class="ow">and</span> <span class="n">l2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">l1</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">l2</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">l1</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">l2</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">l1</span> <span class="ow">or</span> <span class="n">l2</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span>



<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>

    <span class="n">l1</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">l1</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">l1</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

    <span class="n">l2</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">l2</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">l2</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

    <span class="n">l3</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">l3</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="n">Solution</span><span class="p">().</span><span class="n">mergeKLists</span><span class="p">([</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">l3</span><span class="p">]))</span>

    <span class="k">print</span><span class="p">(</span><span class="n">Solution</span><span class="p">().</span><span class="n">mergeKLists</span><span class="p">([]))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">Solution</span><span class="p">().</span><span class="n">mergeKLists</span><span class="p">([[]]))</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */</span>
 <span class="k">func</span> <span class="n">mergeKLists</span><span class="p">(</span><span class="n">lists</span> <span class="p">[]</span><span class="o">*</span><span class="n">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="n">ListNode</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">nil</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="m">1</span><span class="p">],</span> <span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">lists</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
<span class="p">}</span>

 <span class="k">func</span> <span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">l1</span> <span class="o">*</span><span class="n">ListNode</span><span class="p">,</span> <span class="n">l2</span> <span class="o">*</span><span class="n">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="n">ListNode</span> <span class="p">{</span>
    <span class="n">dummy</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">ListNode</span><span class="p">{}</span>
    <span class="n">cur</span> <span class="o">:=</span> <span class="n">dummy</span>
    <span class="k">for</span> <span class="n">l1</span> <span class="o">!=</span> <span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="n">l2</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">l1</span><span class="o">.</span><span class="n">Val</span> <span class="o">&lt;=</span> <span class="n">l2</span><span class="o">.</span><span class="n">Val</span> <span class="p">{</span>
            <span class="n">cur</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="n">l1</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="n">Next</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">cur</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="n">l2</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="n">Next</span>
        <span class="p">}</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">Next</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">l1</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">cur</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="n">l1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">l2</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">cur</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="n">l2</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="n">Next</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */</span>

<span class="kd">function</span> <span class="nx">mergeKLists</span><span class="p">(</span><span class="nx">lists</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">ListNode</span> <span class="o">|</span> <span class="kc">null</span><span class="o">&gt;</span><span class="p">):</span> <span class="nx">ListNode</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">lists</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">end</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">end</span> <span class="o">-</span> <span class="nx">start</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">lists</span><span class="p">[</span><span class="nx">start</span><span class="p">]</span> <span class="o">??</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">const</span> <span class="nx">mid</span> <span class="o">=</span> <span class="p">(</span><span class="nx">start</span> <span class="o">+</span> <span class="nx">end</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">mid</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">mid</span><span class="p">,</span> <span class="nx">end</span><span class="p">);</span>

        <span class="kd">const</span> <span class="nx">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">();</span>
        <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="nx">dummy</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">left</span> <span class="o">||</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="na">next</span><span class="p">:</span> <span class="nx">ListNode</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">(</span><span class="nx">left</span> <span class="o">??</span> <span class="p">{</span> <span class="na">val</span><span class="p">:</span> <span class="kc">Infinity</span> <span class="p">}).</span><span class="nx">val</span> <span class="o">&lt;</span>
                <span class="p">(</span><span class="nx">right</span> <span class="o">??</span> <span class="p">{</span> <span class="na">val</span><span class="p">:</span> <span class="kc">Infinity</span> <span class="p">}).</span><span class="nx">val</span>
            <span class="p">)</span> <span class="p">{</span>
                <span class="nx">next</span> <span class="o">=</span> <span class="nx">left</span><span class="p">;</span>
                <span class="nx">left</span> <span class="o">=</span> <span class="nx">left</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">next</span> <span class="o">=</span> <span class="nx">right</span><span class="p">;</span>
                <span class="nx">right</span> <span class="o">=</span> <span class="nx">right</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">next</span><span class="p">;</span>
            <span class="nx">cur</span> <span class="o">=</span> <span class="nx">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">dummy</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-js highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */</span>
<span class="cm">/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */</span>
<span class="kd">var</span> <span class="nx">mergeKLists</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">lists</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">lists</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">lists</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">mergeTwoLists</span><span class="p">(</span><span class="nx">lists</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="nx">lists</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">lists</span><span class="p">[</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">mergeTwoLists</span><span class="p">(</span><span class="nx">l1</span><span class="p">,</span> <span class="nx">l2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">();</span>
    <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="nx">dummy</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">l1</span> <span class="o">&amp;&amp;</span> <span class="nx">l2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">l1</span><span class="p">.</span><span class="nx">val</span> <span class="o">&lt;=</span> <span class="nx">l2</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">l1</span><span class="p">;</span>
            <span class="nx">l1</span> <span class="o">=</span> <span class="nx">l1</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">l2</span><span class="p">;</span>
            <span class="nx">l2</span> <span class="o">=</span> <span class="nx">l2</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">cur</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">l1</span> <span class="o">||</span> <span class="nx">l2</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">dummy</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-rb highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode</span>
<span class="c1">#     attr_accessor :val, :next</span>
<span class="c1">#     def initialize(val = 0, _next = nil)</span>
<span class="c1">#         @val = val</span>
<span class="c1">#         @next = _next</span>
<span class="c1">#     end</span>
<span class="c1"># end</span>
<span class="c1"># @param {ListNode[]} lists</span>
<span class="c1"># @return {ListNode}</span>
<span class="k">def</span> <span class="nf">merge_k_lists</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">lists</span><span class="p">.</span><span class="nf">length</span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span>
      <span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">merge_two_lists</span><span class="p">(</span><span class="n">lists</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">end</span>
  <span class="n">lists</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">merge_two_lists</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span>
<span class="n">dummy</span> <span class="o">=</span> <span class="no">ListNode</span><span class="p">.</span><span class="nf">new</span><span class="p">()</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">dummy</span>
<span class="k">while</span> <span class="n">l1</span> <span class="o">&amp;&amp;</span> <span class="n">l2</span>
    <span class="k">if</span> <span class="n">l1</span><span class="p">.</span><span class="nf">val</span> <span class="o">&lt;=</span> <span class="n">l2</span><span class="p">.</span><span class="nf">val</span>
        <span class="n">cur</span><span class="p">.</span><span class="nf">next</span> <span class="o">=</span> <span class="n">l1</span>
        <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="p">.</span><span class="nf">next</span>
    <span class="k">else</span>
        <span class="n">cur</span><span class="p">.</span><span class="nf">next</span> <span class="o">=</span> <span class="n">l2</span>
        <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="p">.</span><span class="nf">next</span>
    <span class="k">end</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nf">next</span>
<span class="k">end</span>
<span class="n">cur</span><span class="p">.</span><span class="nf">next</span> <span class="o">=</span> <span class="n">l1</span> <span class="o">||</span> <span class="n">l2</span>
<span class="n">dummy</span><span class="p">.</span><span class="nf">next</span>
<span class="k">end</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public int val;
 *     public ListNode next;
 *     public ListNode(int val=0, ListNode next=null) {
 *         this.val = val;
 *         this.next = next;
 *     }
 * }
 */</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">ListNode</span> <span class="nf">MergeKLists</span><span class="p">(</span><span class="n">ListNode</span><span class="p">[]</span> <span class="n">lists</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="n">lists</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">MergeTwoLists</span><span class="p">(</span><span class="n">lists</span><span class="p">[</span><span class="n">i</span> <span class="p">-</span> <span class="m">1</span><span class="p">],</span> <span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">lists</span><span class="p">[</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="n">ListNode</span> <span class="nf">MergeTwoLists</span><span class="p">(</span><span class="n">ListNode</span> <span class="n">l1</span><span class="p">,</span> <span class="n">ListNode</span> <span class="n">l2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="n">dummy</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ListNode</span><span class="p">();</span>
        <span class="n">ListNode</span> <span class="n">cur</span> <span class="p">=</span> <span class="n">dummy</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">l1</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">l2</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">l1</span><span class="p">.</span><span class="n">val</span> <span class="p">&lt;=</span> <span class="n">l2</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">cur</span><span class="p">.</span><span class="n">next</span> <span class="p">=</span> <span class="n">l1</span><span class="p">;</span>
                <span class="n">l1</span> <span class="p">=</span> <span class="n">l1</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">cur</span><span class="p">.</span><span class="n">next</span> <span class="p">=</span> <span class="n">l2</span><span class="p">;</span>
                <span class="n">l2</span> <span class="p">=</span> <span class="n">l2</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">cur</span> <span class="p">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cur</span><span class="p">.</span><span class="n">next</span> <span class="p">=</span> <span class="n">l1</span> <span class="p">==</span> <span class="k">null</span> <span class="p">?</span> <span class="n">l2</span> <span class="p">:</span> <span class="n">l1</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-rs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1">// Definition for singly-linked list.</span>
<span class="c1">// #[derive(PartialEq, Eq, Clone, Debug)]</span>
<span class="c1">// pub struct ListNode {</span>
<span class="c1">//   pub val: i32,</span>
<span class="c1">//   pub next: Option&lt;Box&lt;ListNode&gt;&gt;</span>
<span class="c1">// }</span>
<span class="c1">//</span>
<span class="c1">// impl ListNode {</span>
<span class="c1">//   #[inline]</span>
<span class="c1">//   fn new(val: i32) -&gt; Self {</span>
<span class="c1">//     ListNode {</span>
<span class="c1">//       next: None,</span>
<span class="c1">//       val</span>
<span class="c1">//     }</span>
<span class="c1">//   }</span>
<span class="c1">// }</span>
<span class="k">impl</span> <span class="n">Solution</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">merge_k_lists</span><span class="p">(</span><span class="k">mut</span> <span class="n">lists</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">lists</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">Self</span><span class="p">::</span><span class="nf">dfs</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">lists</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">dfs</span><span class="p">(</span>
        <span class="n">lists</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">end</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">lists</span><span class="nf">.get</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">lists</span><span class="p">[</span><span class="n">start</span><span class="p">]</span><span class="nf">.take</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">left</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">dfs</span><span class="p">(</span><span class="n">lists</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">right</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">dfs</span><span class="p">(</span><span class="n">lists</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">dummy</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">ListNode</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">dummy</span><span class="p">;</span>
        <span class="k">while</span> <span class="n">left</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">||</span> <span class="n">right</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
            <span class="k">if</span> <span class="n">left</span><span class="nf">.is_some</span><span class="p">()</span>
                <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">right</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">||</span> <span class="n">left</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.val</span> <span class="o">&lt;</span> <span class="n">right</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.val</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">left</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.next</span><span class="nf">.take</span><span class="p">();</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">left</span><span class="nf">.take</span><span class="p">();</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">right</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.next</span><span class="nf">.take</span><span class="p">();</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">right</span><span class="nf">.take</span><span class="p">();</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">cur</span><span class="py">.next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="py">.next</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">dummy</span><span class="py">.next</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-php highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for singly-linked list.</span>
<span class="kd">class</span> <span class="nc">ListNode</span> <span class="p">{</span>
    <span class="k">public</span> <span class="nv">$val</span><span class="p">;</span>
    <span class="k">public</span> <span class="nv">$next</span><span class="p">;</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">__construct</span><span class="p">(</span><span class="nv">$val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">$next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="nv">$val</span><span class="p">;</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nv">$next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="cd">/**
     * @param ListNode[] $lists
     * @return ListNode
     */</span>

    <span class="k">function</span> <span class="n">mergeKLists</span><span class="p">(</span><span class="nv">$lists</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$numLists</span> <span class="o">=</span> <span class="nb">count</span><span class="p">(</span><span class="nv">$lists</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="nv">$numLists</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="nv">$numLists</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="nv">$mid</span> <span class="o">=</span> <span class="nb">intval</span><span class="p">(</span><span class="nv">$numLists</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nv">$i</span> <span class="o">&lt;</span> <span class="nv">$mid</span><span class="p">;</span> <span class="nv">$i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nv">$lists</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">mergeTwoLists</span><span class="p">(</span><span class="nv">$lists</span><span class="p">[</span><span class="nv">$i</span><span class="p">],</span> <span class="nv">$lists</span><span class="p">[</span><span class="nv">$numLists</span> <span class="o">-</span> <span class="nv">$i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="nv">$numLists</span> <span class="o">=</span> <span class="nb">intval</span><span class="p">((</span><span class="nv">$numLists</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nv">$lists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="n">mergeTwoLists</span><span class="p">(</span><span class="nv">$list1</span><span class="p">,</span> <span class="nv">$list2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="nv">$current</span> <span class="o">=</span> <span class="nv">$dummy</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="nv">$list1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nv">$list2</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nv">$list1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="nv">$list2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
                <span class="nv">$current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nv">$list1</span><span class="p">;</span>
                <span class="nv">$list1</span> <span class="o">=</span> <span class="nv">$list1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nv">$current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nv">$list2</span><span class="p">;</span>
                <span class="nv">$list2</span> <span class="o">=</span> <span class="nv">$list2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nv">$current</span> <span class="o">=</span> <span class="nv">$current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$list1</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="nv">$current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nv">$list1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">elseif</span> <span class="p">(</span><span class="nv">$list2</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="nv">$current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nv">$list2</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nv">$dummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-23.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
