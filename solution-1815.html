<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-1815.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-1815.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>1815 - Maximum Number of Groups Getting Fresh Donuts</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 1815. Maximum Number of Groups Getting Fresh Donuts Description There is a donuts shop that bakes donuts in batches of batchSize. They have a rule where they must serve all of the donuts of a batch before serving any donuts of the next batch. You...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-1815.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-1815.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-1815.html" rel="stylesheet"/>
   <link href="solution-1815.html" rel="stylesheet"/>
   <link href="solution-1815.html" rel="stylesheet"/>
   <link href="solution-1815.html" rel="stylesheet"/>
   <link href="solution-1815.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="1815 - Maximum Number of Groups Getting Fresh Donuts" property="og:title"/>
   <meta content="Leetcode 1815. Maximum Number of Groups Getting Fresh Donuts Description There is a donuts shop that bakes donuts in batches of batchSize. They have a rule where they must serve all of the donuts of a batch before serving any donuts of the next batch. You are given an integer batchSize and an integer array groups, where groups[i] denotes that there is a group of groups[i] customers that will visit the shop. Each customer will get exactly one donut. When a group visits the shop, all customers of the group must be served before serving any of the following groups. A group will be happy if they all get fresh donuts. That is, the first customer of the group does not receive a donut that was left over from the previous group. You can freely rearrange the ordering of the groups. Return the maximum possible number of happy groups after rearranging the groups. &amp;nbsp; Example 1: Input: batchSize = 3, groups = [1,2,3,4,5,6] Output: 4 Explanation: You can arrange the groups as [6,2,4,5,1,3]. Then the 1st, 2nd, 4th, and 6th groups will be happy. Example 2: Input: batchSize = 4, groups = [1,3,2,5,2,2,1,6] Output: 4 &amp;nbsp; Constraints: 1 &amp;lt;= batchSize &amp;lt;= 9 1 &amp;lt;= groups.length &amp;lt;= 30 1 &amp;lt;= groups[i] &amp;lt;= 109 Solutions Solution 1: Greedy + State Compression + Memorized Search The problem actually asks us to find an arrangement order that maximizes the number of groups whose prefix sum (referring to ânumber of peopleâ here) modulo $batchSize$ equals $0$. Therefore, we can divide all customers into two categories: Customers whose number is a multiple of $batchSize$. These customers will not affect the donuts of the next group of customers. We can greedily arrange these groups of customers first, so these groups of customers will be happy. The âinitial answerâ is the number of these groups. Customers whose number is not a multiple of $batchSize$. The arrangement order of these customers will affect the donuts of the next group of customers. We can take the modulo $batchSize$ for the number of people $v$ in each group here, and the remainders form a set. The range of element values in the set is $[1,2â¦,batchSize-1]$. The maximum length of the $groups$ array is $30$, so the maximum number of each remainder does not exceed $30$. We can use $5$ binary bits to represent the quantity of a remainder, and the maximum $batchSize$ is $9$, so the total number of binary bits required to represent these remainders and their quantities is $5\times (9-1)=40$. We can use a $64$-bit integer $state$ to represent it. Next, we design a function $dfs(state, mod)$, which represents the number of groups that can be happy when the arrangement state is $state$ and the current prefix remainder is $mod$. Then our âinitial answerâ plus $dfs(state, 0)$ is the final answer. The implementation logic of the function $dfs(state, mod)$ is as follows: We enumerate each remainder $i$ from $1$ to $batchSize-1$. If the quantity of..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2020-11-18T00:00:00-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2020-11-18-1815-Maximum-Number-of-Groups-Getting-Fresh-Donuts/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-1815.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="1815 - Maximum Number of Groups Getting Fresh Donuts" property="twitter:title"/>
   <meta content="Leetcode 1815. Maximum Number of Groups Getting Fresh Donuts Description There is a donuts shop that bakes donuts in batches of batchSize. They have a rule where they must serve all of the donuts of a batch before serving any donuts of the next batch. You are given an integer batchSize and an integer array groups, where groups[i] denotes that there is a group of groups[i] customers that will visit the shop. Each customer will get exactly one donut. When a group visits the shop, all customers of the group must be served before serving any of the following groups. A group will be happy if they all get fresh donuts. That is, the first customer of the group does not receive a donut that was left over from the previous group. You can freely rearrange the ordering of the groups. Return the maximum possible number of happy groups after rearranging the groups. &amp;nbsp; Example 1: Input: batchSize = 3, groups = [1,2,3,4,5,6] Output: 4 Explanation: You can arrange the groups as [6,2,4,5,1,3]. Then the 1st, 2nd, 4th, and 6th groups will be happy. Example 2: Input: batchSize = 4, groups = [1,3,2,5,2,2,1,6] Output: 4 &amp;nbsp; Constraints: 1 &amp;lt;= batchSize &amp;lt;= 9 1 &amp;lt;= groups.length &amp;lt;= 30 1 &amp;lt;= groups[i] &amp;lt;= 109 Solutions Solution 1: Greedy + State Compression + Memorized Search The problem actually asks us to find an arrangement order that maximizes the number of groups whose prefix sum (referring to ânumber of peopleâ here) modulo $batchSize$ equals $0$. Therefore, we can divide all customers into two categories: Customers whose number is a multiple of $batchSize$. These customers will not affect the donuts of the next group of customers. We can greedily arrange these groups of customers first, so these groups of customers will be happy. The âinitial answerâ is the number of these groups. Customers whose number is not a multiple of $batchSize$. The arrangement order of these customers will affect the donuts of the next group of customers. We can take the modulo $batchSize$ for the number of people $v$ in each group here, and the remainders form a set. The range of element values in the set is $[1,2â¦,batchSize-1]$. The maximum length of the $groups$ array is $30$, so the maximum number of each remainder does not exceed $30$. We can use $5$ binary bits to represent the quantity of a remainder, and the maximum $batchSize$ is $9$, so the total number of binary bits required to represent these remainders and their quantities is $5\times (9-1)=40$. We can use a $64$-bit integer $state$ to represent it. Next, we design a function $dfs(state, mod)$, which represents the number of groups that can be happy when the arrangement state is $state$ and the current prefix remainder is $mod$. Then our âinitial answerâ plus $dfs(state, 0)$ is the final answer. The implementation logic of the function $dfs(state, mod)$ is as follows: We enumerate each remainder $i$ from $1$ to $batchSize-1$. If the quantity of..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    1815 - Maximum Number of Groups Getting Fresh Donuts | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="1815 - Maximum Number of Groups Getting Fresh Donuts" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-1815.html" rel="canonical">
          <meta content="https://leetcode.ca/2020-11-18-1815-Maximum-Number-of-Groups-Getting-Fresh-Donuts/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2020-11-18T00:00:00-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"1815 - Maximum Number of Groups Getting Fresh Donuts","dateModified":"2020-11-18T00:00:00-08:00","datePublished":"2020-11-18T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2020-11-18-1815-Maximum-Number-of-Groups-Getting-Fresh-Donuts/"},"url":"https://leetcode.ca/2020-11-18-1815-Maximum-Number-of-Groups-Getting-Fresh-Donuts/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="1815-maximum-number-of-groups-getting-fresh-donuts">
       <a href="solution-1815.html">
        1815. Maximum Number of Groups Getting Fresh Donuts
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       There is a donuts shop that bakes donuts in batches of
       <code>
        batchSize
       </code>
       . They have a rule where they must serve
       <strong>
        all
       </strong>
       of the donuts of a batch before serving any donuts of the next batch. You are given an integer
       <code>
        batchSize
       </code>
       and an integer array
       <code>
        groups
       </code>
       , where
       <code>
        groups[i]
       </code>
       denotes that there is a group of
       <code>
        groups[i]
       </code>
       customers that will visit the shop. Each customer will get exactly one donut.
      </p>
      <p>
       When a group visits the shop, all customers of the group must be served before serving any of the following groups. A group will be happy if they all get fresh donuts. That is, the first customer of the group does not receive a donut that was left over from the previous group.
      </p>
      <p>
       You can freely rearrange the ordering of the groups. Return
       <em>
        the
        <strong>
         maximum
        </strong>
        possible number of happy groups after rearranging the groups.
       </em>
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> batchSize = 3, groups = [1,2,3,4,5,6]
<strong>Output:</strong> 4
<strong>Explanation:</strong> You can arrange the groups as [6,2,4,5,1,3]. Then the 1<sup>st</sup>, 2<sup>nd</sup>, 4<sup>th</sup>, and 6<sup>th</sup> groups will be happy.
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> batchSize = 4, groups = [1,3,2,5,2,2,1,6]
<strong>Output:</strong> 4
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= batchSize &lt;= 9
        </code>
       </li>
       <li>
        <code>
         1 &lt;= groups.length &lt;= 30
        </code>
       </li>
       <li>
        <code>
         1 &lt;= groups[i] &lt;= 10
         <sup>
          9
         </sup>
        </code>
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       <strong>
        Solution 1: Greedy + State Compression + Memorized Search
       </strong>
      </p>
      <p>
       The problem actually asks us to find an arrangement order that maximizes the number of groups whose prefix sum (referring to ânumber of peopleâ here) modulo $batchSize$ equals $0$. Therefore, we can divide all customers into two categories:
      </p>
      <ul>
       <li>
        Customers whose number is a multiple of $batchSize$. These customers will not affect the donuts of the next group of customers. We can greedily arrange these groups of customers first, so these groups of customers will be happy. The âinitial answerâ is the number of these groups.
       </li>
       <li>
        Customers whose number is not a multiple of $batchSize$. The arrangement order of these customers will affect the donuts of the next group of customers. We can take the modulo $batchSize$ for the number of people $v$ in each group here, and the remainders form a set. The range of element values in the set is $[1,2â¦,batchSize-1]$. The maximum length of the $groups$ array is $30$, so the maximum number of each remainder does not exceed $30$. We can use $5$ binary bits to represent the quantity of a remainder, and the maximum $batchSize$ is $9$, so the total number of binary bits required to represent these remainders and their quantities is $5\times (9-1)=40$. We can use a $64$-bit integer $state$ to represent it.
       </li>
      </ul>
      <p>
       Next, we design a function $dfs(state, mod)$, which represents the number of groups that can be happy when the arrangement state is $state$ and the current prefix remainder is $mod$. Then our âinitial answerâ plus $dfs(state, 0)$ is the final answer.
      </p>
      <p>
       The implementation logic of the function $dfs(state, mod)$ is as follows:
      </p>
      <p>
       We enumerate each remainder $i$ from $1$ to $batchSize-1$. If the quantity of the remainder $i$ is not $0$, we can subtract $1$ from the quantity of the remainder $i$, add $i$ to the current prefix remainder and take modulo $batchSize$, then recursively call the function $dfs$ to find the optimal solution of the sub-state, and take the maximum value. Finally, check whether $mod$ is $0$. If it is $0$, we return after adding $1$ to the maximum value, otherwise we directly return the maximum value.
      </p>
      <p>
       During the process, we can use memorized search to avoid repeated calculation of states.
      </p>
      <p>
       The time complexity does not exceed $O(10^7)$, and the space complexity does not exceed $O(10^6)$.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#41da4b8c-a921-4a49-8a52-74fcc3443313'}">
       <li class="uk-active">
        <a href="solution-1815.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-1815.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-1815.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-1815.html">
         Go
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="41da4b8c-a921-4a49-8a52-74fcc3443313">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxHappyGroups</span><span class="o">(</span><span class="kt">int</span> <span class="n">batchSize</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">groups</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">batchSize</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">g</span> <span class="o">:</span> <span class="n">groups</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">g</span> <span class="o">%</span> <span class="n">size</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">++</span><span class="n">ans</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">state</span> <span class="o">+=</span> <span class="mi">1</span><span class="n">l</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">5</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">ans</span> <span class="o">+=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">state</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">long</span> <span class="n">state</span><span class="o">,</span> <span class="kt">int</span> <span class="n">mod</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">state</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">state</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">state</span> <span class="o">&gt;&gt;</span> <span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">5</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mi">31</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">state</span> <span class="o">-</span> <span class="o">(</span><span class="mi">1</span><span class="n">l</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">5</span><span class="o">)),</span> <span class="o">(</span><span class="n">mod</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span> <span class="o">%</span> <span class="n">size</span><span class="o">);</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">t</span> <span class="o">+</span> <span class="o">(</span><span class="n">mod</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">f</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">state</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">maxHappyGroups</span><span class="p">(</span><span class="kt">int</span> <span class="n">batchSize</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">groups</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">ll</span> <span class="o">=</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">ll</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">;</span>
        <span class="n">ll</span> <span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">:</span> <span class="n">groups</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">v</span> <span class="o">%</span> <span class="n">batchSize</span><span class="p">;</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">state</span> <span class="o">+=</span> <span class="mi">1ll</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">5</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="n">ll</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">ll</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">state</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">mod</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">batchSize</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">31</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">state</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1ll</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)),</span> <span class="p">(</span><span class="n">mod</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">batchSize</span><span class="p">);</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">x</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="n">ans</span> <span class="o">+=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxHappyGroups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batchSize</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">groups</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="o">@</span><span class="n">cache</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">mod</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mod</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">batchSize</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">state</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">31</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">state</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)),</span> <span class="p">(</span><span class="n">mod</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">batchSize</span><span class="p">)</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="n">state</span> <span class="o">=</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">v</span> <span class="o">%</span> <span class="n">batchSize</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">state</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">ans</span> <span class="o">+=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">maxHappyGroups</span><span class="p">(</span><span class="n">batchSize</span> <span class="kt">int</span><span class="p">,</span> <span class="n">groups</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">ans</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">state</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">groups</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">:=</span> <span class="n">v</span> <span class="o">%</span> <span class="n">batchSize</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">ans</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">state</span> <span class="o">+=</span> <span class="m">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="m">5</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">f</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">mod</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">v</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">f</span><span class="p">[</span><span class="n">state</span><span class="p">];</span> <span class="n">ok</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">v</span>
		<span class="p">}</span>
		<span class="n">res</span> <span class="o">:=</span> <span class="m">0</span>
		<span class="n">x</span> <span class="o">:=</span> <span class="m">0</span>
		<span class="k">if</span> <span class="n">mod</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">x</span> <span class="o">=</span> <span class="m">1</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">batchSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">state</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="m">5</span><span class="p">)</span><span class="o">&amp;</span><span class="m">31</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
				<span class="n">t</span> <span class="o">:=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">state</span><span class="o">-</span><span class="m">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="m">5</span><span class="p">),</span> <span class="p">(</span><span class="n">mod</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">batchSize</span><span class="p">)</span>
				<span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">t</span><span class="o">+</span><span class="n">x</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">f</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
		<span class="k">return</span> <span class="n">res</span>
	<span class="p">}</span>
	<span class="n">ans</span> <span class="o">+=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-1815.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
