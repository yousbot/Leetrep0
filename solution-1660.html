<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-1660.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-1660.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>1660 - Correct a Binary Tree</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 1660. Correct a Binary Tree Description You have a binary tree with a small defect. There is exactly one invalid node where its right child incorrectly points to another node at the same depth but to the invalid node&amp;#39;s right. Given the root of the...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-1660.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-1660.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-1660.html" rel="stylesheet"/>
   <link href="solution-1660.html" rel="stylesheet"/>
   <link href="solution-1660.html" rel="stylesheet"/>
   <link href="solution-1660.html" rel="stylesheet"/>
   <link href="solution-1660.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="1660 - Correct a Binary Tree" property="og:title"/>
   <meta content="Leetcode 1660. Correct a Binary Tree Description You have a binary tree with a small defect. There is exactly one invalid node where its right child incorrectly points to another node at the same depth but to the invalid node&amp;#39;s right. Given the root of the binary tree with this defect, root, return the root of the binary tree after removing this invalid node and every node underneath it (minus the node it incorrectly points to). Custom testing: The test input is read as 3 lines: TreeNode root int fromNode (not available to correctBinaryTree) int toNode (not available to correctBinaryTree) After the binary tree rooted at root is parsed, the TreeNode with value of fromNode will have its right child pointer pointing to the TreeNode with a value of toNode. Then, root is passed to correctBinaryTree. &amp;nbsp; Example 1: Input: root = [1,2,3], fromNode = 2, toNode = 3 Output: [1,null,3] Explanation: The node with value 2 is invalid, so remove it. Example 2: Input: root = [8,3,1,7,null,9,4,2,null,null,null,5,6], fromNode = 7, toNode = 4 Output: [8,3,1,null,null,9,4,null,null,5,6] Explanation: The node with value 7 is invalid, so remove it and the node underneath it, node 2. &amp;nbsp; Constraints: The number of nodes in the tree is in the range [3, 104]. -109 &amp;lt;= Node.val &amp;lt;= 109 All Node.val are unique. fromNode != toNode fromNode and toNode will exist in the tree and will be on the same depth. toNode is to the right of fromNode. fromNode.right is null in the initial tree from the test data. Solutions The solution aims to remove the problematic node that causes this invalidity, ensuring the binary tree does not contain any cycles. Approach The solution employs a recursive Depth-First Search (DFS) strategy to traverse the tree and identify the invalid node. A set named vis (short for âvisitedâ) is used to keep track of all visited nodes during the traversal. Recursive Function: dfs Base Case: If the current node (root) is None or the right child of the current node is already in the vis set, the function returns None. The latter condition indicates that the current nodeâs right child points back to a node on the path from the root, making the current node the one that needs to be removed to correct the tree. Recursive Step: Before exploring the children of the current node, the node itself is added to the vis set to mark it as visited. The function then recursively calls itself on the right child (root.right = dfs(root.right)) and the left child (root.left = dfs(root.left)), in that order. This order is crucial because the problem condition specifically involves the right child, so checking it first ensures that any invalidity is caught as early as possible. After possibly correcting the right and left subtrees, the function returns the current node (root), which is either unmodified if it and its subtrees were valid or adjusted if a subtree contained an invalid node. Set vis The vis set plays a..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2020-06-16T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2020-06-16-1660-Correct-a-Binary-Tree/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-1660.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="1660 - Correct a Binary Tree" property="twitter:title"/>
   <meta content="Leetcode 1660. Correct a Binary Tree Description You have a binary tree with a small defect. There is exactly one invalid node where its right child incorrectly points to another node at the same depth but to the invalid node&amp;#39;s right. Given the root of the binary tree with this defect, root, return the root of the binary tree after removing this invalid node and every node underneath it (minus the node it incorrectly points to). Custom testing: The test input is read as 3 lines: TreeNode root int fromNode (not available to correctBinaryTree) int toNode (not available to correctBinaryTree) After the binary tree rooted at root is parsed, the TreeNode with value of fromNode will have its right child pointer pointing to the TreeNode with a value of toNode. Then, root is passed to correctBinaryTree. &amp;nbsp; Example 1: Input: root = [1,2,3], fromNode = 2, toNode = 3 Output: [1,null,3] Explanation: The node with value 2 is invalid, so remove it. Example 2: Input: root = [8,3,1,7,null,9,4,2,null,null,null,5,6], fromNode = 7, toNode = 4 Output: [8,3,1,null,null,9,4,null,null,5,6] Explanation: The node with value 7 is invalid, so remove it and the node underneath it, node 2. &amp;nbsp; Constraints: The number of nodes in the tree is in the range [3, 104]. -109 &amp;lt;= Node.val &amp;lt;= 109 All Node.val are unique. fromNode != toNode fromNode and toNode will exist in the tree and will be on the same depth. toNode is to the right of fromNode. fromNode.right is null in the initial tree from the test data. Solutions The solution aims to remove the problematic node that causes this invalidity, ensuring the binary tree does not contain any cycles. Approach The solution employs a recursive Depth-First Search (DFS) strategy to traverse the tree and identify the invalid node. A set named vis (short for âvisitedâ) is used to keep track of all visited nodes during the traversal. Recursive Function: dfs Base Case: If the current node (root) is None or the right child of the current node is already in the vis set, the function returns None. The latter condition indicates that the current nodeâs right child points back to a node on the path from the root, making the current node the one that needs to be removed to correct the tree. Recursive Step: Before exploring the children of the current node, the node itself is added to the vis set to mark it as visited. The function then recursively calls itself on the right child (root.right = dfs(root.right)) and the left child (root.left = dfs(root.left)), in that order. This order is crucial because the problem condition specifically involves the right child, so checking it first ensures that any invalidity is caught as early as possible. After possibly correcting the right and left subtrees, the function returns the current node (root), which is either unmodified if it and its subtrees were valid or adjusted if a subtree contained an invalid node. Set vis The vis set plays a..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    1660 - Correct a Binary Tree | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="1660 - Correct a Binary Tree" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-1660.html" rel="canonical">
          <meta content="https://leetcode.ca/2020-06-16-1660-Correct-a-Binary-Tree/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2020-06-16T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"1660 - Correct a Binary Tree","dateModified":"2020-06-16T00:00:00-07:00","datePublished":"2020-06-16T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2020-06-16-1660-Correct-a-Binary-Tree/"},"url":"https://leetcode.ca/2020-06-16-1660-Correct-a-Binary-Tree/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="1660-correct-a-binary-tree">
       <a href="solution-1660.html">
        1660. Correct a Binary Tree
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       You have a binary tree with a small defect. There is
       <strong>
        exactly one
       </strong>
       invalid node where its right child incorrectly points to another node at the
       <strong>
        same depth
       </strong>
       but to the
       <b>
        invalid node's right
       </b>
       .
      </p>
      <p>
       Given the root of the binary tree with this defect,
       <code>
        root
       </code>
       , return
       <em>
        the root of the binary tree after
        <strong>
         removing
        </strong>
        this invalid node
        <strong>
         and every node underneath it
        </strong>
        (minus the node it incorrectly points to).
       </em>
      </p>
      <p>
       <strong>
        Custom testing:
       </strong>
      </p>
      <p>
       The test input is read as 3 lines:
      </p>
      <ul>
       <li>
        <code>
         TreeNode root
        </code>
       </li>
       <li>
        <code>
         int fromNode
        </code>
        (
        <strong>
         not available to
        </strong>
        <code>
         correctBinaryTree
        </code>
        )
       </li>
       <li>
        <code>
         int toNode
        </code>
        (
        <strong>
         not available to
        </strong>
        <code>
         correctBinaryTree
        </code>
        )
       </li>
      </ul>
      <p>
       After the binary tree rooted at
       <code>
        root
       </code>
       is parsed, the
       <code>
        TreeNode
       </code>
       with value of
       <code>
        fromNode
       </code>
       will have its right child pointer pointing to the
       <code>
        TreeNode
       </code>
       with a value of
       <code>
        toNode
       </code>
       . Then,
       <code>
        root
       </code>
       is passed to
       <code>
        correctBinaryTree
       </code>
       .
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <strong>
        <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1660.Correct%20a%20Binary%20Tree/images/ex1v2.png" style="width: 250px; height: 177px;"/>
       </strong>
      </p>
      <pre>
<strong>Input:</strong> root = [1,2,3], fromNode = 2, toNode = 3
<strong>Output:</strong> [1,null,3]
<strong>Explanation:</strong> The node with value 2 is invalid, so remove it.
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <p>
       <strong>
        <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1660.Correct%20a%20Binary%20Tree/images/ex2v3.png" style="width: 350px; height: 255px;"/>
       </strong>
      </p>
      <pre>
<strong>Input:</strong> root = [8,3,1,7,null,9,4,2,null,null,null,5,6], fromNode = 7, toNode = 4
<strong>Output:</strong> [8,3,1,null,null,9,4,null,null,5,6]
<strong>Explanation:</strong> The node with value 7 is invalid, so remove it and the node underneath it, node 2.
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the tree is in the range
        <code>
         [3, 10
         <sup>
          4
         </sup>
         ]
        </code>
        .
       </li>
       <li>
        <code>
         -10
         <sup>
          9
         </sup>
         &lt;= Node.val &lt;= 10
         <sup>
          9
         </sup>
        </code>
       </li>
       <li>
        All
        <code>
         Node.val
        </code>
        are
        <strong>
         unique
        </strong>
        .
       </li>
       <li>
        <code>
         fromNode != toNode
        </code>
       </li>
       <li>
        <code>
         fromNode
        </code>
        and
        <code>
         toNode
        </code>
        will exist in the tree and will be on the same depth.
       </li>
       <li>
        <code>
         toNode
        </code>
        is to the
        <strong>
         right
        </strong>
        of
        <code>
         fromNode
        </code>
        .
       </li>
       <li>
        <code>
         fromNode.right
        </code>
        is
        <code>
         null
        </code>
        in the initial tree from the test data.
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       The solution aims to remove the problematic node that causes this invalidity, ensuring the binary tree does not contain any cycles.
      </p>
      <h3 id="approach">
       Approach
      </h3>
      <p>
       The solution employs a recursive Depth-First Search (DFS) strategy to traverse the tree and identify the invalid node. A set named
       <code class="language-plaintext highlighter-rouge">
        vis
       </code>
       (short for âvisitedâ) is used to keep track of all visited nodes during the traversal.
      </p>
      <h3 id="recursive-function-dfs">
       Recursive Function:
       <code class="language-plaintext highlighter-rouge">
        dfs
       </code>
      </h3>
      <ul>
       <li>
        <p>
         <strong>
          Base Case
         </strong>
         : If the current node (
         <code class="language-plaintext highlighter-rouge">
          root
         </code>
         ) is
         <code class="language-plaintext highlighter-rouge">
          None
         </code>
         or the right child of the current node is already in the
         <code class="language-plaintext highlighter-rouge">
          vis
         </code>
         set, the function returns
         <code class="language-plaintext highlighter-rouge">
          None
         </code>
         . The latter condition indicates that the current nodeâs right child points back to a node on the path from the root, making the current node the one that needs to be removed to correct the tree.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Recursive Step
         </strong>
         :
        </p>
        <ul>
         <li>
          Before exploring the children of the current node, the node itself is added to the
          <code class="language-plaintext highlighter-rouge">
           vis
          </code>
          set to mark it as visited.
         </li>
         <li>
          The function then recursively calls itself on the right child (
          <code class="language-plaintext highlighter-rouge">
           root.right = dfs(root.right)
          </code>
          ) and the left child (
          <code class="language-plaintext highlighter-rouge">
           root.left = dfs(root.left)
          </code>
          ), in that order. This order is crucial because the problem condition specifically involves the right child, so checking it first ensures that any invalidity is caught as early as possible.
         </li>
         <li>
          After possibly correcting the right and left subtrees, the function returns the current node (
          <code class="language-plaintext highlighter-rouge">
           root
          </code>
          ), which is either unmodified if it and its subtrees were valid or adjusted if a subtree contained an invalid node.
         </li>
        </ul>
       </li>
      </ul>
      <h3 id="set-vis">
       Set
       <code class="language-plaintext highlighter-rouge">
        vis
       </code>
      </h3>
      <ul>
       <li>
        The
        <code class="language-plaintext highlighter-rouge">
         vis
        </code>
        set plays a critical role in identifying cycles caused by a nodeâs right child. By adding each visited node to this set, the algorithm can immediately recognize when a right child points back to an earlier node in the traversal path. This detection mechanism allows the algorithm to identify the exact node that needs to be removed to break the cycle and correct the tree.
       </li>
      </ul>
      <h3 id="return-value">
       Return Value
      </h3>
      <p>
       The corrected tree is returned by calling
       <code class="language-plaintext highlighter-rouge">
        dfs
       </code>
       on the original treeâs root. If the tree was already valid, it remains unchanged. If an invalid node was found, the tree is modified by removing this node, effectively breaking the cycle and ensuring the tree is a valid binary tree.
      </p>
      <h3 id="example">
       Example
      </h3>
      <p>
       Given a binary tree where a nodeâs right child creates a cycle by pointing back to one of its ancestors, this method will identify the problematic node and return a new tree where this node has been removed, thus eliminating the cycle and correcting the tree.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#0231dedb-316b-49a5-bcdc-a68ad6a10e9f'}">
       <li class="uk-active">
        <a href="solution-1660.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-1660.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-1660.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-1660.html">
         Javascript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="0231dedb-316b-49a5-bcdc-a68ad6a10e9f">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">vis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">correctBinaryTree</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">TreeNode</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">vis</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">vis</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">correctBinaryTree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">vis</span><span class="p">;</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span> <span class="o">||</span> <span class="n">vis</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">vis</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
            <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span>
<span class="c1"># iteration
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">correctBinaryTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="c1"># Remove the incorrect right child
</span>                <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">break</span>

            <span class="n">seen</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

            <span class="c1"># right first
</span>            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">root</span>

<span class="c1">#############
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span> <span class="c1"># recursive
</span>    <span class="k">def</span> <span class="nf">correctBinaryTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="ow">in</span> <span class="n">vis</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span> <span class="c1"># so will skip the invalid node
</span>            <span class="n">vis</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">root</span>

        <span class="n">vis</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-js highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="cm">/**
 * @param {TreeNode} root
 * @param {number} from
 * @param {number} to
 * @return {TreeNode}
 */</span>
<span class="kd">var</span> <span class="nx">correctBinaryTree</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="nx">root</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">root</span> <span class="o">||</span> <span class="nx">vis</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">vis</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
        <span class="nx">root</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
        <span class="nx">root</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">root</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kd">const</span> <span class="nx">vis</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>
    <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
<span class="p">};</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-1660.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
