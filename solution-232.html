<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-232.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-232.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>232 - Implement Queue using Stacks</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode Question Formatted question description: https://leetcode.ca/all/232.html Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: void push(int x) Pushes element x to...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-232.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-232.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-232.html" rel="stylesheet"/>
   <link href="solution-232.html" rel="stylesheet"/>
   <link href="solution-232.html" rel="stylesheet"/>
   <link href="solution-232.html" rel="stylesheet"/>
   <link href="solution-232.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="232 - Implement Queue using Stacks" property="og:title"/>
   <meta content="Leetcode Question Formatted question description: https://leetcode.ca/all/232.html Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue. boolean empty() Returns true if the queue is empty, false otherwise. Notes: You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack&amp;#39;s standard operations. &amp;nbsp; Example 1: Input [&amp;quot;MyQueue&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;peek&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;empty&amp;quot;] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false &amp;nbsp; Constraints: 1 &amp;lt;= x &amp;lt;= 9 At most 100&amp;nbsp;calls will be made to push, pop, peek, and empty. All the calls to pop and peek are valid. &amp;nbsp; Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer. Algorithm As long as the element is inserted from the front every time, for example, if a queue is 1, 2, 3, 4, then we save it in the stack as 4, 3, 2, 1, and then return to the top element 1, also It is the first element of the queue. The difficulty of this question is the push function. We need an auxiliary stack tmp, and store the elements of s into tmp in reverse order. At this time, add a new element x, and then store the elements in tmp back. This is the order we want , The other three operations also directly call stack operations. To optimize above, because every time you push, you have to flip both stacks, So, have stacks stk1 and stk2, the new pushed elements are cached in stk1 first, and all elements in stk1 are moved to stk2 only when the operations are pop and peek, which improves efficiency. Code Java C++ Python Go TypeScript RenderScript public class Implement_Queue_using_Stacks { class MyQueue { private Stack&amp;lt;Integer&amp;gt; stack1; private Stack&amp;lt;Integer&amp;gt; stack2; public MyQueue() { this.stack1 = new Stack&amp;lt;Integer&amp;gt;(); this.stack2 = new Stack&amp;lt;Integer&amp;gt;(); } // Push element x to the back of queue. public void push(int x) { stack1.push(x); } // Removes the element from in front of queue. public int pop() { if (!stack2.isEmpty()) { return stack2.pop();..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-07-19T22:21:01-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-07-19-232-Implement-Queue-using-Stacks/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-232.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="232 - Implement Queue using Stacks" property="twitter:title"/>
   <meta content="Leetcode Question Formatted question description: https://leetcode.ca/all/232.html Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue. boolean empty() Returns true if the queue is empty, false otherwise. Notes: You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack&amp;#39;s standard operations. &amp;nbsp; Example 1: Input [&amp;quot;MyQueue&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;peek&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;empty&amp;quot;] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false &amp;nbsp; Constraints: 1 &amp;lt;= x &amp;lt;= 9 At most 100&amp;nbsp;calls will be made to push, pop, peek, and empty. All the calls to pop and peek are valid. &amp;nbsp; Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer. Algorithm As long as the element is inserted from the front every time, for example, if a queue is 1, 2, 3, 4, then we save it in the stack as 4, 3, 2, 1, and then return to the top element 1, also It is the first element of the queue. The difficulty of this question is the push function. We need an auxiliary stack tmp, and store the elements of s into tmp in reverse order. At this time, add a new element x, and then store the elements in tmp back. This is the order we want , The other three operations also directly call stack operations. To optimize above, because every time you push, you have to flip both stacks, So, have stacks stk1 and stk2, the new pushed elements are cached in stk1 first, and all elements in stk1 are moved to stk2 only when the operations are pop and peek, which improves efficiency. Code Java C++ Python Go TypeScript RenderScript public class Implement_Queue_using_Stacks { class MyQueue { private Stack&amp;lt;Integer&amp;gt; stack1; private Stack&amp;lt;Integer&amp;gt; stack2; public MyQueue() { this.stack1 = new Stack&amp;lt;Integer&amp;gt;(); this.stack2 = new Stack&amp;lt;Integer&amp;gt;(); } // Push element x to the back of queue. public void push(int x) { stack1.push(x); } // Removes the element from in front of queue. public int pop() { if (!stack2.isEmpty()) { return stack2.pop();..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    232 - Implement Queue using Stacks | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="232 - Implement Queue using Stacks" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-232.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-07-19-232-Implement-Queue-using-Stacks/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-07-19T22:21:01-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"232 - Implement Queue using Stacks","dateModified":"2016-07-19T22:21:01-07:00","datePublished":"2016-07-19T22:21:01-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-07-19-232-Implement-Queue-using-Stacks/"},"url":"https://leetcode.ca/2016-07-19-232-Implement-Queue-using-Stacks/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="question">
       Question
      </h1>
      <p>
       Formatted question description:
       <a href="solution-232.html">
        https://leetcode.ca/all/232.html
       </a>
      </p>
      <p>
       Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (
       <code>
        push
       </code>
       ,
       <code>
        peek
       </code>
       ,
       <code>
        pop
       </code>
       , and
       <code>
        empty
       </code>
       ).
      </p>
      <p>
       Implement the
       <code>
        MyQueue
       </code>
       class:
      </p>
      <ul>
       <li>
        <code>
         void push(int x)
        </code>
        Pushes element x to the back of the queue.
       </li>
       <li>
        <code>
         int pop()
        </code>
        Removes the element from the front of the queue and returns it.
       </li>
       <li>
        <code>
         int peek()
        </code>
        Returns the element at the front of the queue.
       </li>
       <li>
        <code>
         boolean empty()
        </code>
        Returns
        <code>
         true
        </code>
        if the queue is empty,
        <code>
         false
        </code>
        otherwise.
       </li>
      </ul>
      <p>
       <strong>
        Notes:
       </strong>
      </p>
      <ul>
       <li>
        You must use
        <strong>
         only
        </strong>
        standard operations of a stack, which means only
        <code>
         push to top
        </code>
        ,
        <code>
         peek/pop from top
        </code>
        ,
        <code>
         size
        </code>
        , and
        <code>
         is empty
        </code>
        operations are valid.
       </li>
       <li>
        Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input</strong>
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
<strong>Output</strong>
[null, null, null, 1, 1, false]

<strong>Explanation</strong>
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= x &lt;= 9
        </code>
       </li>
       <li>
        At most
        <code>
         100
        </code>
        calls will be made to
        <code>
         push
        </code>
        ,
        <code>
         pop
        </code>
        ,
        <code>
         peek
        </code>
        , and
        <code>
         empty
        </code>
        .
       </li>
       <li>
        All the calls to
        <code>
         pop
        </code>
        and
        <code>
         peek
        </code>
        are valid.
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong>
        Follow-up:
       </strong>
       Can you implement the queue such that each operation is
       <strong>
        <a href="solution-232.html" target="_blank">
         amortized
        </a>
       </strong>
       <code>
        O(1)
       </code>
       time complexity? In other words, performing
       <code>
        n
       </code>
       operations will take overall
       <code>
        O(n)
       </code>
       time even if one of those operations may take longer.
      </p>
      <h1 id="algorithm">
       Algorithm
      </h1>
      <p>
       As long as the element is inserted from the front every time, for example, if a queue is
       <code class="language-plaintext highlighter-rouge">
        1, 2, 3, 4
       </code>
       , then we save it in the stack as
       <code class="language-plaintext highlighter-rouge">
        4, 3, 2, 1
       </code>
       , and then return to the top element 1, also It is the first element of the queue.
      </p>
      <p>
       The
       <code class="language-plaintext highlighter-rouge">
        difficulty
       </code>
       of this question is the push function. We need an auxiliary stack tmp, and store the elements of
       <code class="language-plaintext highlighter-rouge">
        s
       </code>
       into tmp in reverse order. At this time, add a new element
       <code class="language-plaintext highlighter-rouge">
        x
       </code>
       , and then store the elements in tmp back. This is the order we want , The other three operations also directly call stack operations.
      </p>
      <p>
       To optimize above, because every time you push, you have to flip both stacks,
      </p>
      <p>
       So, have stacks
       <code class="language-plaintext highlighter-rouge">
        stk1
       </code>
       and
       <code class="language-plaintext highlighter-rouge">
        stk2
       </code>
       , the new pushed elements are cached in
       <code class="language-plaintext highlighter-rouge">
        stk1
       </code>
       first, and all elements in
       <code class="language-plaintext highlighter-rouge">
        stk1
       </code>
       are moved to
       <code class="language-plaintext highlighter-rouge">
        stk2
       </code>
       only when the operations are pop and peek, which
       <strong>
        improves efficiency
       </strong>
       .
      </p>
      <h1 id="code">
       Code
      </h1>
      <ul class="uk-tab" data-uk-switcher="{connect:'#ce8bc9f9-d4ff-4870-86b6-1deb19df3bcc'}">
       <li class="uk-active">
        <a href="solution-232.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-232.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-232.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-232.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-232.html">
         TypeScript
        </a>
       </li>
       <li>
        <a href="solution-232.html">
         RenderScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="ce8bc9f9-d4ff-4870-86b6-1deb19df3bcc">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Implement_Queue_using_Stacks</span> <span class="o">{</span>
    <span class="kd">class</span> <span class="nc">MyQueue</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack1</span><span class="o">;</span>
        <span class="kd">private</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack2</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">MyQueue</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">stack1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
            <span class="k">this</span><span class="o">.</span><span class="na">stack2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="o">}</span>
        <span class="c1">// Push element x to the back of queue.</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stack1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Removes the element from in front of queue.</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">stack2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">stack2</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span> <span class="c1">// stack is queue-order, queue-head at this-stack-top</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">while</span> <span class="o">(!</span><span class="n">stack1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">stack2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">stack1</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="n">stack2</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Get the front element.</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">peek</span><span class="o">()</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">stack2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">stack2</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">while</span> <span class="o">(!</span><span class="n">stack1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">stack2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">stack1</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
                <span class="o">}</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">stack2</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Return whether the queue is empty.</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">empty</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">stack1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">stack2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="err">############</span>

<span class="kd">class</span> <span class="nc">MyQueue</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stk1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
    <span class="kd">private</span> <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stk2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="nf">MyQueue</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">stk1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">move</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">stk2</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">peek</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">move</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">stk2</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">empty</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">stk1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">stk2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">stk2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">stk1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">stk2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">stk1</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1">// OJ: https://leetcode.com/problems/implement-queue-using-stacks</span>
<span class="c1">// Time: O(1) amortized.</span>
<span class="c1">// Space: O(1)</span>
<span class="k">class</span> <span class="nc">MyQueue</span> <span class="p">{</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">MyQueue</span><span class="p">()</span> <span class="p">{}</span>
    
    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">in</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">peek</span><span class="p">();</span>
        <span class="n">out</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">peek</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">out</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">out</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
                <span class="n">in</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">in</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">out</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-python highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">MyQueue</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stk1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stk2</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># reversed order
</span>
    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stk1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">move</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">stk2</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">move</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">stk2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">stk1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">stk2</span>

    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">stk2</span><span class="p">:</span> <span class="c1"># only when skt2 is empty
</span>            <span class="k">while</span> <span class="bp">self</span><span class="p">.</span><span class="n">stk1</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">stk2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">stk1</span><span class="p">.</span><span class="n">pop</span><span class="p">())</span>


<span class="c1"># Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
</span>
<span class="c1">############
</span>
<span class="k">class</span> <span class="nc">MyQueue</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">sk</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">rsk</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># reversed
</span>
    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">sk</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">peek</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">rsk</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">rsk</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">rsk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">self</span><span class="p">.</span><span class="n">sk</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">rsk</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">sk</span><span class="p">.</span><span class="n">pop</span><span class="p">())</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">rsk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        

    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">sk</span> <span class="ow">or</span> <span class="bp">self</span><span class="p">.</span><span class="n">rsk</span><span class="p">)</span>
        


<span class="c1"># Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
</span></code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">type</span> <span class="n">MyQueue</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">stk1</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="n">stk2</span> <span class="p">[]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Constructor</span><span class="p">()</span> <span class="n">MyQueue</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">MyQueue</span><span class="p">{[]</span><span class="kt">int</span><span class="p">{},</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">MyQueue</span><span class="p">)</span> <span class="n">Push</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">this</span><span class="o">.</span><span class="n">stk1</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">stk1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">MyQueue</span><span class="p">)</span> <span class="n">Pop</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">this</span><span class="o">.</span><span class="n">move</span><span class="p">()</span>
	<span class="n">ans</span> <span class="o">:=</span> <span class="n">this</span><span class="o">.</span><span class="n">stk2</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">stk2</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
	<span class="n">this</span><span class="o">.</span><span class="n">stk2</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">stk2</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">stk2</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">ans</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">MyQueue</span><span class="p">)</span> <span class="n">Peek</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">this</span><span class="o">.</span><span class="n">move</span><span class="p">()</span>
	<span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">stk2</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">stk2</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">MyQueue</span><span class="p">)</span> <span class="n">Empty</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">stk1</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">stk2</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">MyQueue</span><span class="p">)</span> <span class="n">move</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">stk2</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">stk1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">this</span><span class="o">.</span><span class="n">stk2</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">stk2</span><span class="p">,</span> <span class="n">this</span><span class="o">.</span><span class="n">stk1</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">stk1</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">])</span>
			<span class="n">this</span><span class="o">.</span><span class="n">stk1</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">stk1</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">stk1</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">/**
 * Your MyQueue object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(x);
 * param_2 := obj.Pop();
 * param_3 := obj.Peek();
 * param_4 := obj.Empty();
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyQueue</span> <span class="p">{</span>
    <span class="nl">stk1</span><span class="p">:</span> <span class="kr">number</span><span class="p">[];</span>
    <span class="nl">stk2</span><span class="p">:</span> <span class="kr">number</span><span class="p">[];</span>

    <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">stk1</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">stk2</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="p">}</span>

    <span class="nx">push</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">stk1</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">pop</span><span class="p">():</span> <span class="kr">number</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">move</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">stk2</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="nx">peek</span><span class="p">():</span> <span class="kr">number</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">move</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">stk2</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">stk2</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="nx">empty</span><span class="p">():</span> <span class="nx">boolean</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">stk1</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">stk2</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">move</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">stk2</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">stk1</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">stk2</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">stk1</span><span class="p">.</span><span class="nx">pop</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-rs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">struct</span> <span class="n">MyQueue</span> <span class="p">{</span>
    <span class="n">in_stack</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">out_stack</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>


<span class="cd">/**
 * `&amp;self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&amp;mut self` instead.
 */</span>
<span class="k">impl</span> <span class="n">MyQueue</span> <span class="p">{</span>

    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">in_stack</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[],</span>
            <span class="n">out_stack</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[],</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.in_stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">pop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.out_stack</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.fill_out</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="py">.out_stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">peek</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.out_stack</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.fill_out</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="o">*</span><span class="k">self</span><span class="py">.out_stack</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">empty</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.in_stack</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.out_stack</span><span class="nf">.is_empty</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">fill_out</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">){</span>
        <span class="k">let</span> <span class="n">MyQueue</span> <span class="p">{</span> <span class="n">in_stack</span><span class="p">,</span> <span class="n">out_stack</span> <span class="p">}</span> <span class="o">=</span> <span class="k">self</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">out_stack</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">while</span> <span class="o">!</span><span class="n">in_stack</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">out_stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">in_stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/**
 * Your MyQueue object will be instantiated and called as such:
 * let obj = MyQueue::new();
 * obj.push(x);
 * let ret_2: i32 = obj.pop();
 * let ret_3: i32 = obj.peek();
 * let ret_4: bool = obj.empty();
 */</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-232.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
