<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-2925.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-2925.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>2925 - Maximum Score After Applying Operations on a Tree</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 2925. Maximum Score After Applying Operations on a Tree Description There is an undirected tree with n nodes labeled from 0 to n - 1, and rooted at node 0. You are given&amp;nbsp;a 2D integer array edges of length n - 1, where edges[i] =...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-2925.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-2925.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-2925.html" rel="stylesheet"/>
   <link href="solution-2925.html" rel="stylesheet"/>
   <link href="solution-2925.html" rel="stylesheet"/>
   <link href="solution-2925.html" rel="stylesheet"/>
   <link href="solution-2925.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="2925 - Maximum Score After Applying Operations on a Tree" property="og:title"/>
   <meta content="Leetcode 2925. Maximum Score After Applying Operations on a Tree Description There is an undirected tree with n nodes labeled from 0 to n - 1, and rooted at node 0. You are given&amp;nbsp;a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given a 0-indexed integer array values of length n, where values[i] is the value associated with the ith node. You start with a score of 0. In one operation, you can: Pick any node i. Add values[i] to your score. Set values[i] to 0. A tree is healthy if the sum of values on the path from the root to any leaf node is different than zero. Return the maximum score you can obtain after performing these operations on the tree any number of times so that it remains healthy. &amp;nbsp; Example 1: Input: edges = [[0,1],[0,2],[0,3],[2,4],[4,5]], values = [5,2,5,2,1,1] Output: 11 Explanation: We can choose nodes 1, 2, 3, 4, and 5. The value of the root is non-zero. Hence, the sum of values on the path from the root to any leaf is different than zero. Therefore, the tree is healthy and the score is values[1] + values[2] + values[3] + values[4] + values[5] = 11. It can be shown that 11 is the maximum score obtainable after any number of operations on the tree. Example 2: Input: edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [20,10,9,7,4,3,5] Output: 40 Explanation: We can choose nodes 0, 2, 3, and 4. - The sum of values on the path from 0 to 4 is equal to 10. - The sum of values on the path from 0 to 3 is equal to 10. - The sum of values on the path from 0 to 5 is equal to 3. - The sum of values on the path from 0 to 6 is equal to 5. Therefore, the tree is healthy and the score is values[0] + values[2] + values[3] + values[4] = 40. It can be shown that 40 is the maximum score obtainable after any number of operations on the tree. &amp;nbsp; Constraints: 2 &amp;lt;= n &amp;lt;= 2 * 104 edges.length == n - 1 edges[i].length == 2 0 &amp;lt;= ai, bi &amp;lt; n values.length == n 1 &amp;lt;= values[i] &amp;lt;= 109 The input is generated such that edges represents a valid tree. Solutions Solution 1: Tree DP The problem is actually asking us to select some nodes from all nodes of the tree so that the sum of these nodesâ values is maximized, and there is one node on each path from the root node to the leaf node that is not selected. We can use the method of tree DP to solve this problem. We design a function $dfs(i, fa)$, where $i$ represents the current node with node $i$ as the root of the subtree, and $fa$ represents the parent node..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2023-12-03T00:00:00-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2023-12-03-2925-Maximum-Score-After-Applying-Operations-on-a-Tree/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-2925.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="2925 - Maximum Score After Applying Operations on a Tree" property="twitter:title"/>
   <meta content="Leetcode 2925. Maximum Score After Applying Operations on a Tree Description There is an undirected tree with n nodes labeled from 0 to n - 1, and rooted at node 0. You are given&amp;nbsp;a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given a 0-indexed integer array values of length n, where values[i] is the value associated with the ith node. You start with a score of 0. In one operation, you can: Pick any node i. Add values[i] to your score. Set values[i] to 0. A tree is healthy if the sum of values on the path from the root to any leaf node is different than zero. Return the maximum score you can obtain after performing these operations on the tree any number of times so that it remains healthy. &amp;nbsp; Example 1: Input: edges = [[0,1],[0,2],[0,3],[2,4],[4,5]], values = [5,2,5,2,1,1] Output: 11 Explanation: We can choose nodes 1, 2, 3, 4, and 5. The value of the root is non-zero. Hence, the sum of values on the path from the root to any leaf is different than zero. Therefore, the tree is healthy and the score is values[1] + values[2] + values[3] + values[4] + values[5] = 11. It can be shown that 11 is the maximum score obtainable after any number of operations on the tree. Example 2: Input: edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [20,10,9,7,4,3,5] Output: 40 Explanation: We can choose nodes 0, 2, 3, and 4. - The sum of values on the path from 0 to 4 is equal to 10. - The sum of values on the path from 0 to 3 is equal to 10. - The sum of values on the path from 0 to 5 is equal to 3. - The sum of values on the path from 0 to 6 is equal to 5. Therefore, the tree is healthy and the score is values[0] + values[2] + values[3] + values[4] = 40. It can be shown that 40 is the maximum score obtainable after any number of operations on the tree. &amp;nbsp; Constraints: 2 &amp;lt;= n &amp;lt;= 2 * 104 edges.length == n - 1 edges[i].length == 2 0 &amp;lt;= ai, bi &amp;lt; n values.length == n 1 &amp;lt;= values[i] &amp;lt;= 109 The input is generated such that edges represents a valid tree. Solutions Solution 1: Tree DP The problem is actually asking us to select some nodes from all nodes of the tree so that the sum of these nodesâ values is maximized, and there is one node on each path from the root node to the leaf node that is not selected. We can use the method of tree DP to solve this problem. We design a function $dfs(i, fa)$, where $i$ represents the current node with node $i$ as the root of the subtree, and $fa$ represents the parent node..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    2925 - Maximum Score After Applying Operations on a Tree | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="2925 - Maximum Score After Applying Operations on a Tree" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-2925.html" rel="canonical">
          <meta content="https://leetcode.ca/2023-12-03-2925-Maximum-Score-After-Applying-Operations-on-a-Tree/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2023-12-03T00:00:00-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"2925 - Maximum Score After Applying Operations on a Tree","dateModified":"2023-12-03T00:00:00-08:00","datePublished":"2023-12-03T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2023-12-03-2925-Maximum-Score-After-Applying-Operations-on-a-Tree/"},"url":"https://leetcode.ca/2023-12-03-2925-Maximum-Score-After-Applying-Operations-on-a-Tree/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="2925-maximum-score-after-applying-operations-on-a-tree">
       <a href="solution-2925.html">
        2925. Maximum Score After Applying Operations on a Tree
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       There is an undirected tree with
       <code>
        n
       </code>
       nodes labeled from
       <code>
        0
       </code>
       to
       <code>
        n - 1
       </code>
       , and rooted at node
       <code>
        0
       </code>
       . You are given a 2D integer array
       <code>
        edges
       </code>
       of length
       <code>
        n - 1
       </code>
       , where
       <code>
        edges[i] = [a
        <sub>
         i
        </sub>
        , b
        <sub>
         i
        </sub>
        ]
       </code>
       indicates that there is an edge between nodes
       <code>
        a
        <sub>
         i
        </sub>
       </code>
       and
       <code>
        b
        <sub>
         i
        </sub>
       </code>
       in the tree.
      </p>
      <p>
       You are also given a
       <strong>
        0-indexed
       </strong>
       integer array
       <code>
        values
       </code>
       of length
       <code>
        n
       </code>
       , where
       <code>
        values[i]
       </code>
       is the
       <strong>
        value
       </strong>
       associated with the
       <code>
        i
        <sup>
         th
        </sup>
       </code>
       node.
      </p>
      <p>
       You start with a score of
       <code>
        0
       </code>
       . In one operation, you can:
      </p>
      <ul>
       <li>
        Pick any node
        <code>
         i
        </code>
        .
       </li>
       <li>
        Add
        <code>
         values[i]
        </code>
        to your score.
       </li>
       <li>
        Set
        <code>
         values[i]
        </code>
        to
        <code>
         0
        </code>
        .
       </li>
      </ul>
      <p>
       A tree is
       <strong>
        healthy
       </strong>
       if the sum of values on the path from the root to any leaf node is different than zero.
      </p>
      <p>
       Return
       <em>
        the
        <strong>
         maximum score
        </strong>
        you can obtain after performing these operations on the tree any number of times so that it remains
        <strong>
         healthy
        </strong>
        .
       </em>
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2900-2999/2925.Maximum%20Score%20After%20Applying%20Operations%20on%20a%20Tree/images/graph-13-1.png" style="width: 515px; height: 443px;"/>
      </p>
      <pre>
<strong>Input:</strong> edges = [[0,1],[0,2],[0,3],[2,4],[4,5]], values = [5,2,5,2,1,1]
<strong>Output:</strong> 11
<strong>Explanation:</strong> We can choose nodes 1, 2, 3, 4, and 5. The value of the root is non-zero. Hence, the sum of values on the path from the root to any leaf is different than zero. Therefore, the tree is healthy and the score is values[1] + values[2] + values[3] + values[4] + values[5] = 11.
It can be shown that 11 is the maximum score obtainable after any number of operations on the tree.
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2900-2999/2925.Maximum%20Score%20After%20Applying%20Operations%20on%20a%20Tree/images/graph-14-2.png" style="width: 522px; height: 245px;"/>
      </p>
      <pre>
<strong>Input:</strong> edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [20,10,9,7,4,3,5]
<strong>Output:</strong> 40
<strong>Explanation:</strong> We can choose nodes 0, 2, 3, and 4.
- The sum of values on the path from 0 to 4 is equal to 10.
- The sum of values on the path from 0 to 3 is equal to 10.
- The sum of values on the path from 0 to 5 is equal to 3.
- The sum of values on the path from 0 to 6 is equal to 5.
Therefore, the tree is healthy and the score is values[0] + values[2] + values[3] + values[4] = 40.
It can be shown that 40 is the maximum score obtainable after any number of operations on the tree.
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         2 &lt;= n &lt;= 2 * 10
         <sup>
          4
         </sup>
        </code>
       </li>
       <li>
        <code>
         edges.length == n - 1
        </code>
       </li>
       <li>
        <code>
         edges[i].length == 2
        </code>
       </li>
       <li>
        <code>
         0 &lt;= a
         <sub>
          i
         </sub>
         , b
         <sub>
          i
         </sub>
         &lt; n
        </code>
       </li>
       <li>
        <code>
         values.length == n
        </code>
       </li>
       <li>
        <code>
         1 &lt;= values[i] &lt;= 10
         <sup>
          9
         </sup>
        </code>
       </li>
       <li>
        The input is generated such that
        <code>
         edges
        </code>
        represents a valid tree.
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       <strong>
        Solution 1: Tree DP
       </strong>
      </p>
      <p>
       The problem is actually asking us to select some nodes from all nodes of the tree so that the sum of these nodesâ values is maximized, and there is one node on each path from the root node to the leaf node that is not selected.
      </p>
      <p>
       We can use the method of tree DP to solve this problem.
      </p>
      <p>
       We design a function $dfs(i, fa)$, where $i$ represents the current node with node $i$ as the root of the subtree, and $fa$ represents the parent node of $i$. The function returns an array of length $2$, where $[0]$ represents the sum of the values of all nodes in the subtree, and $[1]$ represents the maximum value of the subtree satisfying that there is one node not selected on each path.
      </p>
      <p>
       The value of $[0]$ can be obtained directly by DFS accumulating the values of each node, while the value of $[1]$ needs to consider two situations, namely whether node $i$ is selected. If it is selected, then each subtree of node $i$ must satisfy that there is one node not selected on each path; if it is not selected, then all nodes of each subtree of node $i$ can be selected. We take the maximum of these two situations.
      </p>
      <p>
       It should be noted that the value of $[1]$ of the leaf node is $0$, because the leaf node has no subtree, so there is no need to consider the situation where there is one node not selected on each path.
      </p>
      <p>
       The answer is $dfs(0, -1)[1]$.
      </p>
      <p>
       The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#862dae8a-bd99-4f59-a1ca-89eb9105ef0e'}">
       <li class="uk-active">
        <a href="solution-2925.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-2925.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-2925.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-2925.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-2925.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="862dae8a-bd99-4f59-a1ca-89eb9105ef0e">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">g</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">values</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">maximumScoreAfterOperations</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">List</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">this</span><span class="o">.</span><span class="na">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">;</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">setAll</span><span class="o">(</span><span class="n">g</span><span class="o">,</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">var</span> <span class="n">e</span> <span class="o">:</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">e</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="n">g</span><span class="o">[</span><span class="n">a</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
            <span class="n">g</span><span class="o">[</span><span class="n">b</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">)[</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">long</span><span class="o">[]</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fa</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">leaf</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">:</span> <span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">fa</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">leaf</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="kt">var</span> <span class="n">t</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
                <span class="n">a</span> <span class="o">+=</span> <span class="n">t</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
                <span class="n">b</span> <span class="o">+=</span> <span class="n">t</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">leaf</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[]</span> <span class="o">{</span><span class="n">values</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span><span class="o">};</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[]</span> <span class="o">{</span><span class="n">values</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">a</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">values</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">)};</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">maximumScoreAfterOperations</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">e</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
            <span class="n">g</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">using</span> <span class="n">ll</span> <span class="o">=</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">;</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">ll</span><span class="p">,</span> <span class="n">ll</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fa</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">ll</span><span class="p">,</span> <span class="n">ll</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">ll</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="kt">bool</span> <span class="n">leaf</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">fa</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">auto</span> <span class="p">[</span><span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
                    <span class="n">a</span> <span class="o">+=</span> <span class="n">aa</span><span class="p">;</span>
                    <span class="n">b</span> <span class="o">+=</span> <span class="n">bb</span><span class="p">;</span>
                    <span class="n">leaf</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0LL</span><span class="p">};</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)};</span>
        <span class="p">};</span>
        <span class="k">auto</span> <span class="p">[</span><span class="n">_</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maximumScoreAfterOperations</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">fa</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">leaf</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">fa</span><span class="p">:</span>
                    <span class="n">leaf</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="n">aa</span><span class="p">,</span> <span class="n">bb</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">a</span> <span class="o">+=</span> <span class="n">aa</span>
                    <span class="n">b</span> <span class="o">+=</span> <span class="n">bb</span>
            <span class="k">if</span> <span class="n">leaf</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

        <span class="n">g</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">g</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">maximumScoreAfterOperations</span><span class="p">(</span><span class="n">edges</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="n">values</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="n">g</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">edges</span> <span class="p">{</span>
		<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">e</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="m">1</span><span class="p">]</span>
		<span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span>
		<span class="n">g</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">a</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">int64</span><span class="p">)</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">fa</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="m">0</span><span class="p">),</span> <span class="kt">int64</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
		<span class="n">leaf</span> <span class="o">:=</span> <span class="no">true</span>
		<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">j</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">fa</span> <span class="p">{</span>
				<span class="n">leaf</span> <span class="o">=</span> <span class="no">false</span>
				<span class="n">aa</span><span class="p">,</span> <span class="n">bb</span> <span class="o">:=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
				<span class="n">a</span> <span class="o">+=</span> <span class="n">aa</span>
				<span class="n">b</span> <span class="o">+=</span> <span class="n">bb</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">leaf</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kt">int64</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="kt">int64</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kt">int64</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">a</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="kt">int64</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">_</span><span class="p">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">dfs</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="o">-</span><span class="m">1</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">b</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">function</span> <span class="nx">maximumScoreAfterOperations</span><span class="p">(</span><span class="nx">edges</span><span class="p">:</span> <span class="kr">number</span><span class="p">[][],</span> <span class="nx">values</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">g</span><span class="p">:</span> <span class="kr">number</span><span class="p">[][]</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">({</span> <span class="na">length</span><span class="p">:</span> <span class="nx">values</span><span class="p">.</span><span class="nx">length</span> <span class="p">},</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">[]);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="k">of</span> <span class="nx">edges</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">g</span><span class="p">[</span><span class="nx">a</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
        <span class="nx">g</span><span class="p">[</span><span class="nx">b</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">i</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">fa</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">number</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>
        <span class="kd">let</span> <span class="nx">leaf</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">j</span> <span class="k">of</span> <span class="nx">g</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">j</span> <span class="o">!==</span> <span class="nx">fa</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">const</span> <span class="p">[</span><span class="nx">aa</span><span class="p">,</span> <span class="nx">bb</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
                <span class="nx">a</span> <span class="o">+=</span> <span class="nx">aa</span><span class="p">;</span>
                <span class="nx">b</span> <span class="o">+=</span> <span class="nx">bb</span><span class="p">;</span>
                <span class="nx">leaf</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">leaf</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">[</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">[</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">a</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">)];</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-2925.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
