<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-352.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-352.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>352 - Data Stream as Disjoint Intervals</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 352. Data Stream as Disjoint Intervals Description Given a data stream input of non-negative integers a1, a2, ..., an, summarize the numbers seen so far as a list of disjoint intervals. Implement the SummaryRanges class: SummaryRanges() Initializes the object with an empty stream. void addNum(int...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-352.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-352.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-352.html" rel="stylesheet"/>
   <link href="solution-352.html" rel="stylesheet"/>
   <link href="solution-352.html" rel="stylesheet"/>
   <link href="solution-352.html" rel="stylesheet"/>
   <link href="solution-352.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="352 - Data Stream as Disjoint Intervals" property="og:title"/>
   <meta content="Leetcode 352. Data Stream as Disjoint Intervals Description Given a data stream input of non-negative integers a1, a2, ..., an, summarize the numbers seen so far as a list of disjoint intervals. Implement the SummaryRanges class: SummaryRanges() Initializes the object with an empty stream. void addNum(int value) Adds the integer value to the stream. int[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [starti, endi]. The answer should be sorted by starti. &amp;nbsp; Example 1: Input [&amp;quot;SummaryRanges&amp;quot;, &amp;quot;addNum&amp;quot;, &amp;quot;getIntervals&amp;quot;, &amp;quot;addNum&amp;quot;, &amp;quot;getIntervals&amp;quot;, &amp;quot;addNum&amp;quot;, &amp;quot;getIntervals&amp;quot;, &amp;quot;addNum&amp;quot;, &amp;quot;getIntervals&amp;quot;, &amp;quot;addNum&amp;quot;, &amp;quot;getIntervals&amp;quot;] [[], [1], [], [3], [], [7], [], [2], [], [6], []] Output [null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]] Explanation SummaryRanges summaryRanges = new SummaryRanges(); summaryRanges.addNum(1); // arr = [1] summaryRanges.getIntervals(); // return [[1, 1]] summaryRanges.addNum(3); // arr = [1, 3] summaryRanges.getIntervals(); // return [[1, 1], [3, 3]] summaryRanges.addNum(7); // arr = [1, 3, 7] summaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]] summaryRanges.addNum(2); // arr = [1, 2, 3, 7] summaryRanges.getIntervals(); // return [[1, 3], [7, 7]] summaryRanges.addNum(6); // arr = [1, 2, 3, 6, 7] summaryRanges.getIntervals(); // return [[1, 3], [6, 7]] &amp;nbsp; Constraints: 0 &amp;lt;= value &amp;lt;= 104 At most 3 * 104 calls will be made to addNum and getIntervals. At most 102&amp;nbsp;calls will be made to&amp;nbsp;getIntervals. &amp;nbsp; Follow up: What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream? Solutions Use TreeMap To get previous range last index, and next range first index. Then compare and decide if merge or not. Integer l = tree.lowerKey(val); // @note: Returns the greatest key strictly less than the given key Integer h = tree.higherKey(val); // @note: Returns the least key strictly greater than the given key Interval start/end check Every time a new number val comes in, a new interval [val, val] is generated, and an empty interval array res is created, and a variable cur is used to store the position of the new interval. Traverse the existing interval array intervals, for each traversed current interval interval, If the end position of the interval to be added plus 1 is smaller than the start position of the current interval, indicating that the two are not connected, add the current interval to res. Otherwise, when the start position of the interval to be added is greater than the end position of the current position plus 1, it means that there is no intersection between the two, and the current interval can be added to res, But at this time, cur should be incremented by 1 because the position to be added to the interval is behind the current interval. Otherwise, the two will overlap and need to be merged, At this time, use the smaller of the two starting positions to update the starting position..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-11-16T00:00:00-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-11-16-352-Data-Stream-as-Disjoint-Intervals/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-352.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="352 - Data Stream as Disjoint Intervals" property="twitter:title"/>
   <meta content="Leetcode 352. Data Stream as Disjoint Intervals Description Given a data stream input of non-negative integers a1, a2, ..., an, summarize the numbers seen so far as a list of disjoint intervals. Implement the SummaryRanges class: SummaryRanges() Initializes the object with an empty stream. void addNum(int value) Adds the integer value to the stream. int[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [starti, endi]. The answer should be sorted by starti. &amp;nbsp; Example 1: Input [&amp;quot;SummaryRanges&amp;quot;, &amp;quot;addNum&amp;quot;, &amp;quot;getIntervals&amp;quot;, &amp;quot;addNum&amp;quot;, &amp;quot;getIntervals&amp;quot;, &amp;quot;addNum&amp;quot;, &amp;quot;getIntervals&amp;quot;, &amp;quot;addNum&amp;quot;, &amp;quot;getIntervals&amp;quot;, &amp;quot;addNum&amp;quot;, &amp;quot;getIntervals&amp;quot;] [[], [1], [], [3], [], [7], [], [2], [], [6], []] Output [null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]] Explanation SummaryRanges summaryRanges = new SummaryRanges(); summaryRanges.addNum(1); // arr = [1] summaryRanges.getIntervals(); // return [[1, 1]] summaryRanges.addNum(3); // arr = [1, 3] summaryRanges.getIntervals(); // return [[1, 1], [3, 3]] summaryRanges.addNum(7); // arr = [1, 3, 7] summaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]] summaryRanges.addNum(2); // arr = [1, 2, 3, 7] summaryRanges.getIntervals(); // return [[1, 3], [7, 7]] summaryRanges.addNum(6); // arr = [1, 2, 3, 6, 7] summaryRanges.getIntervals(); // return [[1, 3], [6, 7]] &amp;nbsp; Constraints: 0 &amp;lt;= value &amp;lt;= 104 At most 3 * 104 calls will be made to addNum and getIntervals. At most 102&amp;nbsp;calls will be made to&amp;nbsp;getIntervals. &amp;nbsp; Follow up: What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream? Solutions Use TreeMap To get previous range last index, and next range first index. Then compare and decide if merge or not. Integer l = tree.lowerKey(val); // @note: Returns the greatest key strictly less than the given key Integer h = tree.higherKey(val); // @note: Returns the least key strictly greater than the given key Interval start/end check Every time a new number val comes in, a new interval [val, val] is generated, and an empty interval array res is created, and a variable cur is used to store the position of the new interval. Traverse the existing interval array intervals, for each traversed current interval interval, If the end position of the interval to be added plus 1 is smaller than the start position of the current interval, indicating that the two are not connected, add the current interval to res. Otherwise, when the start position of the interval to be added is greater than the end position of the current position plus 1, it means that there is no intersection between the two, and the current interval can be added to res, But at this time, cur should be incremented by 1 because the position to be added to the interval is behind the current interval. Otherwise, the two will overlap and need to be merged, At this time, use the smaller of the two starting positions to update the starting position..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    352 - Data Stream as Disjoint Intervals | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="352 - Data Stream as Disjoint Intervals" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-352.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-11-16-352-Data-Stream-as-Disjoint-Intervals/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-11-16T00:00:00-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"352 - Data Stream as Disjoint Intervals","dateModified":"2016-11-16T00:00:00-08:00","datePublished":"2016-11-16T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-11-16-352-Data-Stream-as-Disjoint-Intervals/"},"url":"https://leetcode.ca/2016-11-16-352-Data-Stream-as-Disjoint-Intervals/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="352-data-stream-as-disjoint-intervals">
       <a href="solution-352.html">
        352. Data Stream as Disjoint Intervals
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given a data stream input of non-negative integers
       <code>
        a
        <sub>
         1
        </sub>
        , a
        <sub>
         2
        </sub>
        , ..., a
        <sub>
         n
        </sub>
       </code>
       , summarize the numbers seen so far as a list of disjoint intervals.
      </p>
      <p>
       Implement the
       <code>
        SummaryRanges
       </code>
       class:
      </p>
      <ul>
       <li>
        <code>
         SummaryRanges()
        </code>
        Initializes the object with an empty stream.
       </li>
       <li>
        <code>
         void addNum(int value)
        </code>
        Adds the integer
        <code>
         value
        </code>
        to the stream.
       </li>
       <li>
        <code>
         int[][] getIntervals()
        </code>
        Returns a summary of the integers in the stream currently as a list of disjoint intervals
        <code>
         [start
         <sub>
          i
         </sub>
         , end
         <sub>
          i
         </sub>
         ]
        </code>
        . The answer should be sorted by
        <code>
         start
         <sub>
          i
         </sub>
        </code>
        .
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input</strong>
["SummaryRanges", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals"]
[[], [1], [], [3], [], [7], [], [2], [], [6], []]
<strong>Output</strong>
[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]

<strong>Explanation</strong>
SummaryRanges summaryRanges = new SummaryRanges();
summaryRanges.addNum(1);      // arr = [1]
summaryRanges.getIntervals(); // return [[1, 1]]
summaryRanges.addNum(3);      // arr = [1, 3]
summaryRanges.getIntervals(); // return [[1, 1], [3, 3]]
summaryRanges.addNum(7);      // arr = [1, 3, 7]
summaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]
summaryRanges.addNum(2);      // arr = [1, 2, 3, 7]
summaryRanges.getIntervals(); // return [[1, 3], [7, 7]]
summaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]
summaryRanges.getIntervals(); // return [[1, 3], [6, 7]]
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         0 &lt;= value &lt;= 10
         <sup>
          4
         </sup>
        </code>
       </li>
       <li>
        At most
        <code>
         3 * 10
         <sup>
          4
         </sup>
        </code>
        calls will be made to
        <code>
         addNum
        </code>
        and
        <code>
         getIntervals
        </code>
        .
       </li>
       <li>
        At most
        <code>
         10
         <sup>
          2
         </sup>
        </code>
        calls will be made to
        <code>
         getIntervals
        </code>
        .
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong>
        Follow up:
       </strong>
       What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?
      </p>
      <h2 id="solutions">
       Solutions
      </h2>
      <h3 id="use-treemap">
       Use TreeMap
      </h3>
      <p>
       To get previous range last index, and next range first index. Then compare and decide if merge or not.
      </p>
      <div class="language-plaintext highlighter-rouge">
       <div class="highlight">
        <pre class="highlight"><code>Integer l = tree.lowerKey(val);  // @note: Returns the greatest key strictly less than the given key

Integer h = tree.higherKey(val); // @note: Returns the least key strictly greater than the given key
</code></pre>
       </div>
      </div>
      <h3 id="interval-startend-check">
       Interval start/end check
      </h3>
      <p>
       Every time a new number
       <code class="language-plaintext highlighter-rouge">
        val
       </code>
       comes in, a new interval
       <code class="language-plaintext highlighter-rouge">
        [val, val]
       </code>
       is generated, and an empty interval array
       <code class="language-plaintext highlighter-rouge">
        res
       </code>
       is created, and a variable cur is used to store the position of the new interval.
      </p>
      <p>
       Traverse the existing interval array intervals, for each traversed current interval interval,
      </p>
      <ul>
       <li>
        If the end position of the interval to be added plus 1 is smaller than the start position of the current interval, indicating that the two are not connected, add the current interval to res.
       </li>
       <li>
        Otherwise, when the start position of the interval to be added is greater than the end position of the current position plus 1, it means that there is no intersection between the two, and the current interval can be added to
        <code class="language-plaintext highlighter-rouge">
         res
        </code>
        ,
        <ul>
         <li>
          But at this time, cur should be incremented by 1 because the position to be added to the interval is behind the current interval.
         </li>
        </ul>
       </li>
       <li>
        Otherwise, the two will overlap and need to be merged,
        <ul>
         <li>
          At this time, use the smaller of the two starting positions to update the starting position of the interval to be added,
         </li>
         <li>
          In the same way, use the larger of the two end positions to update the end position of the interval to be added.
         </li>
        </ul>
       </li>
      </ul>
      <p>
       Finally, the interval to be added is placed at the cur position in
       <code class="language-plaintext highlighter-rouge">
        res
       </code>
       , and then
       <code class="language-plaintext highlighter-rouge">
        res
       </code>
       is assigned to intervals
      </p>
      <h2 id="solution---more-python-filter-lambda-tricks">
       Solution - more python filter-lambda tricks
      </h2>
      <h3 id="class-initialization-__init__self">
       Class Initialization:
       <code class="language-plaintext highlighter-rouge">
        __init__(self)
       </code>
      </h3>
      <ul>
       <li>
        Initializes an empty list
        <code class="language-plaintext highlighter-rouge">
         self.intervals
        </code>
        which will store the intervals as lists of two elements
        <code class="language-plaintext highlighter-rouge">
         [start, end]
        </code>
        .
       </li>
      </ul>
      <h3 id="method-insertself-newinterval-listint">
       Method:
       <code class="language-plaintext highlighter-rouge">
        insert(self, newInterval: List[int])
       </code>
      </h3>
      <ul>
       <li>
        <strong>
         Parameters
        </strong>
        : Takes a
        <code class="language-plaintext highlighter-rouge">
         newInterval
        </code>
        represented as a list
        <code class="language-plaintext highlighter-rouge">
         [start, end]
        </code>
        .
       </li>
       <li>
        <strong>
         Functionality
        </strong>
        : Inserts
        <code class="language-plaintext highlighter-rouge">
         newInterval
        </code>
        into the existing sorted intervals (
        <code class="language-plaintext highlighter-rouge">
         self.intervals
        </code>
        ) while maintaining the order and merging overlapping or adjacent intervals.
       </li>
       <li>
        <strong>
         Implementation
        </strong>
        :
        <ul>
         <li>
          <strong>
           Empty Intervals Check
          </strong>
          : If
          <code class="language-plaintext highlighter-rouge">
           self.intervals
          </code>
          is empty,
          <code class="language-plaintext highlighter-rouge">
           newInterval
          </code>
          is directly appended to it.
         </li>
         <li>
          <strong>
           Splitting Intervals
          </strong>
          : Divides the existing intervals into two parts:
          <ul>
           <li>
            <code class="language-plaintext highlighter-rouge">
             left
            </code>
            : Intervals that end before
            <code class="language-plaintext highlighter-rouge">
             newInterval
            </code>
            starts (no overlap or adjacency).
           </li>
           <li>
            <code class="language-plaintext highlighter-rouge">
             right
            </code>
            : Intervals that start after
            <code class="language-plaintext highlighter-rouge">
             newInterval
            </code>
            ends (no overlap or adjacency).
           </li>
          </ul>
         </li>
         <li>
          <strong>
           Merging
          </strong>
          : If there are intervals that overlap with or are adjacent to
          <code class="language-plaintext highlighter-rouge">
           newInterval
          </code>
          , it finds the minimum start (
          <code class="language-plaintext highlighter-rouge">
           s
          </code>
          ) and maximum end (
          <code class="language-plaintext highlighter-rouge">
           e
          </code>
          ) among those intervals and
          <code class="language-plaintext highlighter-rouge">
           newInterval
          </code>
          to merge them into a single interval.
         </li>
         <li>
          <strong>
           Updating Intervals
          </strong>
          : Updates
          <code class="language-plaintext highlighter-rouge">
           self.intervals
          </code>
          by concatenating
          <code class="language-plaintext highlighter-rouge">
           left
          </code>
          , the merged interval
          <code class="language-plaintext highlighter-rouge">
           [s, e]
          </code>
          , and
          <code class="language-plaintext highlighter-rouge">
           right
          </code>
          .
         </li>
        </ul>
       </li>
      </ul>
      <h3 id="method-addnumself-val-int---none">
       Method:
       <code class="language-plaintext highlighter-rouge">
        addNum(self, val: int) -&gt; None
       </code>
      </h3>
      <ul>
       <li>
        A convenience method that wraps
        <code class="language-plaintext highlighter-rouge">
         insert
        </code>
        to add a single number as an interval
        <code class="language-plaintext highlighter-rouge">
         [val, val]
        </code>
        .
       </li>
      </ul>
      <h3 id="method-getintervalsself---listlistint">
       Method:
       <code class="language-plaintext highlighter-rouge">
        getIntervals(self) -&gt; List[List[int]]
       </code>
      </h3>
      <ul>
       <li>
        Simply returns the current list of intervals.
       </li>
      </ul>
      <h3 id="key-points">
       Key Points
      </h3>
      <ul>
       <li>
        <strong>
         Efficiency
        </strong>
        : The method
        <code class="language-plaintext highlighter-rouge">
         insert
        </code>
        is designed to efficiently handle the insertion and merging of intervals by using the
        <code class="language-plaintext highlighter-rouge">
         filter
        </code>
        function to separate intervals that donât need merging (
        <code class="language-plaintext highlighter-rouge">
         left
        </code>
        and
        <code class="language-plaintext highlighter-rouge">
         right
        </code>
        ) and directly merging the ones that overlap with or are adjacent to
        <code class="language-plaintext highlighter-rouge">
         newInterval
        </code>
        .
       </li>
       <li>
        <strong>
         Maintaining Order
        </strong>
        : The intervals are kept sorted by their start times, which simplifies the process of merging and searching.
       </li>
       <li>
        <strong>
         Simplicity in
         <code class="language-plaintext highlighter-rouge">
          addNum
         </code>
        </strong>
        : By treating the addition of a single number as adding a zero-length interval, the same insertion logic can be reused without duplication.
       </li>
      </ul>
      <h3 id="follow-up-what-if-there-are-lots-of-merges-and-the-number-of-disjoint-intervals-are-small-compared-to-the-data-streams-size">
       Follow up: What if there are lots of merges and the number of disjoint intervals are small compared to the data streamâs size?
      </h3>
      <ul>
       <li>
        lots of merges
        <code class="language-plaintext highlighter-rouge">
         -&gt;
        </code>
        add() cannot be too costy
       </li>
       <li>
        the number of disjoint intervals are small
        <code class="language-plaintext highlighter-rouge">
         -&gt;
        </code>
        get() can be costy
       </li>
      </ul>
      <p>
       to reduce cost of add(), use
       <code class="language-plaintext highlighter-rouge">
        O(logn)
       </code>
       for insertion of points (no merge), and maintain order
get will have to calculate the disjoint intervals on the fly (basically
       <code class="language-plaintext highlighter-rouge">
        lazy loading
       </code>
       , do a merge on
       <code class="language-plaintext highlighter-rouge">
        get()
       </code>
       trigger)
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#1f9d460e-e101-4b3a-b8f5-695c6ff78e29'}">
       <li class="uk-active">
        <a href="solution-352.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-352.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-352.html">
         Python
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="1f9d460e-e101-4b3a-b8f5-695c6ff78e29">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">SummaryRanges</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">mp</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">SummaryRanges</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addNum</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Integer</span> <span class="n">l</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="na">floorKey</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
        <span class="nc">Integer</span> <span class="n">r</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="na">ceilingKey</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">mp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">l</span><span class="o">)[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">mp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">r</span><span class="o">)[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">mp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">l</span><span class="o">)[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">r</span><span class="o">)[</span><span class="mi">1</span><span class="o">];</span>
            <span class="n">mp</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">mp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">l</span><span class="o">)[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">mp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">l</span><span class="o">)[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">val</span><span class="o">,</span> <span class="n">mp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">l</span><span class="o">)[</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">r</span><span class="o">)[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">mp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">r</span><span class="o">)[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">val</span><span class="o">,</span> <span class="n">mp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">r</span><span class="o">)[</span><span class="mi">0</span><span class="o">]);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">mp</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">val</span><span class="o">,</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">val</span><span class="o">,</span> <span class="n">val</span><span class="o">});</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">getIntervals</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">mp</span><span class="o">.</span><span class="na">size</span><span class="o">()][</span><span class="mi">2</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">range</span> <span class="o">:</span> <span class="n">mp</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">=</span> <span class="n">range</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Your SummaryRanges object will be instantiated and called as such:
 * SummaryRanges obj = new SummaryRanges();
 * obj.addNum(val);
 * int[][] param_2 = obj.getIntervals();
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">SummaryRanges</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">mp</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="n">SummaryRanges</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">addNum</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">l</span> <span class="o">=</span> <span class="n">r</span> <span class="o">==</span> <span class="n">mp</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">?</span> <span class="n">mp</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">:</span> <span class="n">prev</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="n">mp</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">!=</span> <span class="n">mp</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">l</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">mp</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="n">mp</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">l</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">mp</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">r</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">else</span>
            <span class="n">mp</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">val</span><span class="p">,</span> <span class="n">val</span><span class="p">};</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">getIntervals</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">range</span> <span class="o">:</span> <span class="n">mp</span><span class="p">)</span> <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**
 * Your SummaryRanges object will be instantiated and called as such:
 * SummaryRanges* obj = new SummaryRanges();
 * obj-&gt;addNum(val);
 * vector&lt;vector&lt;int&gt;&gt; param_2 = obj-&gt;getIntervals();
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for an interval.
# class Interval(object):
#     def __init__(self, s=0, e=0):
#         self.start = s
#         self.end = e
</span>

<span class="c1"># better and easier, manual filter() via while
# I like this one the most
</span><span class="k">class</span> <span class="nc">SummaryRanges</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">intervals</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">addNum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">new_interval</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="p">,</span> <span class="n">val</span><span class="p">]</span>
        <span class="n">merged_intervals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># before overlap part
</span>        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">intervals</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">val</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">merged_intervals</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># process overlap
</span>        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">intervals</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">val</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">new_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">new_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">new_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">merged_intervals</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_interval</span><span class="p">)</span>

        <span class="c1"># after overlap part
</span>        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">intervals</span><span class="p">):</span>
            <span class="n">merged_intervals</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># also passed OJ, instead of while loop:
</span>        <span class="c1"># merged_intervals.extend(self.intervals[i:])
</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">intervals</span> <span class="o">=</span> <span class="n">merged_intervals</span>

    <span class="k">def</span> <span class="nf">getIntervals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">intervals</span>

<span class="c1">############
</span>
<span class="k">class</span> <span class="nc">SummaryRanges</span><span class="p">:</span> <span class="c1"># passed OJ, optimized below solution
</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">intervals</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newInterval</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="s">"""
    :type intervals: List[Interval]
    :type newInterval: Interval
    :rtype: List[Interval]
    """</span>
    <span class="n">intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">intervals</span>
    <span class="c1"># print intervals
</span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">intervals</span><span class="p">:</span>
      <span class="n">intervals</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">newInterval</span><span class="p">)</span>
      <span class="k">return</span>

    <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">left</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">intervals</span><span class="p">))</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">intervals</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">!=</span> <span class="n">intervals</span><span class="p">:</span>
      <span class="n">s</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">intervals</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)][</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">)</span>
      <span class="n">e</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">intervals</span><span class="p">[</span><span class="o">~</span><span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)][</span><span class="mi">1</span><span class="p">],</span> <span class="n">e</span><span class="p">)</span>

    <span class="c1"># +1 or -1 check: included in lambda's '+1&lt;' and '-1&gt;'
</span>    <span class="bp">self</span><span class="p">.</span><span class="n">intervals</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">[</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span> <span class="p">]</span> <span class="o">+</span> <span class="n">right</span>

  <span class="k">def</span> <span class="nf">addNum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">insert</span><span class="p">([</span><span class="n">val</span><span class="p">,</span> <span class="n">val</span><span class="p">])</span>

  <span class="k">def</span> <span class="nf">getIntervals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>

    <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">intervals</span>


<span class="c1">############
</span>

<span class="k">class</span> <span class="nc">SummaryRanges</span><span class="p">:</span> <span class="c1"># above is optimized version
</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">intervals</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newInterval</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="s">"""
    :type intervals: List[Interval]
    :type newInterval: Interval
    :rtype: List[Interval]
    """</span>
    <span class="n">intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">intervals</span>
    <span class="c1"># print intervals
</span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">intervals</span><span class="p">:</span>
      <span class="n">intervals</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">newInterval</span><span class="p">)</span>
      <span class="k">return</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">left</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">intervals</span><span class="p">))</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">intervals</span><span class="p">))</span>
    <span class="c1"># print left, right, (s, e)
</span>    <span class="k">if</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">!=</span> <span class="n">intervals</span><span class="p">:</span>
      <span class="n">s</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">intervals</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)][</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">)</span>
      <span class="n">e</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">intervals</span><span class="p">[</span><span class="o">~</span><span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)][</span><span class="mi">1</span><span class="p">],</span> <span class="n">e</span><span class="p">)</span>
    <span class="n">newIntv</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span>

    <span class="c1"># merging piece is different from above solution
</span>    <span class="k">if</span> <span class="n">left</span> <span class="ow">and</span> <span class="n">left</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">s</span><span class="p">:</span>
      <span class="n">newIntv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
      <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># cut out last one, which is merged with newIntv
</span>    <span class="k">if</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">right</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">e</span><span class="p">:</span>
      <span class="n">newIntv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
      <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># cut out first one, which is merged with newIntv
</span>    <span class="bp">self</span><span class="p">.</span><span class="n">intervals</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">[</span><span class="n">newIntv</span><span class="p">]</span> <span class="o">+</span> <span class="n">right</span>

  <span class="k">def</span> <span class="nf">addNum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">insert</span><span class="p">([</span><span class="n">val</span><span class="p">,</span> <span class="n">val</span><span class="p">])</span>

  <span class="k">def</span> <span class="nf">getIntervals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>

    <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">intervals</span>

<span class="c1"># Your SummaryRanges object will be instantiated and called as such:
# obj = SummaryRanges()
# obj.addNum(val)
# param_2 = obj.getIntervals()
</span>

<span class="c1">############
</span>
<span class="s">'''
&gt;&gt;&gt; mp = SortedDict()
&gt;&gt;&gt; mp.bisect_right(3)
0


&gt;&gt;&gt; mp = SortedDict()
&gt;&gt;&gt; mp[1]=[1,1]
&gt;&gt;&gt; mp[3]=[3,3]
&gt;&gt;&gt; mp[5]=[5,5]
&gt;&gt;&gt;
&gt;&gt;&gt; mp
SortedDict({1: [1, 1], 3: [3, 3], 5: [5, 5]})
&gt;&gt;&gt; mp.bisect_right(-10)
0
&gt;&gt;&gt; mp.bisect_right(100)
3
&gt;&gt;&gt; mp.bisect_right(2)
1
&gt;&gt;&gt; mp.values()
SortedValuesView(SortedDict({1: [1, 1], 3: [3, 3], 5: [5, 5]}))
&gt;&gt;&gt; list(mp.values())
[[1, 1], [3, 3], [5, 5]]
&gt;&gt;&gt;
'''</span>
<span class="kn">from</span> <span class="nn">sortedcontainers</span> <span class="kn">import</span> <span class="n">SortedDict</span>

<span class="k">class</span> <span class="nc">SummaryRanges</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">mp</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">addNum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">mp</span><span class="p">)</span>
        <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">mp</span><span class="p">.</span><span class="n">bisect_right</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">lidx</span> <span class="o">=</span> <span class="n">n</span> <span class="k">if</span> <span class="n">ridx</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="n">ridx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># n is similar to java treemap returning null
</span>        <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">mp</span><span class="p">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">mp</span><span class="p">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">lidx</span> <span class="o">!=</span> <span class="n">n</span>
            <span class="ow">and</span> <span class="n">ridx</span> <span class="o">!=</span> <span class="n">n</span>
            <span class="ow">and</span> <span class="n">values</span><span class="p">[</span><span class="n">lidx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">val</span>
            <span class="ow">and</span> <span class="n">values</span><span class="p">[</span><span class="n">ridx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">val</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="n">lidx</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="n">ridx</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">mp</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="n">ridx</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">lidx</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">values</span><span class="p">[</span><span class="n">lidx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># &lt;= because, it could be [1 -&gt; 10], and new add is [5,5]
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="n">lidx</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="n">lidx</span><span class="p">]][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ridx</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">val</span> <span class="o">&gt;=</span> <span class="n">values</span><span class="p">[</span><span class="n">ridx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="n">ridx</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="n">ridx</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="p">,</span> <span class="n">val</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">getIntervals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">mp</span><span class="p">.</span><span class="n">values</span><span class="p">())</span>


<span class="c1"># # Your SummaryRanges object will be instantiated and called as such:
# # obj = SummaryRanges()
# # obj.addNum(val)
# # param_2 = obj.getIntervals()
</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-352.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
