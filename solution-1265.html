<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-1265.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-1265.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>1265 - Print Immutable Linked List in Reverse</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 1265. Print Immutable Linked List in Reverse Description You are given an immutable linked list, print out all values of each node in reverse with the help of the following&amp;nbsp;interface: ImmutableListNode:&amp;nbsp;An interface of immutable linked list, you are given the head of the list. You...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-1265.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-1265.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-1265.html" rel="stylesheet"/>
   <link href="solution-1265.html" rel="stylesheet"/>
   <link href="solution-1265.html" rel="stylesheet"/>
   <link href="solution-1265.html" rel="stylesheet"/>
   <link href="solution-1265.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="1265 - Print Immutable Linked List in Reverse" property="og:title"/>
   <meta content="Leetcode 1265. Print Immutable Linked List in Reverse Description You are given an immutable linked list, print out all values of each node in reverse with the help of the following&amp;nbsp;interface: ImmutableListNode:&amp;nbsp;An interface of immutable linked list, you are given the head of the list. You need to use the following functions to access the linked list (you can&amp;#39;t access the ImmutableListNode directly): ImmutableListNode.printValue(): Print value of the current node. ImmutableListNode.getNext(): Return the next node. The input is only given to initialize the linked list internally.&amp;nbsp;You must solve this problem without modifying the linked list. In other words, you must operate&amp;nbsp;the linked list using only the mentioned&amp;nbsp;APIs. &amp;nbsp; Example 1: Input: head = [1,2,3,4] Output: [4,3,2,1] Example 2: Input: head = [0,-4,-1,3,-5] Output: [-5,3,-1,-4,0] Example 3: Input: head = [-2,0,6,4,4,-6] Output: [-6,4,4,6,0,-2] &amp;nbsp; Constraints: The length of the linked list&amp;nbsp;is between [1, 1000]. The value of each&amp;nbsp;node in the linked list&amp;nbsp;is between [-1000, 1000]. &amp;nbsp; Follow up: Could you solve this problem in: Constant space complexity? Linear time complexity and less than linear space complexity? Solutions Similar to 206 Reverse Linked List Solution 1: Recursion We can use recursion to implement reverse printing of a linked list. In the function, we check whether the current node is null. If it is not null, we get the next node, then recursively call the function itself, and finally print the value of the current node. The time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the length of the linked list. Follow up, could you solve this problem in: Constant space complexity? This solution uses a recursive approach to traverse the linked list in reverse order without using any additional space. The printLinkedListInReverse method calls a helper function reversePrint recursively. It first recursively traverses to the end of the list and then prints the values in reverse order while backtracking. Question for above recursion solution: itâs a recursion, but recursion is also using memoryâs stack to store the previous recursions, why itâs Constant Space Complexity? Recursion typically uses the call stack to store previous function calls. However, in the case of the Constant Space Complexity solution for leetcode 1265, the key factor is that the space used by the recursion does not scale with the input size. Although the recursion does use the call stack to store intermediate function calls, the maximum depth of the recursion is limited by the number of nodes in the linked list. In other words, the depth of the recursion is determined by the size of the input, rather than growing indefinitely with the input size. Since the maximum depth of the recursion is bounded by a constant (the number of nodes in the linked list), the space complexity is considered constant. Regardless of the input size, the amount of additional space used by the recursion remains the same, making it a constant factor. Therefore, in this algorithmn, âconstantâ refers to the fact that the amount of additional space..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2019-05-18T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2019-05-18-1265-Print-Immutable-Linked-List-in-Reverse/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-1265.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="1265 - Print Immutable Linked List in Reverse" property="twitter:title"/>
   <meta content="Leetcode 1265. Print Immutable Linked List in Reverse Description You are given an immutable linked list, print out all values of each node in reverse with the help of the following&amp;nbsp;interface: ImmutableListNode:&amp;nbsp;An interface of immutable linked list, you are given the head of the list. You need to use the following functions to access the linked list (you can&amp;#39;t access the ImmutableListNode directly): ImmutableListNode.printValue(): Print value of the current node. ImmutableListNode.getNext(): Return the next node. The input is only given to initialize the linked list internally.&amp;nbsp;You must solve this problem without modifying the linked list. In other words, you must operate&amp;nbsp;the linked list using only the mentioned&amp;nbsp;APIs. &amp;nbsp; Example 1: Input: head = [1,2,3,4] Output: [4,3,2,1] Example 2: Input: head = [0,-4,-1,3,-5] Output: [-5,3,-1,-4,0] Example 3: Input: head = [-2,0,6,4,4,-6] Output: [-6,4,4,6,0,-2] &amp;nbsp; Constraints: The length of the linked list&amp;nbsp;is between [1, 1000]. The value of each&amp;nbsp;node in the linked list&amp;nbsp;is between [-1000, 1000]. &amp;nbsp; Follow up: Could you solve this problem in: Constant space complexity? Linear time complexity and less than linear space complexity? Solutions Similar to 206 Reverse Linked List Solution 1: Recursion We can use recursion to implement reverse printing of a linked list. In the function, we check whether the current node is null. If it is not null, we get the next node, then recursively call the function itself, and finally print the value of the current node. The time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the length of the linked list. Follow up, could you solve this problem in: Constant space complexity? This solution uses a recursive approach to traverse the linked list in reverse order without using any additional space. The printLinkedListInReverse method calls a helper function reversePrint recursively. It first recursively traverses to the end of the list and then prints the values in reverse order while backtracking. Question for above recursion solution: itâs a recursion, but recursion is also using memoryâs stack to store the previous recursions, why itâs Constant Space Complexity? Recursion typically uses the call stack to store previous function calls. However, in the case of the Constant Space Complexity solution for leetcode 1265, the key factor is that the space used by the recursion does not scale with the input size. Although the recursion does use the call stack to store intermediate function calls, the maximum depth of the recursion is limited by the number of nodes in the linked list. In other words, the depth of the recursion is determined by the size of the input, rather than growing indefinitely with the input size. Since the maximum depth of the recursion is bounded by a constant (the number of nodes in the linked list), the space complexity is considered constant. Regardless of the input size, the amount of additional space used by the recursion remains the same, making it a constant factor. Therefore, in this algorithmn, âconstantâ refers to the fact that the amount of additional space..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    1265 - Print Immutable Linked List in Reverse | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="1265 - Print Immutable Linked List in Reverse" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-1265.html" rel="canonical">
          <meta content="https://leetcode.ca/2019-05-18-1265-Print-Immutable-Linked-List-in-Reverse/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2019-05-18T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"1265 - Print Immutable Linked List in Reverse","dateModified":"2019-05-18T00:00:00-07:00","datePublished":"2019-05-18T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2019-05-18-1265-Print-Immutable-Linked-List-in-Reverse/"},"url":"https://leetcode.ca/2019-05-18-1265-Print-Immutable-Linked-List-in-Reverse/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="1265-print-immutable-linked-list-in-reverse">
       <a href="solution-1265.html">
        1265. Print Immutable Linked List in Reverse
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       You are given an immutable linked list, print out all values of each node in reverse with the help of the following interface:
      </p>
      <ul>
       <li>
        <code>
         ImmutableListNode
        </code>
        : An interface of immutable linked list, you are given the head of the list.
       </li>
      </ul>
      <p>
       You need to use the following functions to access the linked list (you
       <strong>
        can't
       </strong>
       access the
       <code>
        ImmutableListNode
       </code>
       directly):
      </p>
      <ul>
       <li>
        <code>
         ImmutableListNode.printValue()
        </code>
        : Print value of the current node.
       </li>
       <li>
        <code>
         ImmutableListNode.getNext()
        </code>
        : Return the next node.
       </li>
      </ul>
      <p>
       The input is only given to initialize the linked list internally. You must solve this problem without modifying the linked list. In other words, you must operate the linked list using only the mentioned APIs.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> head = [1,2,3,4]
<strong>Output:</strong> [4,3,2,1]
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> head = [0,-4,-1,3,-5]
<strong>Output:</strong> [-5,3,-1,-4,0]
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> head = [-2,0,6,4,4,-6]
<strong>Output:</strong> [-6,4,4,6,0,-2]
</pre>
      <ul>
      </ul>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The length of the linked list is between
        <code>
         [1, 1000]
        </code>
        .
       </li>
       <li>
        The value of each node in the linked list is between
        <code>
         [-1000, 1000]
        </code>
        .
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong>
        Follow up:
       </strong>
      </p>
      <p>
       Could you solve this problem in:
      </p>
      <ul>
       <li>
        Constant space complexity?
       </li>
       <li>
        Linear time complexity and less than linear space complexity?
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       Similar to
       <a href="solution-1265.html">
        206	Reverse Linked List
       </a>
      </p>
      <p>
       <strong>
        Solution 1: Recursion
       </strong>
      </p>
      <p>
       We can use recursion to implement reverse printing of a linked list. In the function, we check whether the current node is null. If it is not null, we get the next node, then recursively call the function itself, and finally print the value of the current node.
      </p>
      <p>
       The time complexity is $O(n)$, and the space complexity is $O(n)$. Where $n$ is the length of the linked list.
      </p>
      <h3 id="follow-up-could-you-solve-this-problem-in">
       Follow up, could you solve this problem in:
      </h3>
      <h5 id="constant-space-complexity">
       Constant space complexity?
      </h5>
      <p>
       This solution uses a recursive approach to traverse the linked list in reverse order without using any additional space. The
       <code class="language-plaintext highlighter-rouge">
        printLinkedListInReverse
       </code>
       method calls a helper function
       <code class="language-plaintext highlighter-rouge">
        reversePrint
       </code>
       recursively. It first recursively traverses to the end of the list and then prints the values in reverse order while backtracking.
      </p>
      <p>
       <code class="language-plaintext highlighter-rouge">
        Question for above recursion solution
       </code>
       : itâs a recursion, but recursion is also using memoryâs stack to store the previous recursions, why itâs Constant Space Complexity?
      </p>
      <ul>
       <li>
        Recursion typically uses the
        <code class="language-plaintext highlighter-rouge">
         call stack
        </code>
        to store previous function calls. However, in the case of the Constant Space Complexity solution for leetcode 1265, the
        <code class="language-plaintext highlighter-rouge">
         key factor
        </code>
        is that the space used by the recursion
        <code class="language-plaintext highlighter-rouge">
         does not scale with the input size
        </code>
        .
       </li>
       <li>
        Although the recursion does use the call stack to store intermediate function calls, the
        <code class="language-plaintext highlighter-rouge">
         maximum depth of the recursion is limited
        </code>
        by the number of nodes in the linked list. In other words, the depth of the recursion is
        <code class="language-plaintext highlighter-rouge">
         determined by the size of the input
        </code>
        , rather than growing indefinitely with the input size.
       </li>
       <li>
        Since the maximum depth of the recursion is
        <code class="language-plaintext highlighter-rouge">
         bounded by a constant
        </code>
        (the number of nodes in the linked list), the space complexity is
        <code class="language-plaintext highlighter-rouge">
         considered constant
        </code>
        . Regardless of the input size, the amount of additional space used by the recursion remains the same,
        <code class="language-plaintext highlighter-rouge">
         making it a constant factor
        </code>
        .
       </li>
       <li>
        Therefore, in this algorithmn, âconstantâ refers to the fact that the amount of additional space used by the recursion
        <code class="language-plaintext highlighter-rouge">
         does not grow with the input size
        </code>
        , rather than implying that no memory is used at all.
       </li>
      </ul>
      <h5 id="linear-time-complexity-and-less-than-linear-space-complexity">
       Linear time complexity and less than linear space complexity?
      </h5>
      <p>
       In this solution, we first calculate the count of nodes in the linked list using the
       <code class="language-plaintext highlighter-rouge">
        getNodeCount
       </code>
       method, which iterates through the list and counts the nodes.
      </p>
      <p>
       Then, the
       <code class="language-plaintext highlighter-rouge">
        printListReverse
       </code>
       method recursively prints the list in reverse order. It keeps track of the remaining count of nodes and only proceeds to print if there are more than one node left. The method calls itself recursively with the next node and decreases the count by one in each recursive call until reaching the base case (either a
       <code class="language-plaintext highlighter-rouge">
        None
       </code>
       node or a count of zero). Then it prints the value of the current node.
      </p>
      <p>
       Both of these solutions satisfy the specified requirements, achieving constant space complexity or linear time complexity with less than linear space complexity.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#775aeb41-47bb-45b3-a3be-2615660ca340'}">
       <li class="uk-active">
        <a href="solution-1265.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-1265.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-1265.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-1265.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-1265.html">
         TypeScript
        </a>
       </li>
       <li>
        <a href="solution-1265.html">
         C#
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="775aeb41-47bb-45b3-a3be-2615660ca340">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * // This is the ImmutableListNode's API interface.
 * // You should not implement it, or speculate about its implementation.
 * interface ImmutableListNode {
 *     public void printValue(); // print the value of this node.
 *     public ImmutableListNode getNext(); // return the next node.
 * };
 */</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printLinkedListInReverse</span><span class="o">(</span><span class="nc">ImmutableListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">printLinkedListInReverse</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">getNext</span><span class="o">());</span>
            <span class="n">head</span><span class="o">.</span><span class="na">printValue</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * // This is the ImmutableListNode's API interface.
 * // You should not implement it, or speculate about its implementation.
 * class ImmutableListNode {
 * public:
 *    void printValue(); // print the value of the node.
 *    ImmutableListNode* getNext(); // return the next node.
 * };
 */</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">printLinkedListInReverse</span><span class="p">(</span><span class="n">ImmutableListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printLinkedListInReverse</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">());</span>
            <span class="n">head</span><span class="o">-&gt;</span><span class="n">printValue</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># """
# This is the ImmutableListNode's API interface.
# You should not implement it, or speculate about its implementation.
# """
# class ImmutableListNode:
#     def printValue(self) -&gt; None: # print the value of this node.
#     def getNext(self) -&gt; 'ImmutableListNode': # return the next node.
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">printLinkedListInReverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="s">'ImmutableListNode'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="n">head</span><span class="p">:</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">getNext</span><span class="p">()</span>

        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">printValue</span><span class="p">()</span>

<span class="c1">##############
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span> <span class="c1"># follow up: Constant Space Complexity
</span>    <span class="k">def</span> <span class="nf">printLinkedListInReverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="s">'ImmutableListNode'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">head</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">printLinkedListInReverse</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="n">getNext</span><span class="p">())</span>
            <span class="n">head</span><span class="p">.</span><span class="n">printValue</span><span class="p">()</span>


<span class="c1">##############
</span>
<span class="k">class</span> <span class="nc">Solution_followup</span><span class="p">:</span> <span class="c1"># follow up: Linear Time Complexity and Less Than Linear Space Complexity
</span>    <span class="k">def</span> <span class="nf">printLinkedListInReverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="s">'ImmutableListNode'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">head</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Count nodes
</span>        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_count</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>

        <span class="c1"># Print one by one
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">print_nth</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="s">'ImmutableListNode'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">getNext</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">count</span>

    <span class="k">def</span> <span class="nf">print_nth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="s">'ImmutableListNode'</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">curr</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">getNext</span><span class="p">()</span>

        <span class="n">curr</span><span class="p">.</span><span class="n">printValue</span><span class="p">()</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/*   Below is the interface for ImmutableListNode, which is already defined for you.
 *
 *   type ImmutableListNode struct {
 *
 *   }
 *
 *   func (this *ImmutableListNode) getNext() ImmutableListNode {
 *		// return the next node.
 *   }
 *
 *   func (this *ImmutableListNode) printValue() {
 *		// print the value of this node.
 *   }
 */</span>

<span class="k">func</span> <span class="n">printLinkedListInReverse</span><span class="p">(</span><span class="n">head</span> <span class="n">ImmutableListNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">head</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">printLinkedListInReverse</span><span class="p">(</span><span class="n">head</span><span class="o">.</span><span class="n">getNext</span><span class="p">())</span>
		<span class="n">head</span><span class="o">.</span><span class="n">printValue</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * // This is the ImmutableListNode's API interface.
 * // You should not implement it, or speculate about its implementation
 * class ImmutableListNode {
 *      printValue() {}
 *
 *      getNext(): ImmutableListNode {}
 * }
 */</span>

<span class="kd">function</span> <span class="nx">printLinkedListInReverse</span><span class="p">(</span><span class="nx">head</span><span class="p">:</span> <span class="nx">ImmutableListNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">printLinkedListInReverse</span><span class="p">(</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span><span class="p">);</span>
        <span class="nx">head</span><span class="p">.</span><span class="nx">printValue</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * // This is the ImmutableListNode's API interface.
 * // You should not implement it, or speculate about its implementation.
 * class ImmutableListNode {
 *     public void PrintValue(); // print the value of this node.
 *     public ImmutableListNode GetNext(); // return the next node.
 * }
 */</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">PrintLinkedListInReverse</span><span class="p">(</span><span class="n">ImmutableListNode</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">PrintLinkedListInReverse</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="nf">GetNext</span><span class="p">());</span>
            <span class="n">head</span><span class="p">.</span><span class="nf">PrintValue</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-1265.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
