<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-269.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-269.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>269 - Alien Dictionary</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode Question Formatted question description: https://leetcode.ca/all/269.html There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you. You are given a list of strings words from the alien language&amp;#39;s dictionary, where the strings in words are...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-269.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-269.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-269.html" rel="stylesheet"/>
   <link href="solution-269.html" rel="stylesheet"/>
   <link href="solution-269.html" rel="stylesheet"/>
   <link href="solution-269.html" rel="stylesheet"/>
   <link href="solution-269.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="269 - Alien Dictionary" property="og:title"/>
   <meta content="Leetcode Question Formatted question description: https://leetcode.ca/all/269.html There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you. You are given a list of strings words from the alien language&amp;#39;s dictionary, where the strings in words are sorted lexicographically by the rules of this new language. Return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language&amp;#39;s rules. If there is no solution, return &amp;quot;&amp;quot;. If there are multiple solutions, return any of them. &amp;nbsp; Example 1: Input: words = [&amp;quot;wrt&amp;quot;,&amp;quot;wrf&amp;quot;,&amp;quot;er&amp;quot;,&amp;quot;ett&amp;quot;,&amp;quot;rftt&amp;quot;] Output: &amp;quot;wertf&amp;quot; Example 2: Input: words = [&amp;quot;z&amp;quot;,&amp;quot;x&amp;quot;] Output: &amp;quot;zx&amp;quot; Example 3: Input: words = [&amp;quot;z&amp;quot;,&amp;quot;x&amp;quot;,&amp;quot;z&amp;quot;] Output: &amp;quot;&amp;quot; Explanation: The order is invalid, so return &amp;quot;&amp;quot;. &amp;nbsp; Constraints: 1 &amp;lt;= words.length &amp;lt;= 100 1 &amp;lt;= words[i].length &amp;lt;= 100 words[i] consists of only lowercase English letters. Algorithm This problem is a variant of the classical topological sorting problem, where youâre given a partial order of elements and asked to extend it to a total order. Overview Graph Representation: The problem is modeled as a directed graph where each node represents a character, and an edge from node u to node v implies that u comes before v in the alien language. The goal is to find a topological ordering of the graphâs nodes, which represents the alphabet of the alien language. _buildGraph Method Node Initialization: Initializes inDegree for all characters in all words to 0 and prepares the graph. inDegree counts the number of edges pointing to a node, which is used to identify nodes with no incoming edges. Graph Construction: By comparing adjacent words in the list, it determines the order between different characters and constructs the graph accordingly. When the first non-matching characters between two words are found, an edge is added from the character in the first word to the character in the second word. This is because the sorted list of words implies that characters in earlier words precede those in later words. Edge Addition and inDegree Update: If character v is not already in the adjacency list of u (graph[u]), it adds v to uâs list and increments vâs inDegree. This maintains the count of how many characters come before v. Invalid Order Detection: If a longer word comes before a shorter word and they match up to the length of the shorter word, the order is invalid (e.g., âabâ before âaâ), and the graph is cleared to signal an invalid configuration. _topology Method Topological Sort: Implements topological sorting using Kahnâs algorithm. It starts with characters that have an inDegree of 0 (i.e., characters that donât have any characters preceding them) and adds them to a queue. While the queue is not empty, it removes a character from the queue, appends it to the result string (since this character has no preceding characters or all of them have already been added to the result), and decreases the inDegree of its adjacent characters...." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-08-25T22:21:01-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-08-25-269-Alien-Dictionary/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-269.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="269 - Alien Dictionary" property="twitter:title"/>
   <meta content="Leetcode Question Formatted question description: https://leetcode.ca/all/269.html There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you. You are given a list of strings words from the alien language&amp;#39;s dictionary, where the strings in words are sorted lexicographically by the rules of this new language. Return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language&amp;#39;s rules. If there is no solution, return &amp;quot;&amp;quot;. If there are multiple solutions, return any of them. &amp;nbsp; Example 1: Input: words = [&amp;quot;wrt&amp;quot;,&amp;quot;wrf&amp;quot;,&amp;quot;er&amp;quot;,&amp;quot;ett&amp;quot;,&amp;quot;rftt&amp;quot;] Output: &amp;quot;wertf&amp;quot; Example 2: Input: words = [&amp;quot;z&amp;quot;,&amp;quot;x&amp;quot;] Output: &amp;quot;zx&amp;quot; Example 3: Input: words = [&amp;quot;z&amp;quot;,&amp;quot;x&amp;quot;,&amp;quot;z&amp;quot;] Output: &amp;quot;&amp;quot; Explanation: The order is invalid, so return &amp;quot;&amp;quot;. &amp;nbsp; Constraints: 1 &amp;lt;= words.length &amp;lt;= 100 1 &amp;lt;= words[i].length &amp;lt;= 100 words[i] consists of only lowercase English letters. Algorithm This problem is a variant of the classical topological sorting problem, where youâre given a partial order of elements and asked to extend it to a total order. Overview Graph Representation: The problem is modeled as a directed graph where each node represents a character, and an edge from node u to node v implies that u comes before v in the alien language. The goal is to find a topological ordering of the graphâs nodes, which represents the alphabet of the alien language. _buildGraph Method Node Initialization: Initializes inDegree for all characters in all words to 0 and prepares the graph. inDegree counts the number of edges pointing to a node, which is used to identify nodes with no incoming edges. Graph Construction: By comparing adjacent words in the list, it determines the order between different characters and constructs the graph accordingly. When the first non-matching characters between two words are found, an edge is added from the character in the first word to the character in the second word. This is because the sorted list of words implies that characters in earlier words precede those in later words. Edge Addition and inDegree Update: If character v is not already in the adjacency list of u (graph[u]), it adds v to uâs list and increments vâs inDegree. This maintains the count of how many characters come before v. Invalid Order Detection: If a longer word comes before a shorter word and they match up to the length of the shorter word, the order is invalid (e.g., âabâ before âaâ), and the graph is cleared to signal an invalid configuration. _topology Method Topological Sort: Implements topological sorting using Kahnâs algorithm. It starts with characters that have an inDegree of 0 (i.e., characters that donât have any characters preceding them) and adds them to a queue. While the queue is not empty, it removes a character from the queue, appends it to the result string (since this character has no preceding characters or all of them have already been added to the result), and decreases the inDegree of its adjacent characters...." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    269 - Alien Dictionary | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="269 - Alien Dictionary" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-269.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-08-25-269-Alien-Dictionary/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-08-25T22:21:01-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"269 - Alien Dictionary","dateModified":"2016-08-25T22:21:01-07:00","datePublished":"2016-08-25T22:21:01-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-08-25-269-Alien-Dictionary/"},"url":"https://leetcode.ca/2016-08-25-269-Alien-Dictionary/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="question">
       Question
      </h1>
      <p>
       Formatted question description:
       <a href="solution-269.html">
        https://leetcode.ca/all/269.html
       </a>
      </p>
      <p>
       There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.
      </p>
      <p>
       You are given a list of strings
       <code>
        words
       </code>
       from the alien language's dictionary, where the strings in
       <code>
        words
       </code>
       are
       <span data-keyword="lexicographically-smaller-string-alien">
        <strong>
         sorted lexicographically
        </strong>
       </span>
       by the rules of this new language.
      </p>
      <p>
       Return
       <em>
        a string of the unique letters in the new alien language sorted in
        <strong>
         lexicographically increasing order
        </strong>
        by the new language's rules.
       </em>
       If there is no solution, return
       <code>
        ""
       </code>
       <em>
        .
       </em>
       If there are multiple solutions, return
       <em>
        <strong>
         any of them
        </strong>
       </em>
       .
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> words = ["wrt","wrf","er","ett","rftt"]
<strong>Output:</strong> "wertf"
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> words = ["z","x"]
<strong>Output:</strong> "zx"
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> words = ["z","x","z"]
<strong>Output:</strong> ""
<strong>Explanation:</strong> The order is invalid, so return <code>""</code>.
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= words.length &lt;= 100
        </code>
       </li>
       <li>
        <code>
         1 &lt;= words[i].length &lt;= 100
        </code>
       </li>
       <li>
        <code>
         words[i]
        </code>
        consists of only lowercase English letters.
       </li>
      </ul>
      <h1 id="algorithm">
       Algorithm
      </h1>
      <p>
       This problem is a variant of the classical
       <code class="language-plaintext highlighter-rouge">
        topological sorting
       </code>
       problem, where youâre given a partial order of elements and asked to extend it to a total order.
      </p>
      <h3 id="overview">
       Overview
      </h3>
      <ul>
       <li>
        <strong>
         Graph Representation
        </strong>
        : The problem is modeled as a directed graph where each node represents a character, and an edge from node
        <code class="language-plaintext highlighter-rouge">
         u
        </code>
        to node
        <code class="language-plaintext highlighter-rouge">
         v
        </code>
        implies that
        <code class="language-plaintext highlighter-rouge">
         u
        </code>
        comes before
        <code class="language-plaintext highlighter-rouge">
         v
        </code>
        in the alien language. The goal is to find a topological ordering of the graphâs nodes, which represents the alphabet of the alien language.
       </li>
      </ul>
      <h3 id="_buildgraph-method">
       <code class="language-plaintext highlighter-rouge">
        _buildGraph
       </code>
       Method
      </h3>
      <ul>
       <li>
        <p>
         <strong>
          Node Initialization
         </strong>
         : Initializes
         <code class="language-plaintext highlighter-rouge">
          inDegree
         </code>
         for all characters in all words to 0 and prepares the graph.
         <code class="language-plaintext highlighter-rouge">
          inDegree
         </code>
         counts the number of edges pointing to a node, which is used to identify nodes with no incoming edges.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Graph Construction
         </strong>
         : By comparing adjacent words in the list, it determines the order between different characters and constructs the graph accordingly. When the first non-matching characters between two words are found, an edge is added from the character in the first word to the character in the second word. This is because the sorted list of words implies that characters in earlier words precede those in later words.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Edge Addition and
          <code class="language-plaintext highlighter-rouge">
           inDegree
          </code>
          Update
         </strong>
         : If character
         <code class="language-plaintext highlighter-rouge">
          v
         </code>
         is not already in the adjacency list of
         <code class="language-plaintext highlighter-rouge">
          u
         </code>
         (
         <code class="language-plaintext highlighter-rouge">
          graph[u]
         </code>
         ), it adds
         <code class="language-plaintext highlighter-rouge">
          v
         </code>
         to
         <code class="language-plaintext highlighter-rouge">
          u
         </code>
         âs list and increments
         <code class="language-plaintext highlighter-rouge">
          v
         </code>
         âs
         <code class="language-plaintext highlighter-rouge">
          inDegree
         </code>
         . This maintains the count of how many characters come before
         <code class="language-plaintext highlighter-rouge">
          v
         </code>
         .
        </p>
       </li>
       <li>
        <p>
         <strong>
          Invalid Order Detection
         </strong>
         : If a longer word comes before a shorter word and they match up to the length of the shorter word, the order is invalid (e.g., âabâ before âaâ), and the graph is cleared to signal an invalid configuration.
        </p>
       </li>
      </ul>
      <h3 id="_topology-method">
       <code class="language-plaintext highlighter-rouge">
        _topology
       </code>
       Method
      </h3>
      <ul>
       <li>
        <p>
         <strong>
          Topological Sort
         </strong>
         : Implements topological sorting using Kahnâs algorithm. It starts with characters that have an
         <code class="language-plaintext highlighter-rouge">
          inDegree
         </code>
         of 0 (i.e., characters that donât have any characters preceding them) and adds them to a queue. While the queue is not empty, it removes a character from the queue, appends it to the
         <code class="language-plaintext highlighter-rouge">
          result
         </code>
         string (since this character has no preceding characters or all of them have already been added to the result), and decreases the
         <code class="language-plaintext highlighter-rouge">
          inDegree
         </code>
         of its adjacent characters. If any adjacent characterâs
         <code class="language-plaintext highlighter-rouge">
          inDegree
         </code>
         becomes 0, itâs added to the queue.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Cycle Detection
         </strong>
         : If, after processing all characters, there are still characters with non-zero
         <code class="language-plaintext highlighter-rouge">
          inDegree
         </code>
         , it means thereâs a cycle in the graph, and no valid ordering exists. This scenario returns an empty string.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Result Validation
         </strong>
         : Finally, it checks if the length of the
         <code class="language-plaintext highlighter-rouge">
          result
         </code>
         string matches the number of unique characters in
         <code class="language-plaintext highlighter-rouge">
          inDegree
         </code>
         . If not, it means not all characters were accounted for, possibly due to an invalid input, and it returns an empty string if such a case is detected.
        </p>
       </li>
      </ul>
      <h3 id="conclusion">
       Conclusion
      </h3>
      <p>
       This solution effectively builds a graph to represent the partial ordering of characters inferred from the input list of words, then performs a topological sort on this graph to determine the charactersâ order in the alien language. The topological sort also incorporates checks for cycles and invalid configurations, which would indicate that no valid ordering exists.
      </p>
      <h1 id="code">
       Code
      </h1>
      <ul class="uk-tab" data-uk-switcher="{connect:'#d69c99ec-f71d-4a2a-b760-6ef25b3bed2f'}">
       <li class="uk-active">
        <a href="solution-269.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-269.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-269.html">
         Python
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="d69c99ec-f71d-4a2a-b760-6ef25b3bed2f">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Alien_Dictionary</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Alien_Dictionary</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Alien_Dictionary</span><span class="o">();</span>
        <span class="nc">Solution</span> <span class="n">s</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="na">new</span> <span class="nf">Solution</span><span class="o">();</span>
        <span class="n">Solution_bfs</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="na">new</span> <span class="nf">Solution_bfs</span><span class="o">();</span>

        <span class="nc">String</span><span class="o">[]</span> <span class="n">words</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]</span> <span class="o">{</span>
            <span class="s">"wrt"</span><span class="o">,</span>
            <span class="s">"wrf"</span><span class="o">,</span>
            <span class="s">"er"</span><span class="o">,</span>
            <span class="s">"ett"</span><span class="o">,</span>
            <span class="s">"rftt"</span>
        <span class="o">};</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">alienOrder</span><span class="o">(</span><span class="n">words</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="na">alienOrder</span><span class="o">(</span><span class="n">words</span><span class="o">));</span>
    <span class="o">}</span>


    <span class="c1">// ref: http://buttercola.blogspot.com/2015/09/leetcode-alien-dictionary.html</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution_bfs</span> <span class="o">{</span>
        <span class="cm">/**
         * @param words: a list of words
         * @return: a string which is correct order
         */</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">alienOrder</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Write your code here</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">words</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// step 1: construct the graph</span>
            <span class="c1">//</span>
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;&gt;</span> <span class="n">adjMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
            <span class="n">constructGraph</span><span class="o">(</span><span class="n">words</span><span class="o">,</span> <span class="n">adjMap</span><span class="o">);</span>

            <span class="kt">int</span> <span class="n">numNodes</span> <span class="o">=</span> <span class="n">adjMap</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>

            <span class="nc">StringBuilder</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

            <span class="c1">// toplogical sorting</span>
            <span class="c1">//</span>
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">indegreeMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Character</span> <span class="n">node</span> <span class="o">:</span> <span class="n">adjMap</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">indegreeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="k">for</span> <span class="o">(</span><span class="nc">Character</span> <span class="n">node</span> <span class="o">:</span> <span class="n">adjMap</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">Character</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">adjMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">indegree</span> <span class="o">=</span> <span class="n">indegreeMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">neighbor</span><span class="o">);</span>
                    <span class="n">indegree</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="n">indegreeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">neighbor</span><span class="o">,</span> <span class="n">indegree</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// start from indegree=0</span>
            <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Character</span> <span class="n">node</span> <span class="o">:</span> <span class="n">indegreeMap</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">indegreeMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// starting node, can only be one, cannot be 2 starting with 0 indegree</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="kt">char</span> <span class="n">curNode</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">curNode</span><span class="o">);</span>

                <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">adjMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">curNode</span><span class="o">))</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">indegree</span> <span class="o">=</span> <span class="n">indegreeMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">neighbor</span><span class="o">);</span>
                    <span class="n">indegree</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="n">indegreeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">neighbor</span><span class="o">,</span> <span class="n">indegree</span><span class="o">);</span>

                    <span class="c1">// @note: key is here.</span>
                    <span class="c1">// for A-&gt;B, B-&gt;C, A-C: C will not be counted until its indgree is 0</span>

                    <span class="k">if</span> <span class="o">(</span><span class="n">indegree</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">neighbor</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">numNodes</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="kd">private</span> <span class="kt">void</span> <span class="nf">constructGraph</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">,</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;&gt;</span> <span class="n">adjMap</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// construct nodes</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">word</span> <span class="o">:</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">Character</span> <span class="n">c</span> <span class="o">:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">adjMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span> <span class="c1">// c to all its next</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// construct edges</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
                <span class="nc">String</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">prev</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">curr</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">prev</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">!=</span> <span class="n">curr</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">adjMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">prev</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)).</span><span class="na">add</span><span class="o">(</span><span class="n">curr</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
        <span class="c1">// dfs</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">alienOrder</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>

            <span class="c1">// Step 1: build the graph</span>
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">currentWord</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">currentWord</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">graph</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">currentWord</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)))</span> <span class="o">{</span>
                        <span class="n">graph</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">currentWord</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">),</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;());</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">connectGraph</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span> <span class="n">currentWord</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// Step 2: topological sorting</span>
            <span class="nc">StringBuffer</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;();</span> <span class="c1">// mark as visited: visited.put(vertexId, -1);</span>

            <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;&gt;</span> <span class="nl">entry:</span> <span class="n">graph</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
                <span class="kt">char</span> <span class="n">vertexId</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">topologicalSort</span><span class="o">(</span><span class="n">vertexId</span><span class="o">,</span> <span class="n">graph</span><span class="o">,</span> <span class="n">sb</span><span class="o">,</span> <span class="n">visited</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="kd">private</span> <span class="kt">void</span> <span class="nf">connectGraph</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="o">,</span> <span class="nc">String</span> <span class="n">prev</span><span class="o">,</span> <span class="nc">String</span> <span class="n">curr</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">curr</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">prev</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">curr</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>

            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">char</span> <span class="n">p</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="kt">char</span> <span class="n">q</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// so if same duplicated work, will not reach here and not update graph</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">p</span><span class="o">).</span><span class="na">contains</span><span class="o">(</span><span class="n">q</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">p</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">topologicalSort</span><span class="o">(</span>
            <span class="kt">char</span> <span class="n">vertexId</span><span class="o">,</span>
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="o">,</span>
            <span class="nc">StringBuffer</span> <span class="n">sb</span><span class="o">,</span>
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">visited</span>
        <span class="o">)</span> <span class="o">{</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">vertexId</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// visited</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">vertexId</span><span class="o">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// -1 meaning visited, cycle found</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// already in the list</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">vertexId</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="n">visited</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">vertexId</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// mark as visited</span>


            <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">vertexId</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">neighbors</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">topologicalSort</span><span class="o">(</span><span class="n">neighbor</span><span class="o">,</span> <span class="n">graph</span><span class="o">,</span> <span class="n">sb</span><span class="o">,</span> <span class="n">visited</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="n">sb</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">vertexId</span><span class="o">);</span>
            <span class="n">visited</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">vertexId</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// restore visited</span>

            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">//////</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">alienOrder</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">g</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">26</span><span class="o">][</span><span class="mi">26</span><span class="o">];</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">26</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">c</span> <span class="o">-=</span> <span class="sc">'a'</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">s</span><span class="o">[</span><span class="n">c</span><span class="o">])</span> <span class="o">{</span>
                    <span class="o">++</span><span class="n">cnt</span><span class="o">;</span>
                    <span class="n">s</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">].</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="kt">char</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">),</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">g</span><span class="o">[</span><span class="n">c2</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">][</span><span class="n">c1</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">])</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">g</span><span class="o">[</span><span class="n">c1</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">][</span><span class="n">c2</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">words</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">].</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">26</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">c</span> <span class="o">-=</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">s</span><span class="o">[</span><span class="n">c</span><span class="o">])</span> <span class="o">{</span>
                <span class="o">++</span><span class="n">cnt</span><span class="o">;</span>
                <span class="n">s</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">indegree</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                    <span class="o">++</span><span class="n">indegree</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">indegree</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">q</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">StringBuilder</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
            <span class="n">ans</span><span class="o">.</span><span class="na">append</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">+</span> <span class="sc">'a'</span><span class="o">));</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">t</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">g</span><span class="o">[</span><span class="n">t</span><span class="o">][</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(--</span><span class="n">indegree</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">q</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">cnt</span> <span class="o">?</span> <span class="s">""</span> <span class="o">:</span> <span class="n">ans</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1">// OJ: https://leetcode.com/problems/alien-dictionary/</span>
<span class="c1">// Time: O(N)</span>
<span class="c1">// Space: O(1)</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">alienOrder</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">G</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">indegree</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">:</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="p">)</span> <span class="n">G</span><span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">());</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
                <span class="n">G</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">())</span> <span class="k">return</span> <span class="s">""</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">from</span><span class="p">,</span> <span class="n">tos</span><span class="p">]</span> <span class="o">:</span> <span class="n">G</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">to</span> <span class="o">:</span> <span class="n">tos</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">indegree</span><span class="p">[</span><span class="n">to</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">indegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">string</span> <span class="n">ans</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">u</span> <span class="o">+</span> <span class="sc">'a'</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">indegree</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">G</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="n">ans</span> <span class="o">:</span> <span class="s">""</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-python highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="s">'''
&gt;&gt;&gt; a = ['a','b','c']
&gt;&gt;&gt; zip(a, a[1:])
[('a', 'b'), ('b', 'c')]


# same as pairwise()
&gt;&gt;&gt; from itertools import pairwise
&gt;&gt;&gt; pairwise(a)
&lt;itertools.pairwise object at 0x108458730&gt;
&gt;&gt;&gt; list(pairwise(a))
[('a', 'b'), ('b', 'c')]
'''</span>

<span class="s">'''
&gt;&gt;&gt; inDegree = {'a':11, 'b':22, 'c':33}

&gt;&gt;&gt; [print(c) for c in inDegree.keys()]
a
b
c
[None, None, None]

# same as for c in inDegree.keys()
&gt;&gt;&gt; [print(c) for c in inDegree]
a
b
c
[None, None, None]

&gt;&gt;&gt; [print(c) for c in inDegree.values()]
11
22
33
[None, None, None]

&gt;&gt;&gt; [print(c) for c in inDegree.items()]
('a', 11)
('b', 22)
('c', 33)
[None, None, None]
'''</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">alienOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="n">inDegree</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="bp">self</span><span class="p">.</span><span class="n">_buildGraph</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">inDegree</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_topology</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">inDegree</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_buildGraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">words</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">inDegree</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Create a node for each character in each word
</span>        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
                <span class="n">inDegree</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># necessary for final char counting
</span>
        <span class="k">for</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span> <span class="c1"># or pairwise(words)
</span>            <span class="n">length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">first</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">second</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">first</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">second</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                        <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                        <span class="n">inDegree</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">break</span>  <span class="c1"># Later characters' order is meaningless
</span>                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">second</span><span class="p">):</span>
                    <span class="c1"># If 'ab' comes before 'a', it's an invalid order
</span>                    <span class="n">graph</span><span class="p">.</span><span class="n">clear</span><span class="p">()</span>
                    <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">inDegree</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s">''</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">inDegree</span> <span class="k">if</span> <span class="n">inDegree</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>

        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">u</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="n">inDegree</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">inDegree</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="c1"># If there are remaining characters in inDegree, it means there's a cycle
</span>        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">inDegree</span><span class="p">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">return</span> <span class="s">''</span>

        <span class="c1"># Words = ['z', 'x', 'y', 'x']
</span>        <span class="k">return</span> <span class="n">result</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">indegree</span><span class="p">)</span> <span class="k">else</span> <span class="s">''</span>

<span class="c1">############
</span>
<span class="kn">import</span> <span class="nn">collections</span>


<span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">neighbors</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">neighbors</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">getNbrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">neighbors</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">alienOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>
    <span class="s">"""
    :type words: List[str]
    :rtype: str
    """</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
      <span class="n">visited</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="k">for</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">root</span><span class="p">].</span><span class="n">getNbrs</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">nbr</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="n">dfs</span><span class="p">(</span><span class="n">nbr</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">visited</span><span class="p">[</span><span class="n">nbr</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
          <span class="k">return</span> <span class="bp">False</span>

      <span class="n">visited</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="bp">self</span><span class="p">.</span><span class="n">ans</span> <span class="o">+=</span> <span class="n">root</span>
      <span class="k">return</span> <span class="bp">True</span>

    <span class="bp">self</span><span class="p">.</span><span class="n">ans</span> <span class="o">=</span> <span class="s">""</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="n">collections</span><span class="p">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">topNum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="n">b</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
      <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
          <span class="n">nodeA</span> <span class="o">=</span> <span class="n">nodeB</span> <span class="o">=</span> <span class="bp">None</span>
          <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
            <span class="n">nodeA</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">nodeA</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">nodeA</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
          <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
            <span class="n">nodeB</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">nodeB</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">nodeB</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
          <span class="n">nodeA</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">nodeB</span><span class="p">)</span>
          <span class="k">break</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">""</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dfs</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
          <span class="k">return</span> <span class="s">""</span>

    <span class="n">unUsedSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
        <span class="n">unUsedSet</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">unUsedSet</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">ans</span> <span class="o">+=</span> <span class="n">c</span>
    <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">ans</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-269.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
