<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-347.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-347.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>347 - Top K Frequent Elements</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode Question Formatted question description: https://leetcode.ca/all/347.html 347. Top K Frequent Elements Level Medium Description Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-347.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-347.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-347.html" rel="stylesheet"/>
   <link href="solution-347.html" rel="stylesheet"/>
   <link href="solution-347.html" rel="stylesheet"/>
   <link href="solution-347.html" rel="stylesheet"/>
   <link href="solution-347.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="347 - Top K Frequent Elements" property="og:title"/>
   <meta content="Leetcode Question Formatted question description: https://leetcode.ca/all/347.html 347. Top K Frequent Elements Level Medium Description Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Note: You may assume k is always valid, 1 â¤ k â¤ number of unique elements. Your algorithmâs time complexity must be better than O(*n* log *n*), where n is the arrayâs size. Solution Similar to 692-Top-K-Frequent-Words To achieve an algorithm with a time complexity better than O(n log n), we can leverage mappings. This approach yields a time complexity of O(n log k). The strategy involves the use of two maps: The first map is a hash map that keeps track of each number and its corresponding count. The second map is a tree map, which organizes each count and the numbers associated with that count. The key distinction here is that the tree map sorts its keys. Implementation Steps Counting Occurrences: Iterate over the nums array to tally the occurrence of each number. Store this information in the first map, with the numbers as keys and their counts as values. Organizing Counts: Process the entries of the first map to compile each count and the associated numbers. Insert these into the second map, ensuring that the counts (keys) are in descending order. This setup enables us to efficiently access numbers based on their frequency. Selecting Top Frequencies: Traverse the second map to extract the k most frequent elements. This step is streamlined by the descending order of counts in the map. Consideration A potential complication arises in situations of frequency ties. The solution must account for how to prioritize numbers when multiple values share the same count. This clarification impacts the selection of the k most frequent elements, especially when the exact ordering or choice of elements within tied groups influences the outcome. Code Java C++ Python Go TypeScript RenderScript import java.util.*; public class Top_K_Frequent_Elements { // ref: https://leetcode.com/problems/top-k-frequent-elements/solution/ class Solution_official_oN { int[] unique; Map&amp;lt;Integer, Integer&amp;gt; count; public void swap(int a, int b) { int tmp = unique[a]; unique[a] = unique[b]; unique[b] = tmp; } public int partition(int left, int right, int pivot_index) { int pivot_frequency = count.get(unique[pivot_index]); // 1. move pivot to end swap(pivot_index, right); int store_index = left; // 2. move all less frequent elements to the left for (int i = left; i &amp;lt;= right; i++) { if (count.get(unique[i]) &amp;lt; pivot_frequency) { swap(store_index, i); store_index++; } } // 3. move pivot to its final place swap(store_index, right); return store_index; } public void quickselect(int left, int right, int k_smallest) { /* Sort a list within left..right till kth less frequent element takes its place. */ // base case: the list contains only one element if (left == right) return; // select a random pivot_index Random random_num = new Random(); int pivot_index = left + random_num.nextInt(right - left); // find the pivot position in a..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-11-11T21:21:01-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-11-11-347-Top-K-Frequent-Elements/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-347.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="347 - Top K Frequent Elements" property="twitter:title"/>
   <meta content="Leetcode Question Formatted question description: https://leetcode.ca/all/347.html 347. Top K Frequent Elements Level Medium Description Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Note: You may assume k is always valid, 1 â¤ k â¤ number of unique elements. Your algorithmâs time complexity must be better than O(*n* log *n*), where n is the arrayâs size. Solution Similar to 692-Top-K-Frequent-Words To achieve an algorithm with a time complexity better than O(n log n), we can leverage mappings. This approach yields a time complexity of O(n log k). The strategy involves the use of two maps: The first map is a hash map that keeps track of each number and its corresponding count. The second map is a tree map, which organizes each count and the numbers associated with that count. The key distinction here is that the tree map sorts its keys. Implementation Steps Counting Occurrences: Iterate over the nums array to tally the occurrence of each number. Store this information in the first map, with the numbers as keys and their counts as values. Organizing Counts: Process the entries of the first map to compile each count and the associated numbers. Insert these into the second map, ensuring that the counts (keys) are in descending order. This setup enables us to efficiently access numbers based on their frequency. Selecting Top Frequencies: Traverse the second map to extract the k most frequent elements. This step is streamlined by the descending order of counts in the map. Consideration A potential complication arises in situations of frequency ties. The solution must account for how to prioritize numbers when multiple values share the same count. This clarification impacts the selection of the k most frequent elements, especially when the exact ordering or choice of elements within tied groups influences the outcome. Code Java C++ Python Go TypeScript RenderScript import java.util.*; public class Top_K_Frequent_Elements { // ref: https://leetcode.com/problems/top-k-frequent-elements/solution/ class Solution_official_oN { int[] unique; Map&amp;lt;Integer, Integer&amp;gt; count; public void swap(int a, int b) { int tmp = unique[a]; unique[a] = unique[b]; unique[b] = tmp; } public int partition(int left, int right, int pivot_index) { int pivot_frequency = count.get(unique[pivot_index]); // 1. move pivot to end swap(pivot_index, right); int store_index = left; // 2. move all less frequent elements to the left for (int i = left; i &amp;lt;= right; i++) { if (count.get(unique[i]) &amp;lt; pivot_frequency) { swap(store_index, i); store_index++; } } // 3. move pivot to its final place swap(store_index, right); return store_index; } public void quickselect(int left, int right, int k_smallest) { /* Sort a list within left..right till kth less frequent element takes its place. */ // base case: the list contains only one element if (left == right) return; // select a random pivot_index Random random_num = new Random(); int pivot_index = left + random_num.nextInt(right - left); // find the pivot position in a..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    347 - Top K Frequent Elements | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="347 - Top K Frequent Elements" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-347.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-11-11-347-Top-K-Frequent-Elements/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-11-11T21:21:01-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"347 - Top K Frequent Elements","dateModified":"2016-11-11T21:21:01-08:00","datePublished":"2016-11-11T21:21:01-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-11-11-347-Top-K-Frequent-Elements/"},"url":"https://leetcode.ca/2016-11-11-347-Top-K-Frequent-Elements/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="question">
       Question
      </h1>
      <p>
       Formatted question description:
       <a href="solution-347.html">
        https://leetcode.ca/all/347.html
       </a>
      </p>
      <h1 id="347-top-k-frequent-elements">
       347. Top K Frequent Elements
      </h1>
      <h2 id="level">
       Level
      </h2>
      <p>
       Medium
      </p>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given a non-empty array of integers, return the
       <strong>
        <em>
         k
        </em>
       </strong>
       most frequent elements.
      </p>
      <p>
       <strong>
        Example 1:
       </strong>
      </p>
      <p>
       <strong>
        Input:
       </strong>
       nums = [1,1,1,2,2,3], k = 2
      </p>
      <p>
       <strong>
        Output:
       </strong>
       [1,2]
      </p>
      <p>
       <strong>
        Example 2:
       </strong>
      </p>
      <p>
       <strong>
        Input:
       </strong>
       nums = [1], k = 1
      </p>
      <p>
       <strong>
        Output:
       </strong>
       [1]
      </p>
      <p>
       <strong>
        Note:
       </strong>
      </p>
      <ul>
       <li>
        You may assume k is always valid, 1 â¤
        <em>
         k
        </em>
        â¤ number of unique elements.
       </li>
       <li>
        Your algorithmâs time complexity
        <strong>
         must be
        </strong>
        better than
        <code class="language-plaintext highlighter-rouge">
         O(*n* log *n*)
        </code>
        , where
        <em>
         n
        </em>
        is the arrayâs size.
       </li>
      </ul>
      <h2 id="solution">
       Solution
      </h2>
      <p>
       Similar to
       <a href="solution-347.html">
        692-Top-K-Frequent-Words
       </a>
      </p>
      <p>
       To achieve an algorithm with a time complexity better than
       <code class="language-plaintext highlighter-rouge">
        O(n log n)
       </code>
       , we can leverage mappings. This approach yields a time complexity of
       <code class="language-plaintext highlighter-rouge">
        O(n log k)
       </code>
       .
      </p>
      <p>
       The strategy involves the use of
       <code class="language-plaintext highlighter-rouge">
        two maps
       </code>
       :
      </p>
      <ul>
       <li>
        The first map is a hash map that keeps track of each number and its corresponding count.
       </li>
       <li>
        The second map is a tree map, which organizes each count and the numbers associated with that count. The key distinction here is that the tree map sorts its keys.
       </li>
      </ul>
      <h3 id="implementation-steps">
       Implementation Steps
      </h3>
      <ol>
       <li>
        <p>
         <strong>
          Counting Occurrences
         </strong>
         : Iterate over the
         <code class="language-plaintext highlighter-rouge">
          nums
         </code>
         array to tally the occurrence of each number. Store this information in the first map, with the numbers as keys and their counts as values.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Organizing Counts
         </strong>
         : Process the entries of the first map to compile each count and the associated numbers. Insert these into the second map, ensuring that the counts (keys) are in descending order. This setup enables us to efficiently access numbers based on their frequency.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Selecting Top Frequencies
         </strong>
         : Traverse the second map to extract the
         <code class="language-plaintext highlighter-rouge">
          k
         </code>
         most frequent elements. This step is streamlined by the descending order of counts in the map.
        </p>
       </li>
      </ol>
      <h3 id="consideration">
       Consideration
      </h3>
      <p>
       A potential complication arises in situations of
       <code class="language-plaintext highlighter-rouge">
        frequency ties
       </code>
       . The solution must account for how to prioritize numbers when multiple values share the same count. This clarification impacts the selection of the
       <code class="language-plaintext highlighter-rouge">
        k
       </code>
       most frequent elements, especially when the exact ordering or choice of elements within tied groups influences the outcome.
      </p>
      <h1 id="code">
       Code
      </h1>
      <ul class="uk-tab" data-uk-switcher="{connect:'#4dd509b0-6b95-48aa-9c6b-d47e0cdd1a99'}">
       <li class="uk-active">
        <a href="solution-347.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-347.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-347.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-347.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-347.html">
         TypeScript
        </a>
       </li>
       <li>
        <a href="solution-347.html">
         RenderScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="4dd509b0-6b95-48aa-9c6b-d47e0cdd1a99">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Top_K_Frequent_Elements</span> <span class="o">{</span>

    <span class="c1">// ref: https://leetcode.com/problems/top-k-frequent-elements/solution/</span>

    <span class="kd">class</span> <span class="nc">Solution_official_oN</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">unique</span><span class="o">;</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">count</span><span class="o">;</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">unique</span><span class="o">[</span><span class="n">a</span><span class="o">];</span>
            <span class="n">unique</span><span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">=</span> <span class="n">unique</span><span class="o">[</span><span class="n">b</span><span class="o">];</span>
            <span class="n">unique</span><span class="o">[</span><span class="n">b</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pivot_index</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">pivot_frequency</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">unique</span><span class="o">[</span><span class="n">pivot_index</span><span class="o">]);</span>
            <span class="c1">// 1. move pivot to end</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">pivot_index</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">store_index</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>

            <span class="c1">// 2. move all less frequent elements to the left</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">unique</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">&lt;</span> <span class="n">pivot_frequency</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">swap</span><span class="o">(</span><span class="n">store_index</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
                    <span class="n">store_index</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// 3. move pivot to its final place</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">store_index</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>

            <span class="k">return</span> <span class="n">store_index</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">quickselect</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k_smallest</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/*
        Sort a list within left..right till kth less frequent element
        takes its place.
        */</span>

            <span class="c1">// base case: the list contains only one element</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

            <span class="c1">// select a random pivot_index</span>
            <span class="nc">Random</span> <span class="n">random_num</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">pivot_index</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">random_num</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">);</span>

            <span class="c1">// find the pivot position in a sorted list</span>
            <span class="n">pivot_index</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">pivot_index</span><span class="o">);</span>

            <span class="c1">// if the pivot is in its final sorted position</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">k_smallest</span> <span class="o">==</span> <span class="n">pivot_index</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">k_smallest</span> <span class="o">&lt;</span> <span class="n">pivot_index</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// go left</span>
                <span class="n">quickselect</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">pivot_index</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">k_smallest</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// go right</span>
                <span class="n">quickselect</span><span class="o">(</span><span class="n">pivot_index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">k_smallest</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">topKFrequent</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// build hash map : character and how often it appears</span>
            <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">count</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// array of unique elements</span>
            <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="n">unique</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">count</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">unique</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="c1">// kth top frequent element is (n - k)th less frequent.</span>
            <span class="c1">// Do a partial sort: from less frequent to the most frequent, till</span>
            <span class="c1">// (n - k)th less frequent element takes its place (n - k) in a sorted array.</span>
            <span class="c1">// All element on the left are less frequent.</span>
            <span class="c1">// All the elements on the right are more frequent.</span>
            <span class="n">quickselect</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="o">);</span>
            <span class="c1">// Return top k frequent elements</span>
            <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">unique</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">class</span> <span class="nc">Solution_optimize</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">topKFrequent</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// O(1) time</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 1. build hash map : character and how often it appears</span>
            <span class="c1">// O(N) time</span>
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">countMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">n:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">countMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">countMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// init heap 'the less frequent element first', pollå°æåå©ä¸Kä¸ªæå¤§ç</span>
            <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">heap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span>
                <span class="o">(</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">countMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">n1</span><span class="o">)</span> <span class="o">-</span> <span class="n">countMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">n2</span><span class="o">));</span>

            <span class="c1">// 2. keep k top frequent elements in the heap</span>
            <span class="c1">// O(N log k) &lt; O(N log N) time</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">n:</span> <span class="n">countMap</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">heap</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="n">heap</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="c1">// 3. build an output array</span>
            <span class="c1">// O(k log k) time</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">top</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">top</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">top</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// use an array to save numbers into different bucket whose index is the frequency</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution_bucketCount</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">topKFrequent</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>

            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">n:</span> <span class="n">nums</span><span class="o">){</span>
                <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">hm</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// @note: corner case: if there is only one number in nums, we need the bucket has index 1.</span>
            <span class="nc">LinkedList</span><span class="o">[]</span> <span class="n">bucket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">n:</span> <span class="n">hm</span><span class="o">.</span><span class="na">keySet</span><span class="o">()){</span>
                <span class="kt">int</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">bucket</span><span class="o">[</span><span class="n">freq</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">bucket</span><span class="o">[</span><span class="n">freq</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
                <span class="o">}</span>
                <span class="n">bucket</span><span class="o">[</span><span class="n">freq</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">bucket</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--){</span>

                <span class="c1">// @note: possible tie happening</span>
                <span class="k">if</span><span class="o">(</span><span class="n">bucket</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">bucket</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                    <span class="n">result</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
                    <span class="n">k</span><span class="o">-=</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">topKFrequent</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>

            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// from num, to its count</span>
            <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

            <span class="c1">// to store top k</span>
            <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;</span> <span class="n">heap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span>
                <span class="o">(</span><span class="n">o1</span><span class="o">,</span> <span class="n">o2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">o1</span><span class="o">.</span><span class="na">count</span> <span class="o">-</span> <span class="n">o2</span><span class="o">.</span><span class="na">count</span><span class="o">)</span>
            <span class="o">);</span>

            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">each:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">each</span><span class="o">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">hm</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">each</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
            <span class="o">}</span>

            <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="nl">entry:</span> <span class="n">hm</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">heap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">()));</span>

                <span class="c1">// @note: i missed it</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">heap</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">while</span> <span class="o">(!</span><span class="n">heap</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">poll</span><span class="o">().</span><span class="na">num</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="nc">Collections</span><span class="o">.</span><span class="na">reverse</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>

            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">class</span> <span class="nc">Pair</span><span class="o">{</span>
        <span class="kt">int</span> <span class="n">num</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">,</span> <span class="kt">int</span> <span class="n">count</span><span class="o">){</span>
            <span class="k">this</span><span class="o">.</span><span class="na">num</span><span class="o">=</span><span class="n">num</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">count</span><span class="o">=</span><span class="n">count</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>



<span class="c1">//////</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">topKFrequent</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="n">frequency</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">nums</span><span class="o">).</span><span class="na">boxed</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
            <span class="nc">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="nc">Function</span><span class="o">.</span><span class="na">identity</span><span class="o">(),</span> <span class="nc">Collectors</span><span class="o">.</span><span class="na">counting</span><span class="o">()));</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">.</span><span class="na">comparingByValue</span><span class="o">());</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">var</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">frequency</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">entry</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">queue</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">mapToInt</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">::</span><span class="n">getKey</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1">// OJ: https://leetcode.com/problems/top-k-frequent-elements/</span>
<span class="c1">// Time: O(N + U) on average, O(N + U^2) in the worst case</span>
<span class="c1">// Space: O(U)</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">topKFrequent</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="k">return</span> <span class="n">A</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">cnt</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">:</span> <span class="n">A</span><span class="p">)</span> <span class="n">cnt</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">:</span> <span class="n">cnt</span><span class="p">)</span> <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">partition</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">R</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">L</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">L</span><span class="p">,</span> <span class="n">pivotIndex</span> <span class="o">=</span> <span class="n">L</span> <span class="o">+</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">R</span> <span class="o">-</span> <span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">[</span><span class="n">ans</span><span class="p">[</span><span class="n">pivotIndex</span><span class="p">]];</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="n">pivotIndex</span><span class="p">],</span> <span class="n">ans</span><span class="p">[</span><span class="n">R</span><span class="p">]);</span>
            <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="p">[</span><span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">)</span> <span class="n">swap</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ans</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">ans</span><span class="p">[</span><span class="n">R</span><span class="p">]);</span>
            <span class="k">return</span> <span class="n">j</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">auto</span> <span class="n">quickSelect</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">L</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">ans</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">L</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">M</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">M</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">M</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span> <span class="n">R</span> <span class="o">=</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">else</span> <span class="n">L</span> <span class="o">=</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>
        <span class="n">quickSelect</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
        <span class="n">ans</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-python highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="s">'''
&gt;&gt;&gt; nums = ["a", "a", "b", "c", "c"]

&gt;&gt;&gt; cnt = Counter(nums)
&gt;&gt;&gt; cnt
Counter({'a': 2, 'c': 2, 'b': 1})

# default to keys
&gt;&gt;&gt; sorted_freqs = sorted(cnt, key=lambda x: (-cnt[x], x))
&gt;&gt;&gt; sorted_freqs
['a', 'c', 'b']
'''</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">topKFrequent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># Count the frequency of each element in the list
</span>        <span class="n">cnt</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

        <span class="c1"># Sort the elements by frequency in decreasing order
</span>        <span class="c1"># diff from below solution: sorted(cnt), not sorted(cnt.items())
</span>        <span class="c1">#   more in https://leetcode.ca/2017-10-22-692-Top-K-Frequent-Words/
</span>        <span class="n">sorted_freqs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">cnt</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">sorted_freqs</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span>

<span class="c1">##############
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">topKFrequent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># Count the frequency of each element in the list
</span>        <span class="n">freqs</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

        <span class="c1"># Sort the elements by frequency in decreasing order
</span>        <span class="n">sorted_freqs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">freqs</span><span class="p">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c1"># also passing OJ: sorted_freqs = sorted(freqs.items(), key=lambda x: -x[1])
</span>
        <span class="c1"># Take the top k elements
</span>        <span class="n">top_k</span> <span class="o">=</span> <span class="p">[</span><span class="n">num</span> <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">sorted_freqs</span><span class="p">[:</span><span class="n">k</span><span class="p">]]</span>

        <span class="k">return</span> <span class="n">top_k</span>

<span class="c1">##############
</span>
<span class="s">'''
&gt;&gt;&gt; from heapq import heappush
&gt;&gt;&gt; h = []
&gt;&gt;&gt; heappush(h, (3,1))
&gt;&gt;&gt; heappush(h, (1,1))
&gt;&gt;&gt; heappush(h, (2,1))
&gt;&gt;&gt; h
[(1, 1), (3, 1), (2, 1)]

&gt;&gt;&gt; from heapq import heappop
&gt;&gt;&gt; heappop(h)
(1, 1)
&gt;&gt;&gt; heappop(h)
(2, 1)
&gt;&gt;&gt; heappop(h)
(3, 1)
'''</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span> <span class="c1"># heap
</span>    <span class="k">def</span> <span class="nf">topKFrequent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">hp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">cnt</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">heappush</span><span class="p">(</span><span class="n">hp</span><span class="p">,</span> <span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span> <span class="c1"># freq first, default sort by 1st element
</span>            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">heappop</span><span class="p">(</span><span class="n">hp</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">hp</span><span class="p">]</span>

<span class="c1">##############
</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="c1"># O(n log(n)) in the average case
# O(n^2) worst case
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">topKFrequent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">freq_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="n">freq_map</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">freq_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">freq_map</span><span class="p">.</span><span class="n">items</span><span class="p">())</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">quick_select</span><span class="p">(</span><span class="n">freq_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">num</span> <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">freq_list</span><span class="p">[:</span><span class="n">k</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">quick_select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq_list</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">pivot_idx</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">pivot_freq</span> <span class="o">=</span> <span class="n">freq_list</span><span class="p">[</span><span class="n">pivot_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">left</span> <span class="o">=</span> <span class="n">start</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">end</span>

        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">freq_list</span><span class="p">[</span><span class="n">left</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pivot_freq</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">freq_list</span><span class="p">[</span><span class="n">right</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pivot_freq</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">freq_list</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">freq_list</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_list</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">freq_list</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">quick_select</span><span class="p">(</span><span class="n">freq_list</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">left</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">quick_select</span><span class="p">(</span><span class="n">freq_list</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>


<span class="c1">###########
</span>

<span class="s">'''
&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; x.append([4, 5])
&gt;&gt;&gt; print(x)
[1, 2, 3, [4, 5]]


&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; x.extend([4, 5])
&gt;&gt;&gt; print(x)
[1, 2, 3, 4, 5]
'''</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">topKFrequent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

        <span class="c1"># not always filled, max possible frequency is len(nums) [1,1,1,1,...]
</span>        <span class="n">buckets</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">freq</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">buckets</span><span class="p">[</span><span class="n">freq</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">buckets</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bucket</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">bucket</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span>

<span class="c1">############
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">topKFrequent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="s">"""
    :type nums: List[int]
    :type k: int
    :rtype: List[int]
    """</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">buckets</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
      <span class="n">d</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
      <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">key</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
      <span class="n">freq</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="n">t</span>
      <span class="n">buckets</span><span class="p">[</span><span class="n">freq</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="n">buckets</span><span class="p">.</span><span class="n">reverse</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">buckets</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">item</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">item</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
          <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">pop</span><span class="p">())</span>
          <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">ans</span>

    <span class="k">return</span> <span class="n">ans</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">topKFrequent</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="n">cnt</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">nums</span> <span class="p">{</span>
		<span class="n">cnt</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="n">h</span> <span class="o">:=</span> <span class="n">hp</span><span class="p">{}</span>
	<span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">freq</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">cnt</span> <span class="p">{</span>
		<span class="n">heap</span><span class="o">.</span><span class="n">Push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="p">,</span> <span class="n">pair</span><span class="p">{</span><span class="n">v</span><span class="p">,</span> <span class="n">freq</span><span class="p">})</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">k</span> <span class="p">{</span>
			<span class="n">heap</span><span class="o">.</span><span class="n">Pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ans</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">ans</span> <span class="p">{</span>
		<span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="n">Pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span><span class="o">.</span><span class="n">v</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ans</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">pair</span> <span class="k">struct</span><span class="p">{</span> <span class="n">v</span><span class="p">,</span> <span class="n">cnt</span> <span class="kt">int</span> <span class="p">}</span>
<span class="k">type</span> <span class="n">hp</span> <span class="p">[]</span><span class="n">pair</span>

<span class="k">func</span> <span class="p">(</span><span class="n">h</span> <span class="n">hp</span><span class="p">)</span> <span class="n">Len</span><span class="p">()</span> <span class="kt">int</span>            <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">h</span> <span class="n">hp</span><span class="p">)</span> <span class="n">Less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span>  <span class="p">{</span> <span class="k">return</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">cnt</span> <span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">h</span> <span class="n">hp</span><span class="p">)</span> <span class="n">Swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="kt">int</span><span class="p">)</span>       <span class="p">{</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">h</span> <span class="o">*</span><span class="n">hp</span><span class="p">)</span> <span class="n">Push</span><span class="p">(</span><span class="n">v</span> <span class="k">interface</span><span class="p">{})</span> <span class="p">{</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="p">(</span><span class="n">pair</span><span class="p">))</span> <span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">h</span> <span class="o">*</span><span class="n">hp</span><span class="p">)</span> <span class="n">Pop</span><span class="p">()</span> <span class="k">interface</span><span class="p">{}</span>   <span class="p">{</span> <span class="n">a</span> <span class="o">:=</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">a</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">];</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">];</span> <span class="k">return</span> <span class="n">v</span> <span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">function</span> <span class="nx">topKFrequent</span><span class="p">(</span><span class="nx">nums</span><span class="p">:</span> <span class="kr">number</span><span class="p">[],</span> <span class="nx">k</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span><span class="p">[]</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">hashMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">num</span> <span class="k">of</span> <span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">hashMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">num</span><span class="p">,</span> <span class="p">(</span><span class="nx">hashMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">list</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">hashMap</span><span class="p">];</span>
    <span class="nx">list</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="kd">let</span> <span class="nx">ans</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">k</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">ans</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">list</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">ans</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-rs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Solution</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">top_k_frequent</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">map</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">max_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="o">&amp;</span><span class="n">num</span> <span class="k">in</span> <span class="n">nums</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="n">map</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num</span><span class="p">)</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">map</span><span class="nf">.insert</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
            <span class="n">max_count</span> <span class="o">=</span> <span class="n">max_count</span><span class="nf">.max</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="p">];</span>
        <span class="k">while</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="n">key</span> <span class="k">in</span> <span class="n">map</span><span class="nf">.keys</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="n">max_count</span> <span class="p">{</span>
                    <span class="n">res</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
                    <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">max_count</span> <span class="p">{</span>
                    <span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="nf">.max</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">max_count</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">res</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-347.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
