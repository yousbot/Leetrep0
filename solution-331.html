<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-331.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-331.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>331 - Verify Preorder Serialization of a Binary Tree</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 331. Verify Preorder Serialization of a Binary Tree Description One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node&amp;#39;s value. If it is a null node, we record using a sentinel value such...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-331.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-331.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-331.html" rel="stylesheet"/>
   <link href="solution-331.html" rel="stylesheet"/>
   <link href="solution-331.html" rel="stylesheet"/>
   <link href="solution-331.html" rel="stylesheet"/>
   <link href="solution-331.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="331 - Verify Preorder Serialization of a Binary Tree" property="og:title"/>
   <meta content="Leetcode 331. Verify Preorder Serialization of a Binary Tree Description One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node&amp;#39;s value. If it is a null node, we record using a sentinel value such as &amp;#39;#&amp;#39;. For example, the above binary tree can be serialized to the string &amp;quot;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;quot;, where &amp;#39;#&amp;#39; represents a null node. Given a string of comma-separated values preorder, return true if it is a correct preorder traversal serialization of a binary tree. It is guaranteed that each comma-separated value in the string must be either an integer or a character &amp;#39;#&amp;#39; representing null pointer. You may assume that the input format is always valid. For example, it could never contain two consecutive commas, such as &amp;quot;1,,3&amp;quot;. Note:&amp;nbsp;You are not allowed to reconstruct the tree. &amp;nbsp; Example 1: Input: preorder = &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot; Output: true Example 2: Input: preorder = &quot;1,#&quot; Output: false Example 3: Input: preorder = &quot;9,#,#,1&quot; Output: false &amp;nbsp; Constraints: 1 &amp;lt;= preorder.length &amp;lt;= 104 preorder consist of integers in the range [0, 100] and &amp;#39;#&amp;#39; separated by commas &amp;#39;,&amp;#39;. Solutions In a valid binary tree serialization, each non-null node is followed by two child nodes, which may themselves be null ('#') to indicate the absence of a child node. Core Logic The algorithm is based on the concept of indegree and outdegree. Each node in a binary tree (except the root) has 1 indegree (an edge from its parent) and 2 outdegrees (edges to its children, if non-null). The root node is unique because it does not have a parent, so it starts with an indegree of 1 less than usual to balance this out. Initialization: The preorder string is split by commas into a list of nodes, where each element represents a node in the tree. A node can either be a non-null value or '#' for a null node. Initialize indegree to 1, accounting for the root node which doesnât have a parent. Iterating Through Nodes: For each node in the serialized tree, decrease indegree by 1, reflecting that one node (either null or non-null) has been processed. If at any point indegree becomes negative, the function returns False. This is because a negative indegree indicates there are more edges pointing to nodes than there are nodes available, implying the serialization cannot represent a valid binary tree. If the node is not null (node != '#'), increase indegree by 2, accounting for the two children that a non-null node is supposed to have. Validation: After processing all nodes, if the final indegree is 0, it indicates that the serialization could potentially represent a valid binary tree, where all nodes have the correct number of incoming and outgoing edges. Therefore, the function returns True. If indegree is not 0, the serialization does not correctly represent a binary tree, and the function returns False. Example Consider the serialization preorder = &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;: Start with indegree = 1 for the..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-10-26T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-10-26-331-Verify-Preorder-Serialization-of-a-Binary-Tree/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-331.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="331 - Verify Preorder Serialization of a Binary Tree" property="twitter:title"/>
   <meta content="Leetcode 331. Verify Preorder Serialization of a Binary Tree Description One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node&amp;#39;s value. If it is a null node, we record using a sentinel value such as &amp;#39;#&amp;#39;. For example, the above binary tree can be serialized to the string &amp;quot;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;quot;, where &amp;#39;#&amp;#39; represents a null node. Given a string of comma-separated values preorder, return true if it is a correct preorder traversal serialization of a binary tree. It is guaranteed that each comma-separated value in the string must be either an integer or a character &amp;#39;#&amp;#39; representing null pointer. You may assume that the input format is always valid. For example, it could never contain two consecutive commas, such as &amp;quot;1,,3&amp;quot;. Note:&amp;nbsp;You are not allowed to reconstruct the tree. &amp;nbsp; Example 1: Input: preorder = &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot; Output: true Example 2: Input: preorder = &quot;1,#&quot; Output: false Example 3: Input: preorder = &quot;9,#,#,1&quot; Output: false &amp;nbsp; Constraints: 1 &amp;lt;= preorder.length &amp;lt;= 104 preorder consist of integers in the range [0, 100] and &amp;#39;#&amp;#39; separated by commas &amp;#39;,&amp;#39;. Solutions In a valid binary tree serialization, each non-null node is followed by two child nodes, which may themselves be null ('#') to indicate the absence of a child node. Core Logic The algorithm is based on the concept of indegree and outdegree. Each node in a binary tree (except the root) has 1 indegree (an edge from its parent) and 2 outdegrees (edges to its children, if non-null). The root node is unique because it does not have a parent, so it starts with an indegree of 1 less than usual to balance this out. Initialization: The preorder string is split by commas into a list of nodes, where each element represents a node in the tree. A node can either be a non-null value or '#' for a null node. Initialize indegree to 1, accounting for the root node which doesnât have a parent. Iterating Through Nodes: For each node in the serialized tree, decrease indegree by 1, reflecting that one node (either null or non-null) has been processed. If at any point indegree becomes negative, the function returns False. This is because a negative indegree indicates there are more edges pointing to nodes than there are nodes available, implying the serialization cannot represent a valid binary tree. If the node is not null (node != '#'), increase indegree by 2, accounting for the two children that a non-null node is supposed to have. Validation: After processing all nodes, if the final indegree is 0, it indicates that the serialization could potentially represent a valid binary tree, where all nodes have the correct number of incoming and outgoing edges. Therefore, the function returns True. If indegree is not 0, the serialization does not correctly represent a binary tree, and the function returns False. Example Consider the serialization preorder = &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;: Start with indegree = 1 for the..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    331 - Verify Preorder Serialization of a Binary Tree | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="331 - Verify Preorder Serialization of a Binary Tree" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-331.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-10-26-331-Verify-Preorder-Serialization-of-a-Binary-Tree/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-10-26T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"331 - Verify Preorder Serialization of a Binary Tree","dateModified":"2016-10-26T00:00:00-07:00","datePublished":"2016-10-26T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-10-26-331-Verify-Preorder-Serialization-of-a-Binary-Tree/"},"url":"https://leetcode.ca/2016-10-26-331-Verify-Preorder-Serialization-of-a-Binary-Tree/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="331-verify-preorder-serialization-of-a-binary-tree">
       <a href="solution-331.html">
        331. Verify Preorder Serialization of a Binary Tree
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       One way to serialize a binary tree is to use
       <strong>
        preorder traversal
       </strong>
       . When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as
       <code>
        '#'
       </code>
       .
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0300-0399/0331.Verify%20Preorder%20Serialization%20of%20a%20Binary%20Tree/images/pre-tree.jpg" style="width: 362px; height: 293px;"/>
      </p>
      <p>
       For example, the above binary tree can be serialized to the string
       <code>
        "9,3,4,#,#,1,#,#,2,#,6,#,#"
       </code>
       , where
       <code>
        '#'
       </code>
       represents a null node.
      </p>
      <p>
       Given a string of comma-separated values
       <code>
        preorder
       </code>
       , return
       <code>
        true
       </code>
       if it is a correct preorder traversal serialization of a binary tree.
      </p>
      <p>
       It is
       <strong>
        guaranteed
       </strong>
       that each comma-separated value in the string must be either an integer or a character
       <code>
        '#'
       </code>
       representing null pointer.
      </p>
      <p>
       You may assume that the input format is always valid.
      </p>
      <ul>
       <li>
        For example, it could never contain two consecutive commas, such as
        <code>
         "1,,3"
        </code>
        .
       </li>
      </ul>
      <p>
       <strong>
        Note:
       </strong>
       You are not allowed to reconstruct the tree.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre><strong>Input:</strong> preorder = "9,3,4,#,#,1,#,#,2,#,6,#,#"
<strong>Output:</strong> true
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre><strong>Input:</strong> preorder = "1,#"
<strong>Output:</strong> false
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <pre><strong>Input:</strong> preorder = "9,#,#,1"
<strong>Output:</strong> false
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= preorder.length &lt;= 10
         <sup>
          4
         </sup>
        </code>
       </li>
       <li>
        <code>
         preorder
        </code>
        consist of integers in the range
        <code>
         [0, 100]
        </code>
        and
        <code>
         '#'
        </code>
        separated by commas
        <code>
         ','
        </code>
        .
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       In a valid binary tree serialization, each non-null node is followed by two child nodes, which may themselves be null (
       <code class="language-plaintext highlighter-rouge">
        '#'
       </code>
       ) to indicate the absence of a child node.
      </p>
      <h3 id="core-logic">
       Core Logic
      </h3>
      <p>
       The algorithm is based on the concept of
       <strong>
        indegree
       </strong>
       and
       <strong>
        outdegree
       </strong>
       . Each node in a binary tree (except the root) has 1 indegree (an edge from its parent) and 2 outdegrees (edges to its children, if non-null). The root node is unique because it does not have a parent, so it starts with an
       <strong>
        indegree
       </strong>
       of 1 less than usual to balance this out.
      </p>
      <ol>
       <li>
        <strong>
         Initialization
        </strong>
        :
        <ul>
         <li>
          The preorder string is split by commas into a list of
          <code class="language-plaintext highlighter-rouge">
           nodes
          </code>
          , where each element represents a node in the tree. A node can either be a non-null value or
          <code class="language-plaintext highlighter-rouge">
           '#'
          </code>
          for a null node.
         </li>
         <li>
          Initialize
          <code class="language-plaintext highlighter-rouge">
           indegree
          </code>
          to 1, accounting for the root node which doesnât have a parent.
         </li>
        </ul>
       </li>
       <li>
        <strong>
         Iterating Through Nodes
        </strong>
        :
        <ul>
         <li>
          For each node in the serialized tree, decrease
          <code class="language-plaintext highlighter-rouge">
           indegree
          </code>
          by 1, reflecting that one node (either null or non-null) has been processed.
         </li>
         <li>
          If at any point
          <code class="language-plaintext highlighter-rouge">
           indegree
          </code>
          becomes negative, the function returns
          <code class="language-plaintext highlighter-rouge">
           False
          </code>
          . This is because a negative
          <code class="language-plaintext highlighter-rouge">
           indegree
          </code>
          indicates there are more edges pointing to nodes than there are nodes available, implying the serialization cannot represent a valid binary tree.
         </li>
         <li>
          If the node is not null (
          <code class="language-plaintext highlighter-rouge">
           node != '#'
          </code>
          ), increase
          <code class="language-plaintext highlighter-rouge">
           indegree
          </code>
          by 2, accounting for the two children that a non-null node is supposed to have.
         </li>
        </ul>
       </li>
       <li>
        <strong>
         Validation
        </strong>
        :
        <ul>
         <li>
          After processing all nodes, if the final
          <code class="language-plaintext highlighter-rouge">
           indegree
          </code>
          is 0, it indicates that the serialization could potentially represent a valid binary tree, where all nodes have the correct number of incoming and outgoing edges. Therefore, the function returns
          <code class="language-plaintext highlighter-rouge">
           True
          </code>
          .
         </li>
         <li>
          If
          <code class="language-plaintext highlighter-rouge">
           indegree
          </code>
          is not 0, the serialization does not correctly represent a binary tree, and the function returns
          <code class="language-plaintext highlighter-rouge">
           False
          </code>
          .
         </li>
        </ul>
       </li>
      </ol>
      <h3 id="example">
       Example
      </h3>
      <p>
       Consider the serialization
       <code class="language-plaintext highlighter-rouge">
        preorder = "9,3,4,#,#,1,#,#,2,#,6,#,#"
       </code>
       :
      </p>
      <ul>
       <li>
        Start with
        <code class="language-plaintext highlighter-rouge">
         indegree = 1
        </code>
        for the root.
       </li>
       <li>
        Process each node, adjusting
        <code class="language-plaintext highlighter-rouge">
         indegree
        </code>
        accordingly. Non-null nodes increase
        <code class="language-plaintext highlighter-rouge">
         indegree
        </code>
        by 2 (for their children), while processing any node (null or non-null) decreases
        <code class="language-plaintext highlighter-rouge">
         indegree
        </code>
        by 1.
       </li>
       <li>
        The serialization ends with
        <code class="language-plaintext highlighter-rouge">
         indegree = 0
        </code>
        , indicating it is a valid binary tree serialization.
       </li>
      </ul>
      <ul class="uk-tab" data-uk-switcher="{connect:'#c2504af3-7061-44f2-a33f-27289620b4f1'}">
       <li class="uk-active">
        <a href="solution-331.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-331.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-331.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-331.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-331.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="c2504af3-7061-44f2-a33f-27289620b4f1">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValidSerialization</span><span class="o">(</span><span class="nc">String</span> <span class="n">preorder</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stk</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">preorder</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">stk</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">stk</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">stk</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">stk</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="s">"#"</span><span class="o">)</span>
                <span class="o">&amp;&amp;</span> <span class="n">stk</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">stk</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">2</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="s">"#"</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">stk</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">stk</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">3</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="s">"#"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">stk</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">stk</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">stk</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">stk</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">stk</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">stk</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">stk</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"#"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">stk</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">stk</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="s">"#"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">isValidSerialization</span><span class="p">(</span><span class="n">string</span> <span class="n">preorder</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">stk</span><span class="p">;</span>
        <span class="n">stringstream</span> <span class="n">ss</span><span class="p">(</span><span class="n">preorder</span><span class="p">);</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="sc">','</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">stk</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">stk</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">stk</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">"#"</span> <span class="o">&amp;&amp;</span> <span class="n">stk</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s">"#"</span> <span class="o">&amp;&amp;</span> <span class="n">stk</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="s">"#"</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">stk</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
                <span class="n">stk</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
                <span class="n">stk</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
                <span class="n">stk</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"#"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">stk</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">stk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">"#"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="s">'''
In this solution, we split the input string by comma to get a list of nodes. 
We then initialize the indegree counter to 1 for the root node, 
since the root has no incoming edges.

We then loop through the nodes and for each node, we decrease the indegree counter by 1. 
If the indegree counter becomes negative, 
it means that there are more incoming edges than expected, 
and the tree is invalid. In this case, we return False.

If the current node is not null (i.e., not '#'), 
we increase the indegree counter by 2 for its two children. 
This is because every non-null node has two children in a binary tree. 
Finally, we return True if the final indegree counter is 0, 
meaning that all incoming edges have been accounted for.
'''</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValidSerialization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preorder</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Split the string by comma to get the list of nodes
</span>        <span class="n">nodes</span> <span class="o">=</span> <span class="n">preorder</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)</span>

        <span class="c1"># since the root has no incoming edges
</span>        <span class="n">indegree</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="c1"># Decrease the indegree for the current node
</span>            <span class="n">indegree</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="c1"># If the indegree is negative, return False because the tree is invalid
</span>            <span class="k">if</span> <span class="n">indegree</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="c1"># If the current node is not null, increase the indegree by 2 for its children
</span>            <span class="k">if</span> <span class="n">node</span> <span class="o">!=</span> <span class="s">'#'</span><span class="p">:</span>
                <span class="n">indegree</span> <span class="o">+=</span> <span class="mi">2</span>

        <span class="c1"># Return True if the final indegree is 0
</span>        <span class="k">return</span> <span class="n">indegree</span> <span class="o">==</span> <span class="mi">0</span>

<span class="c1">############
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValidSerialization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preorder</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preorder</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">preorder</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">","</span><span class="p">)</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="s">"#"</span><span class="p">:</span>
                <span class="c1"># after first while loop, current node can be deemed as #
</span>                <span class="k">while</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">"#"</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># pop # in stack
</span>                    <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span><span class="p">:</span> <span class="c1"># should leave a number in stack
</span>                        <span class="k">return</span> <span class="bp">False</span>
                    
                    <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># pop val with left-# and right-#   =&gt;   repalce it with #
</span>            <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">"#"</span>

<span class="c1">############
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValidSerialization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preorder</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">stk</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">preorder</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">","</span><span class="p">):</span>
            <span class="n">stk</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">stk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">stk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">stk</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s">"#"</span> <span class="ow">and</span> <span class="n">stk</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="s">"#"</span><span class="p">:</span>
                <span class="n">stk</span> <span class="o">=</span> <span class="n">stk</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
                <span class="n">stk</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"#"</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">stk</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">stk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">"#"</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">isValidSerialization</span><span class="p">(</span><span class="n">preorder</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="n">stk</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">strings</span><span class="o">.</span><span class="n">Split</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="s">","</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stk</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">stk</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
		<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">stk</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="m">3</span> <span class="o">&amp;&amp;</span> <span class="n">stk</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">stk</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">"#"</span> <span class="o">&amp;&amp;</span> <span class="n">stk</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">stk</span><span class="p">)</span><span class="o">-</span><span class="m">2</span><span class="p">]</span> <span class="o">==</span> <span class="s">"#"</span> <span class="o">&amp;&amp;</span> <span class="n">stk</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">stk</span><span class="p">)</span><span class="o">-</span><span class="m">3</span><span class="p">]</span> <span class="o">!=</span> <span class="s">"#"</span> <span class="p">{</span>
			<span class="n">stk</span> <span class="o">=</span> <span class="n">stk</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">stk</span><span class="p">)</span><span class="o">-</span><span class="m">3</span><span class="p">]</span>
			<span class="n">stk</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">stk</span><span class="p">,</span> <span class="s">"#"</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">stk</span><span class="p">)</span> <span class="o">==</span> <span class="m">1</span> <span class="o">&amp;&amp;</span> <span class="n">stk</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">"#"</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">function</span> <span class="nx">isValidSerialization</span><span class="p">(</span><span class="nx">preorder</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">boolean</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">stk</span><span class="p">:</span> <span class="kr">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">s</span> <span class="k">of</span> <span class="nx">preorder</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">,</span><span class="dl">'</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">stk</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">stk</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="nx">stk</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="nx">stk</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="nx">stk</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">stk</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">stk</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">stk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-331.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
