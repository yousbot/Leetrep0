<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-173.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-173.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>173 - Binary Search Tree Iterator</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode Question Formatted question description: https://leetcode.ca/all/173.html Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST): BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-173.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-173.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-173.html" rel="stylesheet"/>
   <link href="solution-173.html" rel="stylesheet"/>
   <link href="solution-173.html" rel="stylesheet"/>
   <link href="solution-173.html" rel="stylesheet"/>
   <link href="solution-173.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="173 - Binary Search Tree Iterator" property="og:title"/>
   <meta content="Leetcode Question Formatted question description: https://leetcode.ca/all/173.html Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST): BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST. boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false. int next() Moves the pointer to the right, then returns the number at the pointer. Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST. You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called. &amp;nbsp; Example 1: Input [&amp;quot;BSTIterator&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;hasNext&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;hasNext&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;hasNext&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;hasNext&amp;quot;] [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []] Output [null, 3, 7, true, 9, true, 15, true, 20, false] Explanation BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator.next(); // return 3 bSTIterator.next(); // return 7 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 9 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 15 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 20 bSTIterator.hasNext(); // return False &amp;nbsp; Constraints: The number of nodes in the tree is in the range [1, 105]. 0 &amp;lt;= Node.val &amp;lt;= 106 At most 105 calls will be made to hasNext, and next. &amp;nbsp; Follow up: Could you implement next() and hasNext() to run in average O(1) time and use&amp;nbsp;O(h) memory, where h is the height of the tree? Algorithm The non-recursive form of the in-order traversal of the binary tree requires an additional definition of a stack to assist. The building rule of the binary search tree is left&amp;lt;root&amp;lt;right, and the in-order traversal can extract all nodes from small to large. Code Java C++ Python Go TypeScript Javascript RenderScript import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Stack; public class Binary_Search_Tree_Iterator { /** * Definition for binary tree * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ public class BSTIterator { Stack&amp;lt;TreeNode&amp;gt; sk; // @note:@memorize: important feature, min is always going left branch to leaf public BSTIterator(TreeNode root) { sk = new Stack&amp;lt;&amp;gt;(); // all the way to leftmost leaf while (root != null) { sk.push(root); root = root.left; } } /** @return whether we have a next smallest number */ public boolean hasNext() { return !sk.isEmpty(); } /** @return the next smallest number */ public int next() { TreeNode minNode = sk.pop(); TreeNode current = minNode; // update stack, possible next time min is frmo its right-then-left branch if (current.right != null) { current = current.right; // same logic as in constructor while..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-05-21T22:21:01-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-05-21-173-Binary-Search-Tree-Iterator/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-173.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="173 - Binary Search Tree Iterator" property="twitter:title"/>
   <meta content="Leetcode Question Formatted question description: https://leetcode.ca/all/173.html Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST): BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST. boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false. int next() Moves the pointer to the right, then returns the number at the pointer. Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST. You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called. &amp;nbsp; Example 1: Input [&amp;quot;BSTIterator&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;hasNext&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;hasNext&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;hasNext&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;hasNext&amp;quot;] [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []] Output [null, 3, 7, true, 9, true, 15, true, 20, false] Explanation BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator.next(); // return 3 bSTIterator.next(); // return 7 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 9 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 15 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 20 bSTIterator.hasNext(); // return False &amp;nbsp; Constraints: The number of nodes in the tree is in the range [1, 105]. 0 &amp;lt;= Node.val &amp;lt;= 106 At most 105 calls will be made to hasNext, and next. &amp;nbsp; Follow up: Could you implement next() and hasNext() to run in average O(1) time and use&amp;nbsp;O(h) memory, where h is the height of the tree? Algorithm The non-recursive form of the in-order traversal of the binary tree requires an additional definition of a stack to assist. The building rule of the binary search tree is left&amp;lt;root&amp;lt;right, and the in-order traversal can extract all nodes from small to large. Code Java C++ Python Go TypeScript Javascript RenderScript import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Stack; public class Binary_Search_Tree_Iterator { /** * Definition for binary tree * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ public class BSTIterator { Stack&amp;lt;TreeNode&amp;gt; sk; // @note:@memorize: important feature, min is always going left branch to leaf public BSTIterator(TreeNode root) { sk = new Stack&amp;lt;&amp;gt;(); // all the way to leftmost leaf while (root != null) { sk.push(root); root = root.left; } } /** @return whether we have a next smallest number */ public boolean hasNext() { return !sk.isEmpty(); } /** @return the next smallest number */ public int next() { TreeNode minNode = sk.pop(); TreeNode current = minNode; // update stack, possible next time min is frmo its right-then-left branch if (current.right != null) { current = current.right; // same logic as in constructor while..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    173 - Binary Search Tree Iterator | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="173 - Binary Search Tree Iterator" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-173.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-05-21-173-Binary-Search-Tree-Iterator/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-05-21T22:21:01-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"173 - Binary Search Tree Iterator","dateModified":"2016-05-21T22:21:01-07:00","datePublished":"2016-05-21T22:21:01-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-05-21-173-Binary-Search-Tree-Iterator/"},"url":"https://leetcode.ca/2016-05-21-173-Binary-Search-Tree-Iterator/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="question">
       Question
      </h1>
      <p>
       Formatted question description:
       <a href="solution-173.html">
        https://leetcode.ca/all/173.html
       </a>
      </p>
      <p>
       Implement the
       <code>
        BSTIterator
       </code>
       class that represents an iterator over the
       <strong>
        <a href="solution-173.html" target="_blank">
         in-order traversal
        </a>
       </strong>
       of a binary search tree (BST):
      </p>
      <ul>
       <li>
        <code>
         BSTIterator(TreeNode root)
        </code>
        Initializes an object of the
        <code>
         BSTIterator
        </code>
        class. The
        <code>
         root
        </code>
        of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.
       </li>
       <li>
        <code>
         boolean hasNext()
        </code>
        Returns
        <code>
         true
        </code>
        if there exists a number in the traversal to the right of the pointer, otherwise returns
        <code>
         false
        </code>
        .
       </li>
       <li>
        <code>
         int next()
        </code>
        Moves the pointer to the right, then returns the number at the pointer.
       </li>
      </ul>
      <p>
       Notice that by initializing the pointer to a non-existent smallest number, the first call to
       <code>
        next()
       </code>
       will return the smallest element in the BST.
      </p>
      <p>
       You may assume that
       <code>
        next()
       </code>
       calls will always be valid. That is, there will be at least a next number in the in-order traversal when
       <code>
        next()
       </code>
       is called.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0173.Binary%20Search%20Tree%20Iterator/images/bst-tree.png" style="width: 189px; height: 178px;"/>
      </p>
      <pre>
<strong>Input</strong>
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
<strong>Output</strong>
[null, 3, 7, true, 9, true, 15, true, 20, false]

<strong>Explanation</strong>
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next(); // return 3
bSTIterator.next(); // return 7
bSTIterator.hasNext(); // return True
bSTIterator.next(); // return 9
bSTIterator.hasNext(); // return True
bSTIterator.next(); // return 15
bSTIterator.hasNext(); // return True
bSTIterator.next(); // return 20
bSTIterator.hasNext(); // return False

</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the tree is in the range
        <code>
         [1, 10
         <sup>
          5
         </sup>
         ]
        </code>
        .
       </li>
       <li>
        <code>
         0 &lt;= Node.val &lt;= 10
         <sup>
          6
         </sup>
        </code>
       </li>
       <li>
        At most
        <code>
         10
         <sup>
          5
         </sup>
        </code>
        calls will be made to
        <code>
         hasNext
        </code>
        , and
        <code>
         next
        </code>
        .
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong>
        Follow up:
       </strong>
      </p>
      <ul>
       <li>
        Could you implement
        <code>
         next()
        </code>
        and
        <code>
         hasNext()
        </code>
        to run in average
        <code>
         O(1)
        </code>
        time and use
        <code>
         O(h)
        </code>
        memory, where
        <code>
         h
        </code>
        is the height of the tree?
       </li>
      </ul>
      <h1 id="algorithm">
       Algorithm
      </h1>
      <p>
       The non-recursive form of the in-order traversal of the binary tree requires an additional definition of a stack to assist. The building rule of the binary search tree is
       <code class="language-plaintext highlighter-rouge">
        left&lt;root&lt;right
       </code>
       , and the in-order traversal can extract all nodes from small to large.
      </p>
      <h1 id="code">
       Code
      </h1>
      <ul class="uk-tab" data-uk-switcher="{connect:'#7bffaf76-8c8d-4e32-8594-da92f9fc173d'}">
       <li class="uk-active">
        <a href="solution-173.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-173.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-173.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-173.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-173.html">
         TypeScript
        </a>
       </li>
       <li>
        <a href="solution-173.html">
         Javascript
        </a>
       </li>
       <li>
        <a href="solution-173.html">
         RenderScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="7bffaf76-8c8d-4e32-8594-da92f9fc173d">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Collections</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Binary_Search_Tree_Iterator</span> <span class="o">{</span>

    <span class="cm">/**
     * Definition for binary tree
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode(int x) { val = x; }
     * }
     */</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">BSTIterator</span> <span class="o">{</span>

        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">sk</span><span class="o">;</span>

        <span class="c1">// @note:@memorize: important feature, min is always going left branch to leaf</span>
        <span class="kd">public</span> <span class="nf">BSTIterator</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sk</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>

            <span class="c1">// all the way to leftmost leaf</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">sk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span>

        <span class="o">}</span>

        <span class="cm">/** @return whether we have a next smallest number */</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">!</span><span class="n">sk</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="cm">/** @return the next smallest number */</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
            <span class="nc">TreeNode</span> <span class="n">minNode</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>

            <span class="nc">TreeNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">minNode</span><span class="o">;</span>
            <span class="c1">// update stack, possible next time min is frmo its right-then-left branch</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>

                <span class="c1">// same logic as in constructor</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">sk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                    <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="n">minNode</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="cm">/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = new BSTIterator(root);
 * while (i.hasNext()) v[f()] = i.next();
 */</span>
<span class="o">}</span>

<span class="err">############</span>

<span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">BSTIterator</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="nf">BSTIterator</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(;</span> <span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">;</span> <span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cur</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Your BSTIterator object will be instantiated and called as such:
 * BSTIterator obj = new BSTIterator(root);
 * int param_1 = obj.next();
 * boolean param_2 = obj.hasNext();
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1">// OJ: https://leetcode.com/problems/binary-search-tree-iterator/</span>
<span class="c1">// Time: O(1) amortized</span>
<span class="c1">// Space: O(H)</span>
<span class="k">class</span> <span class="nc">BSTIterator</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">s</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">pushNodes</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="nl">public:</span>
    <span class="n">BSTIterator</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pushNodes</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">next</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">pushNodes</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">hasNext</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-python highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">BSTIterator</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_leftmost_inorder</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_leftmost_inorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">right</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_leftmost_inorder</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cur</span><span class="p">.</span><span class="n">val</span>

    <span class="k">def</span> <span class="nf">hasNext</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

<span class="c1"># Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()
</span>
<span class="c1">#############
</span>
<span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">BSTIterator</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">right</span>
        <span class="k">while</span> <span class="n">node</span><span class="p">:</span> <span class="c1"># deplicated while block
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> 
        <span class="k">return</span> <span class="n">cur</span><span class="p">.</span><span class="n">val</span>

    <span class="k">def</span> <span class="nf">hasNext</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>


<span class="c1"># Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()
</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */</span>
<span class="k">type</span> <span class="n">BSTIterator</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">stack</span> <span class="p">[]</span><span class="o">*</span><span class="n">TreeNode</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Constructor</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="n">BSTIterator</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">stack</span> <span class="p">[]</span><span class="o">*</span><span class="n">TreeNode</span>
	<span class="k">for</span> <span class="p">;</span> <span class="n">root</span> <span class="o">!=</span> <span class="no">nil</span><span class="p">;</span> <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">Left</span> <span class="p">{</span>
		<span class="n">stack</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">BSTIterator</span><span class="p">{</span>
		<span class="n">stack</span><span class="o">:</span> <span class="n">stack</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">BSTIterator</span><span class="p">)</span> <span class="n">Next</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">cur</span> <span class="o">:=</span> <span class="n">this</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
	<span class="n">this</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
	<span class="k">for</span> <span class="n">node</span> <span class="o">:=</span> <span class="n">cur</span><span class="o">.</span><span class="n">Right</span><span class="p">;</span> <span class="n">node</span> <span class="o">!=</span> <span class="no">nil</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">Left</span> <span class="p">{</span>
		<span class="n">this</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">stack</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">cur</span><span class="o">.</span><span class="n">Val</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">BSTIterator</span><span class="p">)</span> <span class="n">HasNext</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span>
<span class="p">}</span>

<span class="c">/**
 * Your BSTIterator object will be instantiated and called as such:
 * obj := Constructor(root);
 * param_1 := obj.Next();
 * param_2 := obj.HasNext();
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>

<span class="kd">class</span> <span class="nx">BSTIterator</span> <span class="p">{</span>
    <span class="k">private</span> <span class="nx">stack</span><span class="p">:</span> <span class="nx">TreeNode</span><span class="p">[];</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">stack</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
            <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
        <span class="p">};</span>
        <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">next</span><span class="p">():</span> <span class="kr">number</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="p">{</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">right</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="nx">right</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="nx">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">cur</span><span class="p">);</span>
                <span class="nx">cur</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">left</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">hasNext</span><span class="p">():</span> <span class="nx">boolean</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
 * Your BSTIterator object will be instantiated and called as such:
 * var obj = new BSTIterator(root)
 * var param_1 = obj.next()
 * var param_2 = obj.hasNext()
 */</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-js highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="cm">/**
 * @param {TreeNode} root
 */</span>
<span class="kd">var</span> <span class="nx">BSTIterator</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">stack</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="nx">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">;</span> <span class="nx">root</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**
 * @return {number}
 */</span>
<span class="nx">BSTIterator</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
    <span class="kd">let</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">right</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="nx">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">;</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">val</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**
 * @return {boolean}
 */</span>
<span class="nx">BSTIterator</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasNext</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**
 * Your BSTIterator object will be instantiated and called as such:
 * var obj = new BSTIterator(root)
 * var param_1 = obj.next()
 * var param_2 = obj.hasNext()
 */</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-rs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1">// Definition for a binary tree node.</span>
<span class="c1">// #[derive(Debug, PartialEq, Eq)]</span>
<span class="c1">// pub struct TreeNode {</span>
<span class="c1">//   pub val: i32,</span>
<span class="c1">//   pub left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span>
<span class="c1">//   pub right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span>
<span class="c1">// }</span>
<span class="c1">//</span>
<span class="c1">// impl TreeNode {</span>
<span class="c1">//   #[inline]</span>
<span class="c1">//   pub fn new(val: i32) -&gt; Self {</span>
<span class="c1">//     TreeNode {</span>
<span class="c1">//       val,</span>
<span class="c1">//       left: None,</span>
<span class="c1">//       right: None</span>
<span class="c1">//     }</span>
<span class="c1">//   }</span>
<span class="c1">// }</span>
<span class="k">struct</span> <span class="n">BSTIterator</span> <span class="p">{</span>
    <span class="n">stack</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span>
<span class="cd">/**
 * `&amp;self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&amp;mut self` instead.
 */</span>
<span class="k">impl</span> <span class="n">BSTIterator</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">dfs</span><span class="p">(</span>
        <span class="k">mut</span> <span class="n">root</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
        <span class="n">stack</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">root</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.left</span><span class="nf">.take</span><span class="p">();</span>
            <span class="n">stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
            <span class="k">Self</span><span class="p">::</span><span class="nf">dfs</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">stack</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">stack</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
        <span class="k">Self</span><span class="p">::</span><span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">stack</span><span class="p">);</span>
        <span class="n">BSTIterator</span> <span class="p">{</span> <span class="n">stack</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="nf">.borrow_mut</span><span class="p">();</span>
        <span class="k">if</span> <span class="n">node</span><span class="py">.right</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">::</span><span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="py">.right</span><span class="nf">.take</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.stack</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">node</span><span class="py">.val</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">has_next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.stack</span><span class="nf">.len</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/**
 * Your BSTIterator object will be instantiated and called as such:
 * let obj = BSTIterator::new(root);
 * let ret_1: i32 = obj.next();
 * let ret_2: bool = obj.has_next();
 */</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-173.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
