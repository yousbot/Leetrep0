<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-1506.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-1506.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>1506 - Find Root of N-Ary Tree</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 1506. Find Root of N-Ary Tree Description You are given all the nodes of an N-ary tree as an array of Node objects, where each node has a unique value. Return the root of the N-ary tree. Custom testing: An N-ary tree can be serialized...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-1506.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-1506.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-1506.html" rel="stylesheet"/>
   <link href="solution-1506.html" rel="stylesheet"/>
   <link href="solution-1506.html" rel="stylesheet"/>
   <link href="solution-1506.html" rel="stylesheet"/>
   <link href="solution-1506.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="1506 - Find Root of N-Ary Tree" property="og:title"/>
   <meta content='Leetcode 1506. Find Root of N-Ary Tree Description You are given all the nodes of an N-ary tree as an array of Node objects, where each node has a unique value. Return the root of the N-ary tree. Custom testing: An N-ary tree can be serialized as represented in its level order traversal where each group of children is separated by the null value (see examples). For example, the above tree is serialized as [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]. The testing will be done in the following way: The input data should be provided as a serialization of the tree. The driver code will construct the tree from the serialized input data and put each Node object into an array in an arbitrary order. The driver code will pass the array to findRoot, and your function should find and return the root Node object in the array. The driver code will take the returned Node object and serialize it. If the serialized value and the input data are the same, the test passes. &amp;nbsp; Example 1: Input: tree = [1,null,3,2,4,null,5,6] Output: [1,null,3,2,4,null,5,6] Explanation: The tree from the input data is shown above. The driver code creates the tree and gives findRoot the Node objects in an arbitrary order. For example, the passed array could be [Node(5),Node(4),Node(3),Node(6),Node(2),Node(1)] or [Node(2),Node(6),Node(1),Node(3),Node(5),Node(4)]. The findRoot function should return the root Node(1), and the driver code will serialize it and compare with the input data. The input data and serialized Node(1) are the same, so the test passes. Example 2: Input: tree = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] &amp;nbsp; Constraints: The total number of nodes is between [1, 5 * 104]. Each node has a unique value. &amp;nbsp; Follow up: Could you solve this problem in constant space complexity with a linear time algorithm? Solutions Java C++ Python Go TypeScript /* // Definition for a Node. class Node { public int val; public List&amp;lt;Node&amp;gt; children; public Node() { children = new ArrayList&amp;lt;Node&amp;gt;(); } public Node(int _val) { val = _val; children = new ArrayList&amp;lt;Node&amp;gt;(); } public Node(int _val,ArrayList&amp;lt;Node&amp;gt; _children) { val = _val; children = _children; } }; */ class Solution { public Node findRoot(List&amp;lt;Node&amp;gt; tree) { int x = 0; for (Node node : tree) { x ^= node.val; for (Node child : node.children) { x ^= child.val; } } for (int i = 0;; ++i) { if (tree.get(i).val == x) { return tree.get(i); } } } } /* // Definition for a Node. class Node { public: int val; vector&amp;lt;Node*&amp;gt; children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector&amp;lt;Node*&amp;gt; _children) { val = _val; children = _children; } }; */ class Solution { public: Node* findRoot(vector&amp;lt;Node*&amp;gt; tree) { int x = 0; for (Node* node : tree) { x ^= node-&amp;gt;val; for (Node* child : node-&amp;gt;children) { x ^= child-&amp;gt;val; } } for (int i = 0;; ++i) { if (tree[i]-&amp;gt;val == x) { return tree[i]; } } } }; """ # Definition for a Node. class Node: def __init__(self, val=None, children=None):...' property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2020-01-14T00:00:00-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2020-01-14-1506-Find-Root-of-N-Ary-Tree/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-1506.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="1506 - Find Root of N-Ary Tree" property="twitter:title"/>
   <meta content='Leetcode 1506. Find Root of N-Ary Tree Description You are given all the nodes of an N-ary tree as an array of Node objects, where each node has a unique value. Return the root of the N-ary tree. Custom testing: An N-ary tree can be serialized as represented in its level order traversal where each group of children is separated by the null value (see examples). For example, the above tree is serialized as [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]. The testing will be done in the following way: The input data should be provided as a serialization of the tree. The driver code will construct the tree from the serialized input data and put each Node object into an array in an arbitrary order. The driver code will pass the array to findRoot, and your function should find and return the root Node object in the array. The driver code will take the returned Node object and serialize it. If the serialized value and the input data are the same, the test passes. &amp;nbsp; Example 1: Input: tree = [1,null,3,2,4,null,5,6] Output: [1,null,3,2,4,null,5,6] Explanation: The tree from the input data is shown above. The driver code creates the tree and gives findRoot the Node objects in an arbitrary order. For example, the passed array could be [Node(5),Node(4),Node(3),Node(6),Node(2),Node(1)] or [Node(2),Node(6),Node(1),Node(3),Node(5),Node(4)]. The findRoot function should return the root Node(1), and the driver code will serialize it and compare with the input data. The input data and serialized Node(1) are the same, so the test passes. Example 2: Input: tree = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] &amp;nbsp; Constraints: The total number of nodes is between [1, 5 * 104]. Each node has a unique value. &amp;nbsp; Follow up: Could you solve this problem in constant space complexity with a linear time algorithm? Solutions Java C++ Python Go TypeScript /* // Definition for a Node. class Node { public int val; public List&amp;lt;Node&amp;gt; children; public Node() { children = new ArrayList&amp;lt;Node&amp;gt;(); } public Node(int _val) { val = _val; children = new ArrayList&amp;lt;Node&amp;gt;(); } public Node(int _val,ArrayList&amp;lt;Node&amp;gt; _children) { val = _val; children = _children; } }; */ class Solution { public Node findRoot(List&amp;lt;Node&amp;gt; tree) { int x = 0; for (Node node : tree) { x ^= node.val; for (Node child : node.children) { x ^= child.val; } } for (int i = 0;; ++i) { if (tree.get(i).val == x) { return tree.get(i); } } } } /* // Definition for a Node. class Node { public: int val; vector&amp;lt;Node*&amp;gt; children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector&amp;lt;Node*&amp;gt; _children) { val = _val; children = _children; } }; */ class Solution { public: Node* findRoot(vector&amp;lt;Node*&amp;gt; tree) { int x = 0; for (Node* node : tree) { x ^= node-&amp;gt;val; for (Node* child : node-&amp;gt;children) { x ^= child-&amp;gt;val; } } for (int i = 0;; ++i) { if (tree[i]-&amp;gt;val == x) { return tree[i]; } } } }; """ # Definition for a Node. class Node: def __init__(self, val=None, children=None):...' property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    1506 - Find Root of N-Ary Tree | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="1506 - Find Root of N-Ary Tree" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-1506.html" rel="canonical">
          <meta content="https://leetcode.ca/2020-01-14-1506-Find-Root-of-N-Ary-Tree/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2020-01-14T00:00:00-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"1506 - Find Root of N-Ary Tree","dateModified":"2020-01-14T00:00:00-08:00","datePublished":"2020-01-14T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2020-01-14-1506-Find-Root-of-N-Ary-Tree/"},"url":"https://leetcode.ca/2020-01-14-1506-Find-Root-of-N-Ary-Tree/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="1506-find-root-of-n-ary-tree">
       <a href="solution-1506.html">
        1506. Find Root of N-Ary Tree
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       You are given all the nodes of an
       <strong>
        <a href="solution-1506.html">
         N-ary tree
        </a>
       </strong>
       as an array of
       <code>
        Node
       </code>
       objects, where each node has a
       <strong>
        unique value
       </strong>
       .
      </p>
      <p>
       Return
       <em>
        the
        <strong>
         root
        </strong>
        of the N-ary tree
       </em>
       .
      </p>
      <p>
       <strong>
        Custom testing:
       </strong>
      </p>
      <p>
       An N-ary tree can be serialized as represented in its level order traversal where each group of children is separated by the
       <code>
        null
       </code>
       value (see examples).
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1506.Find%20Root%20of%20N-Ary%20Tree/images/sample_4_964.png" style="width: 296px; height: 241px;"/>
      </p>
      <p>
       For example, the above tree is serialized as
       <code>
        [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
       </code>
       .
      </p>
      <p>
       The testing will be done in the following way:
      </p>
      <ol>
       <li>
        The
        <strong>
         input data
        </strong>
        should be provided as a serialization of the tree.
       </li>
       <li>
        The driver code will construct the tree from the serialized input data and put each
        <code>
         Node
        </code>
        object into an array
        <strong>
         in an arbitrary order
        </strong>
        .
       </li>
       <li>
        The driver code will pass the array to
        <code>
         findRoot
        </code>
        , and your function should find and return the root
        <code>
         Node
        </code>
        object in the array.
       </li>
       <li>
        The driver code will take the returned
        <code>
         Node
        </code>
        object and serialize it. If the serialized value and the input data are the
        <strong>
         same
        </strong>
        , the test
        <strong>
         passes
        </strong>
        .
       </li>
      </ol>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1506.Find%20Root%20of%20N-Ary%20Tree/images/narytreeexample.png" style="width: 100%; max-width: 300px;"/>
      </p>
      <pre>
<strong>Input:</strong> tree = [1,null,3,2,4,null,5,6]
<strong>Output:</strong> [1,null,3,2,4,null,5,6]
<strong>Explanation:</strong> The tree from the input data is shown above.
The driver code creates the tree and gives findRoot the Node objects in an arbitrary order.
For example, the passed array could be [Node(5),Node(4),Node(3),Node(6),Node(2),Node(1)] or [Node(2),Node(6),Node(1),Node(3),Node(5),Node(4)].
The findRoot function should return the root Node(1), and the driver code will serialize it and compare with the input data.
The input data and serialized Node(1) are the same, so the test passes.
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1506.Find%20Root%20of%20N-Ary%20Tree/images/sample_4_964.png" style="width: 296px; height: 241px;"/>
      </p>
      <pre>
<strong>Input:</strong> tree = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
<strong>Output:</strong> [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The total number of nodes is between
        <code>
         [1, 5 * 10
         <sup>
          4
         </sup>
         ]
        </code>
        .
       </li>
       <li>
        Each node has a
        <strong>
         unique
        </strong>
        value.
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong>
        Follow up:
       </strong>
      </p>
      <ul>
       <li>
        Could you solve this problem in constant space complexity with a linear time algorithm?
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <ul class="uk-tab" data-uk-switcher="{connect:'#44907969-9860-426c-b20d-8a68252a6b76'}">
       <li class="uk-active">
        <a href="solution-1506.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-1506.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-1506.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-1506.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-1506.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="44907969-9860-426c-b20d-8a68252a6b76">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/*
// Definition for a Node.
class Node {
    public int val;
    public List&lt;Node&gt; children;


    public Node() {
        children = new ArrayList&lt;Node&gt;();
    }

    public Node(int _val) {
        val = _val;
        children = new ArrayList&lt;Node&gt;();
    }

    public Node(int _val,ArrayList&lt;Node&gt; _children) {
        val = _val;
        children = _children;
    }
};
*/</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">findRoot</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">tree</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span> <span class="n">node</span> <span class="o">:</span> <span class="n">tree</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">x</span> <span class="o">^=</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span> <span class="n">child</span> <span class="o">:</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">x</span> <span class="o">^=</span> <span class="n">child</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">val</span> <span class="o">==</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">tree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/*
// Definition for a Node.
class Node {
public:
    int val;
    vector&lt;Node*&gt; children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector&lt;Node*&gt; _children) {
        val = _val;
        children = _children;
    }
};
*/</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">findRoot</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">:</span> <span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">^=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">child</span> <span class="o">:</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">^=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="s">"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []
"""</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findRoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s">'Node'</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s">'Node'</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">^=</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">^=</span> <span class="n">child</span><span class="p">.</span><span class="n">val</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span> <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Children []*Node
 * }
 */</span>

<span class="k">func</span> <span class="n">findRoot</span><span class="p">(</span><span class="n">tree</span> <span class="p">[]</span><span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="o">*</span><span class="n">Node</span> <span class="p">{</span>
	<span class="n">x</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">node</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">tree</span> <span class="p">{</span>
		<span class="n">x</span> <span class="o">^=</span> <span class="n">node</span><span class="o">.</span><span class="n">Val</span>
		<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">node</span><span class="o">.</span><span class="n">Children</span> <span class="p">{</span>
			<span class="n">x</span> <span class="o">^=</span> <span class="n">child</span><span class="o">.</span><span class="n">Val</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Val</span> <span class="o">==</span> <span class="n">x</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for Node.
 * class Node {
 *     val: number
 *     children: Node[]
 *     constructor(val?: number, children?: Node[]) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.children = (children===undefined ? [] : children)
 *     }
 * }
 */</span>

<span class="kd">function</span> <span class="nx">findRoot</span><span class="p">(</span><span class="nx">tree</span><span class="p">:</span> <span class="nx">Node</span><span class="p">[]):</span> <span class="nx">Node</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">node</span> <span class="k">of</span> <span class="nx">tree</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">x</span> <span class="o">^=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">val</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">child</span> <span class="k">of</span> <span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">x</span> <span class="o">^=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">val</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">node</span> <span class="o">=&gt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">val</span> <span class="o">===</span> <span class="nx">x</span><span class="p">)</span> <span class="o">||</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-1506.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
