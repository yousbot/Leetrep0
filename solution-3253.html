<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-3253.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-3253.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>3253 - Construct String with Minimum Cost (Easy)</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 3253. Construct String with Minimum Cost (Easy) ð Description You are given a string target, an array of strings words, and an integer array costs, both arrays of the same length. Imagine an empty string s. You can perform the following operation any number of...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-3253.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-3253.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-3253.html" rel="stylesheet"/>
   <link href="solution-3253.html" rel="stylesheet"/>
   <link href="solution-3253.html" rel="stylesheet"/>
   <link href="solution-3253.html" rel="stylesheet"/>
   <link href="solution-3253.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="3253 - Construct String with Minimum Cost (Easy)" property="og:title"/>
   <meta content="Leetcode 3253. Construct String with Minimum Cost (Easy) ð Description You are given a string target, an array of strings words, and an integer array costs, both arrays of the same length. Imagine an empty string s. You can perform the following operation any number of times (including zero): Choose an index i in the range [0, words.length - 1]. Append words[i] to s. The cost of operation is costs[i]. Return the minimum cost to make s equal to target. If it&amp;#39;s not possible, return -1. &amp;nbsp; Example 1: Input: target = &amp;quot;abcdef&amp;quot;, words = [&amp;quot;abdef&amp;quot;,&amp;quot;abc&amp;quot;,&amp;quot;d&amp;quot;,&amp;quot;def&amp;quot;,&amp;quot;ef&amp;quot;], costs = [100,1,1,10,5] Output: 7 Explanation: The minimum cost can be achieved by performing the following operations: Select index 1 and append &amp;quot;abc&amp;quot; to s at a cost of 1, resulting in s = &amp;quot;abc&amp;quot;. Select index 2 and append &amp;quot;d&amp;quot; to s at a cost of 1, resulting in s = &amp;quot;abcd&amp;quot;. Select index 4 and append &amp;quot;ef&amp;quot; to s at a cost of 5, resulting in s = &amp;quot;abcdef&amp;quot;. Example 2: Input: target = &amp;quot;aaaa&amp;quot;, words = [&amp;quot;z&amp;quot;,&amp;quot;zz&amp;quot;,&amp;quot;zzz&amp;quot;], costs = [1,10,100] Output: -1 Explanation: It is impossible to make s equal to target, so we return -1. &amp;nbsp; Constraints: 1 &amp;lt;= target.length &amp;lt;= 2000 1 &amp;lt;= words.length == costs.length &amp;lt;= 50 1 &amp;lt;= words[i].length &amp;lt;= target.length target and words[i] consist only of lowercase English letters. 1 &amp;lt;= costs[i] &amp;lt;= 105 Solutions Solution 1: Trie + Memoized Search We first create a Trie $\textit{trie}$, where each node in the Trie contains an array $\textit{children}$ of length $26$, and each element in the array is a pointer to the next node. Each node in the Trie also contains a $\textit{cost}$ variable, which represents the minimum cost from the root node to the current node. We traverse the $\textit{words}$ array, inserting each word into the Trie while updating the $\textit{cost}$ variable for each node. Next, we define a memoized search function $\textit{dfs}(i)$, which represents the minimum cost to construct the string starting from $\textit{target}[i]$. The answer is $\textit{dfs}(0)$. The calculation process of the function $\textit{dfs}(i)$ is as follows: If $i \geq \textit{len}(\textit{target})$, it means the entire string has been constructed, so return $0$. Otherwise, we start from the root node of the $\textit{trie}$ and traverse all suffixes starting from $\textit{target}[i]$, finding the minimum cost, which is the $\textit{cost}$ variable in the $\textit{trie}$, plus the result of $\textit{dfs}(j+1)$, where $j$ is the ending position of the suffix starting from $\textit{target}[i]$. Finally, if $\textit{dfs}(0) &amp;lt; \textit{inf}$, return $\textit{dfs}(0)$; otherwise, return $-1$. The time complexity is $O(n^2 + L)$, and the space complexity is $O(n + L)$. Here, $n$ is the length of $\textit{target}$, and $L$ is the sum of the lengths of all words in the $\textit{words}$ array. Java C++ Python Go TypeScript class Trie { public final int inf = 1 &amp;lt;&amp;lt; 29; public Trie[] children = new Trie[26]; public int cost = inf; public void insert(String word, int cost) { Trie node = this; for (char c : word.toCharArray()) { int..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2024-08-31T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2024-08-31-3253-Construct-String-with-Minimum-Cost-(Easy)/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-3253.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="3253 - Construct String with Minimum Cost (Easy)" property="twitter:title"/>
   <meta content="Leetcode 3253. Construct String with Minimum Cost (Easy) ð Description You are given a string target, an array of strings words, and an integer array costs, both arrays of the same length. Imagine an empty string s. You can perform the following operation any number of times (including zero): Choose an index i in the range [0, words.length - 1]. Append words[i] to s. The cost of operation is costs[i]. Return the minimum cost to make s equal to target. If it&amp;#39;s not possible, return -1. &amp;nbsp; Example 1: Input: target = &amp;quot;abcdef&amp;quot;, words = [&amp;quot;abdef&amp;quot;,&amp;quot;abc&amp;quot;,&amp;quot;d&amp;quot;,&amp;quot;def&amp;quot;,&amp;quot;ef&amp;quot;], costs = [100,1,1,10,5] Output: 7 Explanation: The minimum cost can be achieved by performing the following operations: Select index 1 and append &amp;quot;abc&amp;quot; to s at a cost of 1, resulting in s = &amp;quot;abc&amp;quot;. Select index 2 and append &amp;quot;d&amp;quot; to s at a cost of 1, resulting in s = &amp;quot;abcd&amp;quot;. Select index 4 and append &amp;quot;ef&amp;quot; to s at a cost of 5, resulting in s = &amp;quot;abcdef&amp;quot;. Example 2: Input: target = &amp;quot;aaaa&amp;quot;, words = [&amp;quot;z&amp;quot;,&amp;quot;zz&amp;quot;,&amp;quot;zzz&amp;quot;], costs = [1,10,100] Output: -1 Explanation: It is impossible to make s equal to target, so we return -1. &amp;nbsp; Constraints: 1 &amp;lt;= target.length &amp;lt;= 2000 1 &amp;lt;= words.length == costs.length &amp;lt;= 50 1 &amp;lt;= words[i].length &amp;lt;= target.length target and words[i] consist only of lowercase English letters. 1 &amp;lt;= costs[i] &amp;lt;= 105 Solutions Solution 1: Trie + Memoized Search We first create a Trie $\textit{trie}$, where each node in the Trie contains an array $\textit{children}$ of length $26$, and each element in the array is a pointer to the next node. Each node in the Trie also contains a $\textit{cost}$ variable, which represents the minimum cost from the root node to the current node. We traverse the $\textit{words}$ array, inserting each word into the Trie while updating the $\textit{cost}$ variable for each node. Next, we define a memoized search function $\textit{dfs}(i)$, which represents the minimum cost to construct the string starting from $\textit{target}[i]$. The answer is $\textit{dfs}(0)$. The calculation process of the function $\textit{dfs}(i)$ is as follows: If $i \geq \textit{len}(\textit{target})$, it means the entire string has been constructed, so return $0$. Otherwise, we start from the root node of the $\textit{trie}$ and traverse all suffixes starting from $\textit{target}[i]$, finding the minimum cost, which is the $\textit{cost}$ variable in the $\textit{trie}$, plus the result of $\textit{dfs}(j+1)$, where $j$ is the ending position of the suffix starting from $\textit{target}[i]$. Finally, if $\textit{dfs}(0) &amp;lt; \textit{inf}$, return $\textit{dfs}(0)$; otherwise, return $-1$. The time complexity is $O(n^2 + L)$, and the space complexity is $O(n + L)$. Here, $n$ is the length of $\textit{target}$, and $L$ is the sum of the lengths of all words in the $\textit{words}$ array. Java C++ Python Go TypeScript class Trie { public final int inf = 1 &amp;lt;&amp;lt; 29; public Trie[] children = new Trie[26]; public int cost = inf; public void insert(String word, int cost) { Trie node = this; for (char c : word.toCharArray()) { int..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    3253 - Construct String with Minimum Cost (Easy) | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="3253 - Construct String with Minimum Cost (Easy)" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-3253.html" rel="canonical">
          <meta content="https://leetcode.ca/2024-08-31-3253-Construct-String-with-Minimum-Cost-(Easy)/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2024-08-31T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"3253 - Construct String with Minimum Cost (Easy)","dateModified":"2024-08-31T00:00:00-07:00","datePublished":"2024-08-31T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2024-08-31-3253-Construct-String-with-Minimum-Cost-(Easy)/"},"url":"https://leetcode.ca/2024-08-31-3253-Construct-String-with-Minimum-Cost-(Easy)/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <!-- problem:start -->
      <h1 id="3253-construct-string-with-minimum-cost-easy-">
       <a href="solution-3253.html">
        3253. Construct String with Minimum Cost (Easy) ð
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <!-- description:start -->
      <p>
       You are given a string
       <code>
        target
       </code>
       , an array of strings
       <code>
        words
       </code>
       , and an integer array
       <code>
        costs
       </code>
       , both arrays of the same length.
      </p>
      <p>
       Imagine an empty string
       <code>
        s
       </code>
       .
      </p>
      <p>
       You can perform the following operation any number of times (including
       <strong>
        zero
       </strong>
       ):
      </p>
      <ul>
       <li>
        Choose an index
        <code>
         i
        </code>
        in the range
        <code>
         [0, words.length - 1]
        </code>
        .
       </li>
       <li>
        Append
        <code>
         words[i]
        </code>
        to
        <code>
         s
        </code>
        .
       </li>
       <li>
        The cost of operation is
        <code>
         costs[i]
        </code>
        .
       </li>
      </ul>
      <p>
       Return the
       <strong>
        minimum
       </strong>
       cost to make
       <code>
        s
       </code>
       equal to
       <code>
        target
       </code>
       . If it's not possible, return -1.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <div class="example-block">
       <p>
        <strong>
         Input:
        </strong>
        <span class="example-io">
         target = "abcdef", words = ["abdef","abc","d","def","ef"], costs = [100,1,1,10,5]
        </span>
       </p>
       <p>
        <strong>
         Output:
        </strong>
        <span class="example-io">
         7
        </span>
       </p>
       <p>
        <strong>
         Explanation:
        </strong>
       </p>
       <p>
        The minimum cost can be achieved by performing the following operations:
       </p>
       <ul>
        <li>
         Select index 1 and append
         <code>
          "abc"
         </code>
         to
         <code>
          s
         </code>
         at a cost of 1, resulting in
         <code>
          s = "abc"
         </code>
         .
        </li>
        <li>
         Select index 2 and append
         <code>
          "d"
         </code>
         to
         <code>
          s
         </code>
         at a cost of 1, resulting in
         <code>
          s = "abcd"
         </code>
         .
        </li>
        <li>
         Select index 4 and append
         <code>
          "ef"
         </code>
         to
         <code>
          s
         </code>
         at a cost of 5, resulting in
         <code>
          s = "abcdef"
         </code>
         .
        </li>
       </ul>
      </div>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <div class="example-block">
       <p>
        <strong>
         Input:
        </strong>
        <span class="example-io">
         target = "aaaa", words = ["z","zz","zzz"], costs = [1,10,100]
        </span>
       </p>
       <p>
        <strong>
         Output:
        </strong>
        <span class="example-io">
         -1
        </span>
       </p>
       <p>
        <strong>
         Explanation:
        </strong>
       </p>
       <p>
        It is impossible to make
        <code>
         s
        </code>
        equal to
        <code>
         target
        </code>
        , so we return -1.
       </p>
      </div>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= target.length &lt;= 2000
        </code>
       </li>
       <li>
        <code>
         1 &lt;= words.length == costs.length &lt;= 50
        </code>
       </li>
       <li>
        <code>
         1 &lt;= words[i].length &lt;= target.length
        </code>
       </li>
       <li>
        <code>
         target
        </code>
        and
        <code>
         words[i]
        </code>
        consist only of lowercase English letters.
       </li>
       <li>
        <code>
         1 &lt;= costs[i] &lt;= 10
         <sup>
          5
         </sup>
        </code>
       </li>
      </ul>
      <!-- description:end -->
      <h2 id="solutions">
       Solutions
      </h2>
      <!-- solution:start -->
      <h3 id="solution-1-trie--memoized-search">
       Solution 1: Trie + Memoized Search
      </h3>
      <p>
       We first create a Trie $\textit{trie}$, where each node in the Trie contains an array $\textit{children}$ of length $26$, and each element in the array is a pointer to the next node. Each node in the Trie also contains a $\textit{cost}$ variable, which represents the minimum cost from the root node to the current node.
      </p>
      <p>
       We traverse the $\textit{words}$ array, inserting each word into the Trie while updating the $\textit{cost}$ variable for each node.
      </p>
      <p>
       Next, we define a memoized search function $\textit{dfs}(i)$, which represents the minimum cost to construct the string starting from $\textit{target}[i]$. The answer is $\textit{dfs}(0)$.
      </p>
      <p>
       The calculation process of the function $\textit{dfs}(i)$ is as follows:
      </p>
      <ul>
       <li>
        If $i \geq \textit{len}(\textit{target})$, it means the entire string has been constructed, so return $0$.
       </li>
       <li>
        Otherwise, we start from the root node of the $\textit{trie}$ and traverse all suffixes starting from $\textit{target}[i]$, finding the minimum cost, which is the $\textit{cost}$ variable in the $\textit{trie}$, plus the result of $\textit{dfs}(j+1)$, where $j$ is the ending position of the suffix starting from $\textit{target}[i]$.
       </li>
      </ul>
      <p>
       Finally, if $\textit{dfs}(0) &lt; \textit{inf}$, return $\textit{dfs}(0)$; otherwise, return $-1$.
      </p>
      <p>
       The time complexity is $O(n^2 + L)$, and the space complexity is $O(n + L)$. Here, $n$ is the length of $\textit{target}$, and $L$ is the sum of the lengths of all words in the $\textit{words}$ array.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#4c0f3823-62cc-4991-959e-a6a153764dcf'}">
       <li class="uk-active">
        <a href="solution-3253.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-3253.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-3253.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-3253.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-3253.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="4c0f3823-62cc-4991-959e-a6a153764dcf">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Trie</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">inf</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">29</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">Trie</span><span class="o">[]</span> <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Trie</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">inf</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cost</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Trie</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">node</span><span class="o">.</span><span class="na">cost</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">cost</span><span class="o">,</span> <span class="n">cost</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Trie</span> <span class="n">trie</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Trie</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kt">char</span><span class="o">[]</span> <span class="n">target</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Integer</span><span class="o">[]</span> <span class="n">f</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minimumCost</span><span class="o">(</span><span class="nc">String</span> <span class="n">target</span><span class="o">,</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">costs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">trie</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">costs</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Integer</span><span class="o">[</span><span class="n">target</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">ans</span> <span class="o">&lt;</span> <span class="n">trie</span><span class="o">.</span><span class="na">inf</span> <span class="o">?</span> <span class="n">ans</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">trie</span><span class="o">.</span><span class="na">inf</span><span class="o">;</span>
        <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="n">trie</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">target</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
            <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">node</span><span class="o">.</span><span class="na">cost</span> <span class="o">+</span> <span class="n">dfs</span><span class="o">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">inf</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">29</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Trie</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Trie</span><span class="o">*</span> <span class="n">children</span><span class="p">[</span><span class="mi">26</span><span class="p">]{};</span>
    <span class="kt">int</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">inf</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">word</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cost</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Trie</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Trie</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">cost</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">cost</span><span class="p">,</span> <span class="n">cost</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">minimumCost</span><span class="p">(</span><span class="n">string</span> <span class="n">target</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">words</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">costs</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Trie</span><span class="o">*</span> <span class="n">trie</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Trie</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">trie</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
        <span class="k">auto</span> <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">dfs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">inf</span><span class="p">;</span>
            <span class="n">Trie</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">trie</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">cost</span> <span class="o">+</span> <span class="n">dfs</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">};</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ans</span> <span class="o">&lt;</span> <span class="n">inf</span> <span class="o">?</span> <span class="n">ans</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Trie</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cost</span> <span class="o">=</span> <span class="n">inf</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">cost</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">node</span><span class="p">.</span><span class="n">cost</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">cost</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minimumCost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">words</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">costs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="o">@</span><span class="n">cache</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">inf</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">trie</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">ans</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">cost</span> <span class="o">+</span> <span class="n">dfs</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">ans</span>

        <span class="n">trie</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">word</span><span class="p">,</span> <span class="n">cost</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="n">costs</span><span class="p">):</span>
            <span class="n">trie</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span> <span class="k">if</span> <span class="n">ans</span> <span class="o">&lt;</span> <span class="n">inf</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">const</span> <span class="n">inf</span> <span class="o">=</span> <span class="m">1</span> <span class="o">&lt;&lt;</span> <span class="m">29</span>

<span class="k">type</span> <span class="n">Trie</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">children</span> <span class="p">[</span><span class="m">26</span><span class="p">]</span><span class="o">*</span><span class="n">Trie</span>
	<span class="n">cost</span>     <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewTrie</span><span class="p">()</span> <span class="o">*</span><span class="n">Trie</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">Trie</span><span class="p">{</span><span class="n">cost</span><span class="o">:</span> <span class="n">inf</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">Trie</span><span class="p">)</span> <span class="n">insert</span><span class="p">(</span><span class="n">word</span> <span class="kt">string</span><span class="p">,</span> <span class="n">cost</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">t</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">word</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">:=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span>
		<span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">NewTrie</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="n">node</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">cost</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">minimumCost</span><span class="p">(</span><span class="n">target</span> <span class="kt">string</span><span class="p">,</span> <span class="n">words</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="n">costs</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">trie</span> <span class="o">:=</span> <span class="n">NewTrie</span><span class="p">()</span>
	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">word</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">words</span> <span class="p">{</span>
		<span class="n">trie</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
	<span class="p">}</span>

	<span class="n">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
	<span class="n">f</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="p">{</span>
			<span class="k">return</span> <span class="m">0</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">inf</span>
		<span class="n">node</span> <span class="o">:=</span> <span class="n">trie</span>
		<span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">idx</span> <span class="o">:=</span> <span class="n">target</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span>
			<span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
			<span class="p">}</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
			<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">node</span><span class="o">.</span><span class="n">cost</span><span class="o">+</span><span class="n">dfs</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="m">1</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="n">ans</span> <span class="o">:=</span> <span class="n">dfs</span><span class="p">(</span><span class="m">0</span><span class="p">);</span> <span class="n">ans</span> <span class="o">&lt;</span> <span class="n">inf</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ans</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="m">1</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">const</span> <span class="nx">inf</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">29</span><span class="p">;</span>

<span class="kd">class</span> <span class="nx">Trie</span> <span class="p">{</span>
    <span class="nl">children</span><span class="p">:</span> <span class="p">(</span><span class="nx">Trie</span> <span class="o">|</span> <span class="kc">null</span><span class="p">)[];</span>
    <span class="nl">cost</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

    <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">children</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">26</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">cost</span> <span class="o">=</span> <span class="nx">inf</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">insert</span><span class="p">(</span><span class="nx">word</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">cost</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="na">node</span><span class="p">:</span> <span class="nx">Trie</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">c</span> <span class="k">of</span> <span class="nx">word</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">idx</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">97</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">idx</span><span class="p">])</span> <span class="p">{</span>
                <span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Trie</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span><span class="o">!</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">cost</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">cost</span><span class="p">,</span> <span class="nx">cost</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">minimumCost</span><span class="p">(</span><span class="nx">target</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">words</span><span class="p">:</span> <span class="kr">string</span><span class="p">[],</span> <span class="nx">costs</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">trie</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Trie</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">words</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">trie</span><span class="p">.</span><span class="nx">insert</span><span class="p">(</span><span class="nx">words</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">costs</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">target</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">f</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">n</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">i</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">f</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">f</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="nx">f</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">inf</span><span class="p">;</span>
        <span class="kd">let</span> <span class="na">node</span><span class="p">:</span> <span class="nx">Trie</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="nx">trie</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="o">++</span><span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">idx</span> <span class="o">=</span> <span class="nx">target</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span> <span class="o">-</span> <span class="mi">97</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">?.</span><span class="nx">children</span><span class="p">[</span><span class="nx">idx</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">f</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">idx</span><span class="p">];</span>
            <span class="nx">f</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">f</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">node</span><span class="o">!</span><span class="p">.</span><span class="nx">cost</span> <span class="o">+</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">f</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="p">};</span>

    <span class="kd">const</span> <span class="nx">ans</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">ans</span> <span class="o">&lt;</span> <span class="nx">inf</span> <span class="p">?</span> <span class="nx">ans</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-3253.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
