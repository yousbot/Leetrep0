<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-1722.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-1722.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>1722 - Minimize Hamming Distance After Swap Operations</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 1722. Minimize Hamming Distance After Swap Operations Description You are given two integer arrays, source and target, both of length n. You are also given an array allowedSwaps where each allowedSwaps[i] = [ai, bi] indicates that you are allowed to swap the elements at index...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-1722.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-1722.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-1722.html" rel="stylesheet"/>
   <link href="solution-1722.html" rel="stylesheet"/>
   <link href="solution-1722.html" rel="stylesheet"/>
   <link href="solution-1722.html" rel="stylesheet"/>
   <link href="solution-1722.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="1722 - Minimize Hamming Distance After Swap Operations" property="og:title"/>
   <meta content="Leetcode 1722. Minimize Hamming Distance After Swap Operations Description You are given two integer arrays, source and target, both of length n. You are also given an array allowedSwaps where each allowedSwaps[i] = [ai, bi] indicates that you are allowed to swap the elements at index ai and index bi (0-indexed) of array source. Note that you can swap elements at a specific pair of indices multiple times and in any order. The Hamming distance of two arrays of the same length, source and target, is the number of positions where the elements are different. Formally, it is the number of indices i for 0 &amp;lt;= i &amp;lt;= n-1 where source[i] != target[i] (0-indexed). Return the minimum Hamming distance of source and target after performing any amount of swap operations on array source. &amp;nbsp; Example 1: Input: source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]] Output: 1 Explanation: source can be transformed the following way: - Swap indices 0 and 1: source = [2,1,3,4] - Swap indices 2 and 3: source = [2,1,4,3] The Hamming distance of source and target is 1 as they differ in 1 position: index 3. Example 2: Input: source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = [] Output: 2 Explanation: There are no allowed swaps. The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2. Example 3: Input: source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]] Output: 0 &amp;nbsp; Constraints: n == source.length == target.length 1 &amp;lt;= n &amp;lt;= 105 1 &amp;lt;= source[i], target[i] &amp;lt;= 105 0 &amp;lt;= allowedSwaps.length &amp;lt;= 105 allowedSwaps[i].length == 2 0 &amp;lt;= ai, bi &amp;lt;= n - 1 ai != bi Solutions Solution 1: Union-Find + Hash Table We can consider each index as a node, and the element corresponding to each index as the value of the node. Then each element [a_i, b_i] in the given allowedSwaps represents an edge between index a_i and b_i. Therefore, we can use a union-find set to maintain these connected components. After obtaining each connected component, we use a two-dimensional hash table $cnt$ to count the number of occurrences of each element in each connected component. Finally, for each element in the array target, if its occurrence count in the corresponding connected component is greater than 0, we decrease its count by 1, otherwise, we increase the answer by 1. The time complexity is $O(n \times \log n)$ or $O(n \times \alpha(n))$, and the space complexity is $O(n)$. Here, $n$ is the length of the array, and $\alpha$ is the inverse Ackermann function. Java C++ Python Go TypeScript class Solution { private int[] p; public int minimumHammingDistance(int[] source, int[] target, int[][] allowedSwaps) { int n = source.length; p = new int[n]; for (int i = 0; i &amp;lt; n; i++) { p[i] = i; } for (int[] a : allowedSwaps) { p[find(a[0])] = find(a[1]); } Map&amp;lt;Integer, Map&amp;lt;Integer, Integer&amp;gt;&amp;gt; cnt = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2020-08-17T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2020-08-17-1722-Minimize-Hamming-Distance-After-Swap-Operations/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-1722.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="1722 - Minimize Hamming Distance After Swap Operations" property="twitter:title"/>
   <meta content="Leetcode 1722. Minimize Hamming Distance After Swap Operations Description You are given two integer arrays, source and target, both of length n. You are also given an array allowedSwaps where each allowedSwaps[i] = [ai, bi] indicates that you are allowed to swap the elements at index ai and index bi (0-indexed) of array source. Note that you can swap elements at a specific pair of indices multiple times and in any order. The Hamming distance of two arrays of the same length, source and target, is the number of positions where the elements are different. Formally, it is the number of indices i for 0 &amp;lt;= i &amp;lt;= n-1 where source[i] != target[i] (0-indexed). Return the minimum Hamming distance of source and target after performing any amount of swap operations on array source. &amp;nbsp; Example 1: Input: source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]] Output: 1 Explanation: source can be transformed the following way: - Swap indices 0 and 1: source = [2,1,3,4] - Swap indices 2 and 3: source = [2,1,4,3] The Hamming distance of source and target is 1 as they differ in 1 position: index 3. Example 2: Input: source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = [] Output: 2 Explanation: There are no allowed swaps. The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2. Example 3: Input: source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]] Output: 0 &amp;nbsp; Constraints: n == source.length == target.length 1 &amp;lt;= n &amp;lt;= 105 1 &amp;lt;= source[i], target[i] &amp;lt;= 105 0 &amp;lt;= allowedSwaps.length &amp;lt;= 105 allowedSwaps[i].length == 2 0 &amp;lt;= ai, bi &amp;lt;= n - 1 ai != bi Solutions Solution 1: Union-Find + Hash Table We can consider each index as a node, and the element corresponding to each index as the value of the node. Then each element [a_i, b_i] in the given allowedSwaps represents an edge between index a_i and b_i. Therefore, we can use a union-find set to maintain these connected components. After obtaining each connected component, we use a two-dimensional hash table $cnt$ to count the number of occurrences of each element in each connected component. Finally, for each element in the array target, if its occurrence count in the corresponding connected component is greater than 0, we decrease its count by 1, otherwise, we increase the answer by 1. The time complexity is $O(n \times \log n)$ or $O(n \times \alpha(n))$, and the space complexity is $O(n)$. Here, $n$ is the length of the array, and $\alpha$ is the inverse Ackermann function. Java C++ Python Go TypeScript class Solution { private int[] p; public int minimumHammingDistance(int[] source, int[] target, int[][] allowedSwaps) { int n = source.length; p = new int[n]; for (int i = 0; i &amp;lt; n; i++) { p[i] = i; } for (int[] a : allowedSwaps) { p[find(a[0])] = find(a[1]); } Map&amp;lt;Integer, Map&amp;lt;Integer, Integer&amp;gt;&amp;gt; cnt = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    1722 - Minimize Hamming Distance After Swap Operations | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="1722 - Minimize Hamming Distance After Swap Operations" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-1722.html" rel="canonical">
          <meta content="https://leetcode.ca/2020-08-17-1722-Minimize-Hamming-Distance-After-Swap-Operations/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2020-08-17T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"1722 - Minimize Hamming Distance After Swap Operations","dateModified":"2020-08-17T00:00:00-07:00","datePublished":"2020-08-17T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2020-08-17-1722-Minimize-Hamming-Distance-After-Swap-Operations/"},"url":"https://leetcode.ca/2020-08-17-1722-Minimize-Hamming-Distance-After-Swap-Operations/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="1722-minimize-hamming-distance-after-swap-operations">
       <a href="solution-1722.html">
        1722. Minimize Hamming Distance After Swap Operations
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       You are given two integer arrays,
       <code>
        source
       </code>
       and
       <code>
        target
       </code>
       , both of length
       <code>
        n
       </code>
       . You are also given an array
       <code>
        allowedSwaps
       </code>
       where each
       <code>
        allowedSwaps[i] = [a
        <sub>
         i
        </sub>
        , b
        <sub>
         i
        </sub>
        ]
       </code>
       indicates that you are allowed to swap the elements at index
       <code>
        a
        <sub>
         i
        </sub>
       </code>
       and index
       <code>
        b
        <sub>
         i
        </sub>
       </code>
       <strong>
        (0-indexed)
       </strong>
       of array
       <code>
        source
       </code>
       . Note that you can swap elements at a specific pair of indices
       <strong>
        multiple
       </strong>
       times and in
       <strong>
        any
       </strong>
       order.
      </p>
      <p>
       The
       <strong>
        Hamming distance
       </strong>
       of two arrays of the same length,
       <code>
        source
       </code>
       and
       <code>
        target
       </code>
       , is the number of positions where the elements are different. Formally, it is the number of indices
       <code>
        i
       </code>
       for
       <code>
        0 &lt;= i &lt;= n-1
       </code>
       where
       <code>
        source[i] != target[i]
       </code>
       <strong>
        (0-indexed)
       </strong>
       .
      </p>
      <p>
       Return
       <em>
        the
        <strong>
         minimum Hamming distance
        </strong>
        of
       </em>
       <code>
        source
       </code>
       <em>
        and
       </em>
       <code>
        target
       </code>
       <em>
        after performing
        <strong>
         any
        </strong>
        amount of swap operations on array
       </em>
       <code>
        source
       </code>
       <em>
        .
       </em>
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> source can be transformed the following way:
- Swap indices 0 and 1: source = [<u>2</u>,<u>1</u>,3,4]
- Swap indices 2 and 3: source = [2,1,<u>4</u>,<u>3</u>]
The Hamming distance of source and target is 1 as they differ in 1 position: index 3.
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = []
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are no allowed swaps.
The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2.
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]]
<strong>Output:</strong> 0
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         n == source.length == target.length
        </code>
       </li>
       <li>
        <code>
         1 &lt;= n &lt;= 10
         <sup>
          5
         </sup>
        </code>
       </li>
       <li>
        <code>
         1 &lt;= source[i], target[i] &lt;= 10
         <sup>
          5
         </sup>
        </code>
       </li>
       <li>
        <code>
         0 &lt;= allowedSwaps.length &lt;= 10
         <sup>
          5
         </sup>
        </code>
       </li>
       <li>
        <code>
         allowedSwaps[i].length == 2
        </code>
       </li>
       <li>
        <code>
         0 &lt;= a
         <sub>
          i
         </sub>
         , b
         <sub>
          i
         </sub>
         &lt;= n - 1
        </code>
       </li>
       <li>
        <code>
         a
         <sub>
          i
         </sub>
         != b
         <sub>
          i
         </sub>
        </code>
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       <strong>
        Solution 1: Union-Find + Hash Table
       </strong>
      </p>
      <p>
       We can consider each index as a node, and the element corresponding to each index as the value of the node. Then each element
       <code class="language-plaintext highlighter-rouge">
        [a_i, b_i]
       </code>
       in the given
       <code class="language-plaintext highlighter-rouge">
        allowedSwaps
       </code>
       represents an edge between index
       <code class="language-plaintext highlighter-rouge">
        a_i
       </code>
       and
       <code class="language-plaintext highlighter-rouge">
        b_i
       </code>
       . Therefore, we can use a union-find set to maintain these connected components.
      </p>
      <p>
       After obtaining each connected component, we use a two-dimensional hash table $cnt$ to count the number of occurrences of each element in each connected component. Finally, for each element in the array
       <code class="language-plaintext highlighter-rouge">
        target
       </code>
       , if its occurrence count in the corresponding connected component is greater than 0, we decrease its count by 1, otherwise, we increase the answer by 1.
      </p>
      <p>
       The time complexity is $O(n \times \log n)$ or $O(n \times \alpha(n))$, and the space complexity is $O(n)$. Here, $n$ is the length of the array, and $\alpha$ is the inverse Ackermann function.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#f876eb8f-ef9f-4f33-a540-3664fb232e31'}">
       <li class="uk-active">
        <a href="solution-1722.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-1722.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-1722.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-1722.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-1722.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="f876eb8f-ef9f-4f33-a540-3664fb232e31">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">p</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minimumHammingDistance</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">source</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">target</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">allowedSwaps</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">:</span> <span class="n">allowedSwaps</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">p</span><span class="o">[</span><span class="n">find</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">])]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">cnt</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;()).</span><span class="na">merge</span><span class="o">(</span><span class="n">source</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">1</span><span class="o">,</span> <span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">target</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">++</span><span class="n">ans</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">!=</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">p</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">[</span><span class="n">x</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">minimumHammingDistance</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">allowedSwaps</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">source</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">iota</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">p</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">find</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
        <span class="p">};</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">:</span> <span class="n">allowedSwaps</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">p</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">cnt</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">++</span><span class="n">cnt</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">i</span><span class="p">)][</span><span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">cnt</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">i</span><span class="p">)][</span><span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">++</span><span class="n">ans</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minimumHammingDistance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">allowedSwaps</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">allowedSwaps</span><span class="p">:</span>
            <span class="n">p</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">Counter</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">cnt</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">cnt</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">ans</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">minimumHammingDistance</span><span class="p">(</span><span class="n">source</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">target</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">allowedSwaps</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">ans</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
	<span class="n">p</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">p</span> <span class="p">{</span>
		<span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
	<span class="p">}</span>
	<span class="k">var</span> <span class="n">find</span> <span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
	<span class="n">find</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span> <span class="p">{</span>
			<span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">a</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">allowedSwaps</span> <span class="p">{</span>
		<span class="n">p</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="m">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="m">1</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="n">cnt</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">source</span> <span class="p">{</span>
		<span class="n">j</span> <span class="o">:=</span> <span class="n">find</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">cnt</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">cnt</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
		<span class="p">}</span>
		<span class="n">cnt</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">x</span><span class="p">]</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">target</span> <span class="p">{</span>
		<span class="n">j</span> <span class="o">:=</span> <span class="n">find</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">cnt</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">x</span><span class="p">]</span><span class="o">--</span>
		<span class="k">if</span> <span class="n">cnt</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">ans</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">function</span> <span class="nx">minimumHammingDistance</span><span class="p">(</span>
    <span class="nx">source</span><span class="p">:</span> <span class="kr">number</span><span class="p">[],</span>
    <span class="nx">target</span><span class="p">:</span> <span class="kr">number</span><span class="p">[],</span>
    <span class="nx">allowedSwaps</span><span class="p">:</span> <span class="kr">number</span><span class="p">[][],</span>
<span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">source</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">p</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">({</span> <span class="na">length</span><span class="p">:</span> <span class="nx">n</span> <span class="p">},</span> <span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">i</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">find</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">p</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">p</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">p</span><span class="p">[</span><span class="nx">x</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">p</span><span class="p">[</span><span class="nx">x</span><span class="p">];</span>
    <span class="p">};</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="k">of</span> <span class="nx">allowedSwaps</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">p</span><span class="p">[</span><span class="nx">find</span><span class="p">(</span><span class="nx">a</span><span class="p">)]</span> <span class="o">=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">cnt</span><span class="p">:</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="kr">number</span><span class="p">,</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="kr">number</span><span class="p">,</span> <span class="kr">number</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">cnt</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">j</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">cnt</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="kd">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">cnt</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span><span class="o">!</span><span class="p">;</span>
        <span class="nx">m</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">source</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">source</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">??</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">cnt</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span><span class="o">!</span><span class="p">;</span>
        <span class="nx">m</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">target</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">target</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">??</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">target</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span><span class="o">!</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">++</span><span class="nx">ans</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">ans</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-1722.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
