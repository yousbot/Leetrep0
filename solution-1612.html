<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-1612.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-1612.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>1612 - Check If Two Expression Trees are Equivalent</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 1612. Check If Two Expression Trees are Equivalent Description A binary expression tree is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-1612.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-1612.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-1612.html" rel="stylesheet"/>
   <link href="solution-1612.html" rel="stylesheet"/>
   <link href="solution-1612.html" rel="stylesheet"/>
   <link href="solution-1612.html" rel="stylesheet"/>
   <link href="solution-1612.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="1612 - Check If Two Expression Trees are Equivalent" property="og:title"/>
   <meta content="Leetcode 1612. Check If Two Expression Trees are Equivalent Description A binary expression tree is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to operands (variables), and internal nodes (nodes with two children) correspond to the operators. In this problem, we only consider the &amp;#39;+&amp;#39; operator (i.e. addition). You are given the roots of two binary expression trees, root1 and root2. Return true if the two binary expression trees are equivalent. Otherwise, return false. Two binary expression trees are equivalent if they evaluate to the same value regardless of what the variables are set to. &amp;nbsp; Example 1: Input: root1 = [x], root2 = [x] Output: true Example 2: Input: root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,c] Output: true Explanation: a + (b + c) == (b + c) + a Example 3: Input: root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,d] Output: false Explanation: a + (b + c) != (b + d) + a &amp;nbsp; Constraints: The number of nodes in both trees are equal, odd and, in the range [1, 4999]. Node.val is &amp;#39;+&amp;#39; or a lower-case English letter. It&amp;#39;s guaranteed that the tree given is a valid binary expression tree. &amp;nbsp; Follow up: What will you change in your solution if the tree also supports the &amp;#39;-&amp;#39; operator (i.e. subtraction)? Solutions Just count the type and number of letters in the two expression trees. Because itâs + only, (a+b)+c is same as a+(b+c) Follow up question What will you change in your solution if the tree also supports the â-â operator (i.e. subtraction). Then use 2 maps, one for + records, and one for - records. Java C++ Python Javascript /** * Definition for a binary tree node. * class Node { * char val; * Node left; * Node right; * Node() {this.val = ' ';} * Node(char val) { this.val = val; } * Node(char val, Node left, Node right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { private int[] cnt = new int[26]; public boolean checkEquivalence(Node root1, Node root2) { dfs(root1, 1); dfs(root2, -1); for (int x : cnt) { if (x != 0) { return false; } } return true; } private void dfs(Node root, int v) { if (root == null) { return; } if (root.val != '+') { cnt[root.val - 'a'] += v; } dfs(root.left, v); dfs(root.right, v); } } ////// // if '-' supported, then it's just (-1*X) // 2 maps, one for + , and one for - class Solution_followup { public boolean checkEquivalence(Node root1, Node root2) { int[] countPlus = new int[26]; int[] countMinus = new int[26]; dfs(root1, countPlus, countMinus, 1, false); dfs(root2, countPlus, countMinus, -1, false); for (int i = 0; i &amp;lt; countPlus.length; i++) { if (countPlus[i] != 0) { return false; } } for (int i = 0;..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2020-04-29T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2020-04-29-1612-Check-If-Two-Expression-Trees-are-Equivalent/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-1612.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="1612 - Check If Two Expression Trees are Equivalent" property="twitter:title"/>
   <meta content="Leetcode 1612. Check If Two Expression Trees are Equivalent Description A binary expression tree is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to operands (variables), and internal nodes (nodes with two children) correspond to the operators. In this problem, we only consider the &amp;#39;+&amp;#39; operator (i.e. addition). You are given the roots of two binary expression trees, root1 and root2. Return true if the two binary expression trees are equivalent. Otherwise, return false. Two binary expression trees are equivalent if they evaluate to the same value regardless of what the variables are set to. &amp;nbsp; Example 1: Input: root1 = [x], root2 = [x] Output: true Example 2: Input: root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,c] Output: true Explanation: a + (b + c) == (b + c) + a Example 3: Input: root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,d] Output: false Explanation: a + (b + c) != (b + d) + a &amp;nbsp; Constraints: The number of nodes in both trees are equal, odd and, in the range [1, 4999]. Node.val is &amp;#39;+&amp;#39; or a lower-case English letter. It&amp;#39;s guaranteed that the tree given is a valid binary expression tree. &amp;nbsp; Follow up: What will you change in your solution if the tree also supports the &amp;#39;-&amp;#39; operator (i.e. subtraction)? Solutions Just count the type and number of letters in the two expression trees. Because itâs + only, (a+b)+c is same as a+(b+c) Follow up question What will you change in your solution if the tree also supports the â-â operator (i.e. subtraction). Then use 2 maps, one for + records, and one for - records. Java C++ Python Javascript /** * Definition for a binary tree node. * class Node { * char val; * Node left; * Node right; * Node() {this.val = ' ';} * Node(char val) { this.val = val; } * Node(char val, Node left, Node right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { private int[] cnt = new int[26]; public boolean checkEquivalence(Node root1, Node root2) { dfs(root1, 1); dfs(root2, -1); for (int x : cnt) { if (x != 0) { return false; } } return true; } private void dfs(Node root, int v) { if (root == null) { return; } if (root.val != '+') { cnt[root.val - 'a'] += v; } dfs(root.left, v); dfs(root.right, v); } } ////// // if '-' supported, then it's just (-1*X) // 2 maps, one for + , and one for - class Solution_followup { public boolean checkEquivalence(Node root1, Node root2) { int[] countPlus = new int[26]; int[] countMinus = new int[26]; dfs(root1, countPlus, countMinus, 1, false); dfs(root2, countPlus, countMinus, -1, false); for (int i = 0; i &amp;lt; countPlus.length; i++) { if (countPlus[i] != 0) { return false; } } for (int i = 0;..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    1612 - Check If Two Expression Trees are Equivalent | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="1612 - Check If Two Expression Trees are Equivalent" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-1612.html" rel="canonical">
          <meta content="https://leetcode.ca/2020-04-29-1612-Check-If-Two-Expression-Trees-are-Equivalent/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2020-04-29T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"1612 - Check If Two Expression Trees are Equivalent","dateModified":"2020-04-29T00:00:00-07:00","datePublished":"2020-04-29T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2020-04-29-1612-Check-If-Two-Expression-Trees-are-Equivalent/"},"url":"https://leetcode.ca/2020-04-29-1612-Check-If-Two-Expression-Trees-are-Equivalent/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="1612-check-if-two-expression-trees-are-equivalent">
       <a href="solution-1612.html">
        1612. Check If Two Expression Trees are Equivalent
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       A
       <strong>
        <a href="solution-1612.html" target="_blank">
         binary expression tree
        </a>
       </strong>
       is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to operands (variables), and internal nodes (nodes with two children) correspond to the operators. In this problem, we only consider the
       <code>
        '+'
       </code>
       operator (i.e. addition).
      </p>
      <p>
       You are given the roots of two binary expression trees,
       <code>
        root1
       </code>
       and
       <code>
        root2
       </code>
       . Return
       <code>
        true
       </code>
       <em>
        if the two binary expression trees are equivalent
       </em>
       . Otherwise, return
       <code>
        false
       </code>
       .
      </p>
      <p>
       Two binary expression trees are equivalent if they
       <strong>
        evaluate to the same value
       </strong>
       regardless of what the variables are set to.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> root1 = [x], root2 = [x]
<strong>Output:</strong> true
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <p>
       <strong>
        <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1612.Check%20If%20Two%20Expression%20Trees%20are%20Equivalent/images/tree1.png" style="width: 211px; height: 131px;"/>
       </strong>
      </p>
      <pre>
<strong>Input:</strong> root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,c]
<strong>Output:</strong> true
<strong>Explanation</strong><strong>:</strong> <code>a + (b + c) == (b + c) + a</code></pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <p>
       <strong>
        <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1612.Check%20If%20Two%20Expression%20Trees%20are%20Equivalent/images/tree2.png" style="width: 211px; height: 131px;"/>
       </strong>
      </p>
      <pre>
<strong>Input:</strong> root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,d]
<strong>Output:</strong> false
<strong>Explanation</strong><strong>:</strong> <code>a + (b + c) != (b + d) + a</code>
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in both trees are equal, odd and, in the range
        <code>
         [1, 4999]
        </code>
        .
       </li>
       <li>
        <code>
         Node.val
        </code>
        is
        <code>
         '+'
        </code>
        or a lower-case English letter.
       </li>
       <li>
        It's
        <strong>
         guaranteed
        </strong>
        that the tree given is a valid binary expression tree.
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong>
        Follow up:
       </strong>
       What will you change in your solution if the tree also supports the
       <code>
        '-'
       </code>
       operator (i.e. subtraction)?
      </p>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       Just count the type and number of letters in the two expression trees. Because itâs
       <code class="language-plaintext highlighter-rouge">
        +
       </code>
       only,
       <code class="language-plaintext highlighter-rouge">
        (a+b)+c
       </code>
       is same as
       <code class="language-plaintext highlighter-rouge">
        a+(b+c)
       </code>
      </p>
      <h2 id="follow-up-question">
       Follow up question
      </h2>
      <p>
       What will you change in your solution if the tree also supports the â-â operator (i.e. subtraction). Then use 2 maps, one for
       <code class="language-plaintext highlighter-rouge">
        +
       </code>
       records, and one for
       <code class="language-plaintext highlighter-rouge">
        -
       </code>
       records.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#ec412df8-9d6b-4885-b180-c555debf5f0f'}">
       <li class="uk-active">
        <a href="solution-1612.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-1612.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-1612.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-1612.html">
         Javascript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="ec412df8-9d6b-4885-b180-c555debf5f0f">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * class Node {
 *     char val;
 *     Node left;
 *     Node right;
 *     Node() {this.val = ' ';}
 *     Node(char val) { this.val = val; }
 *     Node(char val, Node left, Node right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">checkEquivalence</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root1</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">root2</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root1</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">cnt</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="sc">'+'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">cnt</span><span class="o">[</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">+=</span> <span class="n">v</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">//////</span>

<span class="c1">// if '-' supported, then it's just (-1*X)</span>
<span class="c1">// 2 maps, one for + , and one for -</span>
<span class="kd">class</span> <span class="nc">Solution_followup</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">checkEquivalence</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root1</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">root2</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">countPlus</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">countMinus</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>


        <span class="n">dfs</span><span class="o">(</span><span class="n">root1</span><span class="o">,</span> <span class="n">countPlus</span><span class="o">,</span> <span class="n">countMinus</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">root2</span><span class="o">,</span> <span class="n">countPlus</span><span class="o">,</span> <span class="n">countMinus</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">countPlus</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">countPlus</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">countMinus</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">countMinus</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">Node</span> <span class="n">cur</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">countPlus</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">countMinus</span><span class="o">,</span> <span class="kt">int</span> <span class="n">diff</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isRightChildOfMinusNode</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cur</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="sc">'+'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">countPlus</span><span class="o">,</span> <span class="n">countMinus</span><span class="o">,</span> <span class="n">diff</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">countPlus</span><span class="o">,</span> <span class="n">countMinus</span><span class="o">,</span> <span class="n">diff</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="sc">'-'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">countPlus</span><span class="o">,</span> <span class="n">countMinus</span><span class="o">,</span> <span class="n">diff</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">countPlus</span><span class="o">,</span> <span class="n">countMinus</span><span class="o">,</span> <span class="n">diff</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isRightChildOfMinusNode</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">countMinus</span><span class="o">[</span><span class="n">cur</span><span class="o">.</span><span class="na">val</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">+=</span> <span class="n">diff</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">countPlus</span><span class="o">[</span><span class="n">cur</span><span class="o">.</span><span class="na">val</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">+=</span> <span class="n">diff</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct Node {
 *     char val;
 *     Node *left;
 *     Node *right;
 *     Node() : val(' '), left(nullptr), right(nullptr) {}
 *     Node(char x) : val(x), left(nullptr), right(nullptr) {}
 *     Node(char x, Node *left, Node *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">checkEquivalence</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root1</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">root2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">cnt</span><span class="p">[</span><span class="mi">26</span><span class="p">]{};</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="sc">'+'</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">cnt</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">]</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
        <span class="p">};</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class Node(object):
#     def __init__(self, val=" ", left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">checkEquivalence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root1</span><span class="p">:</span> <span class="s">'Node'</span><span class="p">,</span> <span class="n">root2</span><span class="p">:</span> <span class="s">'Node'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">!=</span> <span class="s">'+'</span><span class="p">:</span>
                <span class="n">cnt</span><span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">+=</span> <span class="n">v</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="n">cnt</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cnt</span><span class="p">.</span><span class="n">values</span><span class="p">())</span>
        <span class="c1"># or, return sum(cnt.values()) == 0
</span>
<span class="c1">###############
</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="c1"># follow-up
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">checkEquivalence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root1</span><span class="p">:</span> <span class="s">'Node'</span><span class="p">,</span> <span class="n">root2</span><span class="p">:</span> <span class="s">'Node'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">counter</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">.</span><span class="n">isdigit</span><span class="p">():</span>
                <span class="n">counter</span><span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="ow">in</span> <span class="p">(</span><span class="s">'+'</span><span class="p">,</span> <span class="s">'-'</span><span class="p">):</span>
                <span class="n">counter</span><span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
            <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>

        <span class="n">counter1</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
        <span class="n">counter2</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">root1</span><span class="p">,</span> <span class="n">counter1</span><span class="p">)</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">root2</span><span class="p">,</span> <span class="n">counter2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">counter1</span> <span class="o">==</span> <span class="n">counter2</span>


<span class="c1">#############
</span>

<span class="s">'''
&gt;&gt;&gt; a = [11,22,33,44,55,11,22,33,11,22]
&gt;&gt;&gt; a.count(11)
3
&gt;&gt;&gt;
&gt;&gt;&gt; a = ['aaa', 'bbb', 'ccc', 'aaa']
&gt;&gt;&gt; a.count('aaa')
2
&gt;&gt;&gt; a.count('zzz')
0
'''</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">checkEquivalence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root1</span><span class="p">:</span> <span class="s">'Node'</span><span class="p">,</span> <span class="n">root2</span><span class="p">:</span> <span class="s">'Node'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">incr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">:</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">incr</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">incr</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">!=</span> <span class="s">'+'</span><span class="p">:</span>
                    <span class="n">counter</span><span class="p">[</span><span class="nb">ord</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">incr</span>

        <span class="n">dfs</span><span class="p">(</span><span class="n">root1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">counter</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">26</span>


<span class="c1">############
</span>
<span class="c1"># Definition for a binary tree node.
# class Node(object):
#     def __init__(self, val=" ", left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">checkEquivalence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root1</span><span class="p">:</span> <span class="s">'Node'</span><span class="p">,</span> <span class="n">root2</span><span class="p">:</span> <span class="s">'Node'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">calc</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">26</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s">'+'</span><span class="p">:</span>
                    <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">right</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">right</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ans</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="ow">in</span> <span class="p">[</span><span class="s">'+'</span><span class="p">,</span> <span class="s">'-'</span><span class="p">]:</span>
                <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">),</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
                <span class="n">calc</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ans</span><span class="p">[</span><span class="nb">ord</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">ans</span>

        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root1</span><span class="p">)</span> <span class="o">==</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root2</span><span class="p">)</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-js highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * function Node(val, left, right) {
 *     this.val = (val===undefined ? " " : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="cm">/**
 * @param {Node} root1
 * @param {Node} root2
 * @return {boolean}
 */</span>
<span class="kd">var</span> <span class="nx">checkEquivalence</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">root1</span><span class="p">,</span> <span class="nx">root2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">26</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">val</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">+</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">cnt</span><span class="p">[</span><span class="nx">root</span><span class="p">.</span><span class="nx">val</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span> <span class="o">+=</span> <span class="nx">v</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span>
        <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="nx">dfs</span><span class="p">(</span><span class="nx">root1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="nx">dfs</span><span class="p">(</span><span class="nx">root2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">x</span> <span class="k">of</span> <span class="nx">cnt</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">};</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-1612.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
