<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-2479.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-2479.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>2479 - Maximum XOR of Two Non-Overlapping Subtrees</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 2479. Maximum XOR of Two Non-Overlapping Subtrees Description There is an undirected tree with n nodes labeled from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi]...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-2479.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-2479.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-2479.html" rel="stylesheet"/>
   <link href="solution-2479.html" rel="stylesheet"/>
   <link href="solution-2479.html" rel="stylesheet"/>
   <link href="solution-2479.html" rel="stylesheet"/>
   <link href="solution-2479.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="2479 - Maximum XOR of Two Non-Overlapping Subtrees" property="og:title"/>
   <meta content="Leetcode 2479. Maximum XOR of Two Non-Overlapping Subtrees Description There is an undirected tree with n nodes labeled from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. The root of the tree is the node labeled 0. Each node has an associated value. You are given an array values of length n, where values[i] is the value of the ith node. Select any two non-overlapping subtrees. Your score is the bitwise XOR of the sum of the values within those subtrees. Return the maximum possible score you can achieve. If it is impossible to find two nonoverlapping subtrees, return 0. Note that: The subtree of a node is the tree consisting of that node and all of its descendants. Two subtrees are non-overlapping if they do not share any common node. &amp;nbsp; Example 1: Input: n = 6, edges = [[0,1],[0,2],[1,3],[1,4],[2,5]], values = [2,8,3,6,2,5] Output: 24 Explanation: Node 1&amp;#39;s subtree has sum of values 16, while node 2&amp;#39;s subtree has sum of values 8, so choosing these nodes will yield a score of 16 XOR 8 = 24. It can be proved that is the maximum possible score we can obtain. Example 2: Input: n = 3, edges = [[0,1],[1,2]], values = [4,6,1] Output: 0 Explanation: There is no possible way to select two non-overlapping subtrees, so we just return 0. &amp;nbsp; Constraints: 2 &amp;lt;= n &amp;lt;= 5 * 104 edges.length == n - 1 0 &amp;lt;= ai, bi &amp;lt; n values.length == n 1 &amp;lt;= values[i] &amp;lt;= 109 It is guaranteed that edges represents a valid tree. Solutions Java C++ Python Go class Trie { Trie[] children = new Trie[2]; void insert(long x) { Trie node = this; for (int i = 47; i &amp;gt;= 0; --i) { int v = (int) (x &amp;gt;&amp;gt; i) &amp;amp; 1; if (node.children[v] == null) { node.children[v] = new Trie(); } node = node.children[v]; } } long search(long x) { Trie node = this; long res = 0; for (int i = 47; i &amp;gt;= 0; --i) { int v = (int) (x &amp;gt;&amp;gt; i) &amp;amp; 1; if (node == null) { return res; } if (node.children[v ^ 1] != null) { res = res &amp;lt;&amp;lt; 1 | 1; node = node.children[v ^ 1]; } else { res &amp;lt;&amp;lt;= 1; node = node.children[v]; } } return res; } } class Solution { private List&amp;lt;Integer&amp;gt;[] g; private int[] vals; private long[] s; private Trie tree; private long ans; public long maxXor(int n, int[][] edges, int[] values) { g = new List[n]; s = new long[n]; vals = values; Arrays.setAll(g, k -&amp;gt; new ArrayList&amp;lt;&amp;gt;()); for (var e : edges) { int a = e[0], b = e[1]; g[a].add(b); g[b].add(a); } dfs1(0, -1); tree = new Trie(); dfs2(0, -1); return ans; } private void dfs2(int i, int fa) {..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2022-09-13T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2022-09-13-2479-Maximum-XOR-of-Two-Non-Overlapping-Subtrees/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-2479.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="2479 - Maximum XOR of Two Non-Overlapping Subtrees" property="twitter:title"/>
   <meta content="Leetcode 2479. Maximum XOR of Two Non-Overlapping Subtrees Description There is an undirected tree with n nodes labeled from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. The root of the tree is the node labeled 0. Each node has an associated value. You are given an array values of length n, where values[i] is the value of the ith node. Select any two non-overlapping subtrees. Your score is the bitwise XOR of the sum of the values within those subtrees. Return the maximum possible score you can achieve. If it is impossible to find two nonoverlapping subtrees, return 0. Note that: The subtree of a node is the tree consisting of that node and all of its descendants. Two subtrees are non-overlapping if they do not share any common node. &amp;nbsp; Example 1: Input: n = 6, edges = [[0,1],[0,2],[1,3],[1,4],[2,5]], values = [2,8,3,6,2,5] Output: 24 Explanation: Node 1&amp;#39;s subtree has sum of values 16, while node 2&amp;#39;s subtree has sum of values 8, so choosing these nodes will yield a score of 16 XOR 8 = 24. It can be proved that is the maximum possible score we can obtain. Example 2: Input: n = 3, edges = [[0,1],[1,2]], values = [4,6,1] Output: 0 Explanation: There is no possible way to select two non-overlapping subtrees, so we just return 0. &amp;nbsp; Constraints: 2 &amp;lt;= n &amp;lt;= 5 * 104 edges.length == n - 1 0 &amp;lt;= ai, bi &amp;lt; n values.length == n 1 &amp;lt;= values[i] &amp;lt;= 109 It is guaranteed that edges represents a valid tree. Solutions Java C++ Python Go class Trie { Trie[] children = new Trie[2]; void insert(long x) { Trie node = this; for (int i = 47; i &amp;gt;= 0; --i) { int v = (int) (x &amp;gt;&amp;gt; i) &amp;amp; 1; if (node.children[v] == null) { node.children[v] = new Trie(); } node = node.children[v]; } } long search(long x) { Trie node = this; long res = 0; for (int i = 47; i &amp;gt;= 0; --i) { int v = (int) (x &amp;gt;&amp;gt; i) &amp;amp; 1; if (node == null) { return res; } if (node.children[v ^ 1] != null) { res = res &amp;lt;&amp;lt; 1 | 1; node = node.children[v ^ 1]; } else { res &amp;lt;&amp;lt;= 1; node = node.children[v]; } } return res; } } class Solution { private List&amp;lt;Integer&amp;gt;[] g; private int[] vals; private long[] s; private Trie tree; private long ans; public long maxXor(int n, int[][] edges, int[] values) { g = new List[n]; s = new long[n]; vals = values; Arrays.setAll(g, k -&amp;gt; new ArrayList&amp;lt;&amp;gt;()); for (var e : edges) { int a = e[0], b = e[1]; g[a].add(b); g[b].add(a); } dfs1(0, -1); tree = new Trie(); dfs2(0, -1); return ans; } private void dfs2(int i, int fa) {..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    2479 - Maximum XOR of Two Non-Overlapping Subtrees | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="2479 - Maximum XOR of Two Non-Overlapping Subtrees" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-2479.html" rel="canonical">
          <meta content="https://leetcode.ca/2022-09-13-2479-Maximum-XOR-of-Two-Non-Overlapping-Subtrees/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2022-09-13T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"2479 - Maximum XOR of Two Non-Overlapping Subtrees","dateModified":"2022-09-13T00:00:00-07:00","datePublished":"2022-09-13T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2022-09-13-2479-Maximum-XOR-of-Two-Non-Overlapping-Subtrees/"},"url":"https://leetcode.ca/2022-09-13-2479-Maximum-XOR-of-Two-Non-Overlapping-Subtrees/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="2479-maximum-xor-of-two-non-overlapping-subtrees">
       <a href="solution-2479.html">
        2479. Maximum XOR of Two Non-Overlapping Subtrees
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       There is an undirected tree with
       <code>
        n
       </code>
       nodes labeled from
       <code>
        0
       </code>
       to
       <code>
        n - 1
       </code>
       . You are given the integer
       <code>
        n
       </code>
       and a 2D integer array
       <code>
        edges
       </code>
       of length
       <code>
        n - 1
       </code>
       , where
       <code>
        edges[i] = [a
        <sub>
         i
        </sub>
        , b
        <sub>
         i
        </sub>
        ]
       </code>
       indicates that there is an edge between nodes
       <code>
        a
        <sub>
         i
        </sub>
       </code>
       and
       <code>
        b
        <sub>
         i
        </sub>
       </code>
       in the tree. The root of the tree is the node labeled
       <code>
        0
       </code>
       .
      </p>
      <p>
       Each node has an associated
       <strong>
        value
       </strong>
       . You are given an array
       <code>
        values
       </code>
       of length
       <code>
        n
       </code>
       , where
       <code>
        values[i]
       </code>
       is the
       <strong>
        value
       </strong>
       of the
       <code>
        i
        <sup>
         th
        </sup>
       </code>
       node.
      </p>
      <p>
       Select any two
       <strong>
        non-overlapping
       </strong>
       subtrees. Your
       <strong>
        score
       </strong>
       is the bitwise XOR of the sum of the values within those subtrees.
      </p>
      <p>
       Return
       <em>
        the
       </em>
       <em>
        <strong>
         maximum
        </strong>
       </em>
       <i>
        possible
        <strong>
         score
        </strong>
        you can achieve
       </i>
       .
       <em>
        If it is impossible to find two nonoverlapping subtrees
       </em>
       , return
       <code>
        0
       </code>
       .
      </p>
      <p>
       <strong>
        Note
       </strong>
       that:
      </p>
      <ul>
       <li>
        The
        <strong>
         subtree
        </strong>
        of a node is the tree consisting of that node and all of its descendants.
       </li>
       <li>
        Two subtrees are
        <strong>
         non-overlapping
        </strong>
        if they do not share
        <strong>
         any common
        </strong>
        node.
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2400-2499/2479.Maximum%20XOR%20of%20Two%20Non-Overlapping%20Subtrees/images/treemaxxor.png" style="width: 346px; height: 249px;"/>
      </p>
      <pre>
<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[1,3],[1,4],[2,5]], values = [2,8,3,6,2,5]
<strong>Output:</strong> 24
<strong>Explanation:</strong> Node 1's subtree has sum of values 16, while node 2's subtree has sum of values 8, so choosing these nodes will yield a score of 16 XOR 8 = 24. It can be proved that is the maximum possible score we can obtain.
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2400-2499/2479.Maximum%20XOR%20of%20Two%20Non-Overlapping%20Subtrees/images/tree3drawio.png" style="width: 240px; height: 261px;"/>
      </p>
      <pre>
<strong>Input:</strong> n = 3, edges = [[0,1],[1,2]], values = [4,6,1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There is no possible way to select two non-overlapping subtrees, so we just return 0.
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         2 &lt;= n &lt;= 5 * 10
         <sup>
          4
         </sup>
        </code>
       </li>
       <li>
        <code>
         edges.length == n - 1
        </code>
       </li>
       <li>
        <code>
         0 &lt;= a
         <sub>
          i
         </sub>
         , b
         <sub>
          i
         </sub>
         &lt; n
        </code>
       </li>
       <li>
        <code>
         values.length == n
        </code>
       </li>
       <li>
        <code>
         1 &lt;= values[i] &lt;= 10
         <sup>
          9
         </sup>
        </code>
       </li>
       <li>
        It is guaranteed that
        <code>
         edges
        </code>
        represents a valid tree.
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <ul class="uk-tab" data-uk-switcher="{connect:'#f9721e49-82a0-4ebd-94e0-f3bf809bc74f'}">
       <li class="uk-active">
        <a href="solution-2479.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-2479.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-2479.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-2479.html">
         Go
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="f9721e49-82a0-4ebd-94e0-f3bf809bc74f">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Trie</span> <span class="o">{</span>
    <span class="nc">Trie</span><span class="o">[]</span> <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Trie</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>

    <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="kt">long</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">47</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Trie</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kt">long</span> <span class="nf">search</span><span class="o">(</span><span class="kt">long</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">47</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">v</span> <span class="o">^</span> <span class="mi">1</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">1</span><span class="o">;</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">v</span> <span class="o">^</span> <span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">res</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">g</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">vals</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span><span class="o">[]</span> <span class="n">s</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Trie</span> <span class="n">tree</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">ans</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">maxXor</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">g</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">List</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">values</span><span class="o">;</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">setAll</span><span class="o">(</span><span class="n">g</span><span class="o">,</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">var</span> <span class="n">e</span> <span class="o">:</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">e</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="n">g</span><span class="o">[</span><span class="n">a</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
            <span class="n">g</span><span class="o">[</span><span class="n">b</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">dfs1</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Trie</span><span class="o">();</span>
        <span class="n">dfs2</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs2</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fa</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">tree</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">:</span> <span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">fa</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">dfs2</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">tree</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">long</span> <span class="nf">dfs1</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fa</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">t</span> <span class="o">=</span> <span class="n">vals</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">:</span> <span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">fa</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">t</span> <span class="o">+=</span> <span class="n">dfs1</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">using</span> <span class="n">ll</span> <span class="o">=</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Trie</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Trie</span><span class="o">*&gt;</span> <span class="n">children</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">Trie</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">children</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">ll</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Trie</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">47</span><span class="p">;</span> <span class="o">~</span><span class="n">i</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Trie</span><span class="p">();</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ll</span> <span class="n">search</span><span class="p">(</span><span class="n">ll</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Trie</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="n">ll</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">47</span><span class="p">;</span> <span class="o">~</span><span class="n">i</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">v</span> <span class="o">^</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">v</span> <span class="o">^</span> <span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">res</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">maxXor</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">g</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">e</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
            <span class="n">g</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">ll</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="n">ll</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dfs1</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fa</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ll</span> <span class="p">{</span>
            <span class="n">ll</span> <span class="n">t</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">fa</span><span class="p">)</span> <span class="n">t</span> <span class="o">+=</span> <span class="n">dfs1</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="n">dfs1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">Trie</span> <span class="n">tree</span><span class="p">;</span>
        <span class="n">ll</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dfs2</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fa</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">tree</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">fa</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">dfs2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">tree</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">};</span>
        <span class="n">dfs2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">47</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">47</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">res</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">v</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">1</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">v</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxXor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs1</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">fa</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">fa</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">+=</span> <span class="n">dfs1</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
            <span class="k">return</span> <span class="n">t</span>

        <span class="k">def</span> <span class="nf">dfs2</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">fa</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">ans</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">tree</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">fa</span><span class="p">:</span>
                    <span class="n">dfs2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">tree</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">g</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">dfs1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>
        <span class="n">dfs2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">type</span> <span class="n">Trie</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">children</span> <span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="o">*</span><span class="n">Trie</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">newTrie</span><span class="p">()</span> <span class="o">*</span><span class="n">Trie</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">Trie</span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Trie</span><span class="p">)</span> <span class="n">insert</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">this</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">47</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="n">v</span> <span class="o">:=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="m">1</span>
		<span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">newTrie</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Trie</span><span class="p">)</span> <span class="n">search</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">this</span>
	<span class="n">res</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">47</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="n">v</span> <span class="o">:=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="m">1</span>
		<span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">res</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">v</span><span class="o">^</span><span class="m">1</span><span class="p">]</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">&lt;&lt;</span><span class="m">1</span> <span class="o">|</span> <span class="m">1</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">v</span><span class="o">^</span><span class="m">1</span><span class="p">]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">&lt;&lt;=</span> <span class="m">1</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">maxXor</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">edges</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="n">values</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="n">g</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">edges</span> <span class="p">{</span>
		<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">e</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="m">1</span><span class="p">]</span>
		<span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span>
		<span class="n">g</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">a</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="k">var</span> <span class="n">dfs1</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">fa</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
	<span class="n">dfs1</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">fa</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="n">t</span> <span class="o">:=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">j</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">fa</span> <span class="p">{</span>
				<span class="n">t</span> <span class="o">+=</span> <span class="n">dfs1</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
		<span class="k">return</span> <span class="n">t</span>
	<span class="p">}</span>
	<span class="n">dfs1</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="o">-</span><span class="m">1</span><span class="p">)</span>
	<span class="n">ans</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="n">tree</span> <span class="o">:=</span> <span class="n">newTrie</span><span class="p">()</span>
	<span class="k">var</span> <span class="n">dfs2</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">fa</span> <span class="kt">int</span><span class="p">)</span>
	<span class="n">dfs2</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">fa</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
		<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">j</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">fa</span> <span class="p">{</span>
				<span class="n">dfs2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">tree</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="n">dfs2</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="o">-</span><span class="m">1</span><span class="p">)</span>
	<span class="k">return</span> <span class="kt">int64</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-2479.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
