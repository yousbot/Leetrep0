<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-3013.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-3013.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>3013 - Divide an Array Into Subarrays With Minimum Cost II</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 3013. Divide an Array Into Subarrays With Minimum Cost II Description You are given a 0-indexed array of integers nums of length n, and two positive integers k and dist. The cost of an array is the value of its first element. For example, the...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-3013.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-3013.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-3013.html" rel="stylesheet"/>
   <link href="solution-3013.html" rel="stylesheet"/>
   <link href="solution-3013.html" rel="stylesheet"/>
   <link href="solution-3013.html" rel="stylesheet"/>
   <link href="solution-3013.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="3013 - Divide an Array Into Subarrays With Minimum Cost II" property="og:title"/>
   <meta content="Leetcode 3013. Divide an Array Into Subarrays With Minimum Cost II Description You are given a 0-indexed array of integers nums of length n, and two positive integers k and dist. The cost of an array is the value of its first element. For example, the cost of [1,2,3] is 1 while the cost of [3,4,1] is 3. You need to divide nums into k disjoint contiguous subarrays, such that the difference between the starting index of the second subarray and the starting index of the kth subarray should be less than or equal to dist. In other words, if you divide nums into the subarrays nums[0..(i1 - 1)], nums[i1..(i2 - 1)], ..., nums[ik-1..(n - 1)], then ik-1 - i1 &amp;lt;= dist. Return the minimum possible sum of the cost of these subarrays. &amp;nbsp; Example 1: Input: nums = [1,3,2,6,4,2], k = 3, dist = 3 Output: 5 Explanation: The best possible way to divide nums into 3 subarrays is: [1,3], [2,6,4], and [2]. This choice is valid because ik-1 - i1 is 5 - 2 = 3 which is equal to dist. The total cost is nums[0] + nums[2] + nums[5] which is 1 + 2 + 2 = 5. It can be shown that there is no possible way to divide nums into 3 subarrays at a cost lower than 5. Example 2: Input: nums = [10,1,2,2,2,1], k = 4, dist = 3 Output: 15 Explanation: The best possible way to divide nums into 4 subarrays is: [10], [1], [2], and [2,2,1]. This choice is valid because ik-1 - i1 is 3 - 1 = 2 which is less than dist. The total cost is nums[0] + nums[1] + nums[2] + nums[3] which is 10 + 1 + 2 + 2 = 15. The division [10], [1], [2,2,2], and [1] is not valid, because the difference between ik-1 and i1 is 5 - 1 = 4, which is greater than dist. It can be shown that there is no possible way to divide nums into 4 subarrays at a cost lower than 15. Example 3: Input: nums = [10,8,18,9], k = 3, dist = 1 Output: 36 Explanation: The best possible way to divide nums into 4 subarrays is: [10], [8], and [18,9]. This choice is valid because ik-1 - i1 is 2 - 1 = 1 which is equal to dist.The total cost is nums[0] + nums[1] + nums[2] which is 10 + 8 + 18 = 36. The division [10], [8,18], and [9] is not valid, because the difference between ik-1 and i1 is 3 - 1 = 2, which is greater than dist. It can be shown that there is no possible way to divide nums into 3 subarrays at a cost lower than 36. &amp;nbsp; Constraints: 3 &amp;lt;= n &amp;lt;= 105 1 &amp;lt;= nums[i] &amp;lt;= 109 3 &amp;lt;= k &amp;lt;= n k - 2 &amp;lt;= dist &amp;lt;= n - 2 Solutions Solution 1 Java C++ Python Go TypeScript class Solution..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2024-01-24T00:00:00-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2024-01-24-3013-Divide-an-Array-Into-Subarrays-With-Minimum-Cost-II/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-3013.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="3013 - Divide an Array Into Subarrays With Minimum Cost II" property="twitter:title"/>
   <meta content="Leetcode 3013. Divide an Array Into Subarrays With Minimum Cost II Description You are given a 0-indexed array of integers nums of length n, and two positive integers k and dist. The cost of an array is the value of its first element. For example, the cost of [1,2,3] is 1 while the cost of [3,4,1] is 3. You need to divide nums into k disjoint contiguous subarrays, such that the difference between the starting index of the second subarray and the starting index of the kth subarray should be less than or equal to dist. In other words, if you divide nums into the subarrays nums[0..(i1 - 1)], nums[i1..(i2 - 1)], ..., nums[ik-1..(n - 1)], then ik-1 - i1 &amp;lt;= dist. Return the minimum possible sum of the cost of these subarrays. &amp;nbsp; Example 1: Input: nums = [1,3,2,6,4,2], k = 3, dist = 3 Output: 5 Explanation: The best possible way to divide nums into 3 subarrays is: [1,3], [2,6,4], and [2]. This choice is valid because ik-1 - i1 is 5 - 2 = 3 which is equal to dist. The total cost is nums[0] + nums[2] + nums[5] which is 1 + 2 + 2 = 5. It can be shown that there is no possible way to divide nums into 3 subarrays at a cost lower than 5. Example 2: Input: nums = [10,1,2,2,2,1], k = 4, dist = 3 Output: 15 Explanation: The best possible way to divide nums into 4 subarrays is: [10], [1], [2], and [2,2,1]. This choice is valid because ik-1 - i1 is 3 - 1 = 2 which is less than dist. The total cost is nums[0] + nums[1] + nums[2] + nums[3] which is 10 + 1 + 2 + 2 = 15. The division [10], [1], [2,2,2], and [1] is not valid, because the difference between ik-1 and i1 is 5 - 1 = 4, which is greater than dist. It can be shown that there is no possible way to divide nums into 4 subarrays at a cost lower than 15. Example 3: Input: nums = [10,8,18,9], k = 3, dist = 1 Output: 36 Explanation: The best possible way to divide nums into 4 subarrays is: [10], [8], and [18,9]. This choice is valid because ik-1 - i1 is 2 - 1 = 1 which is equal to dist.The total cost is nums[0] + nums[1] + nums[2] which is 10 + 8 + 18 = 36. The division [10], [8,18], and [9] is not valid, because the difference between ik-1 and i1 is 3 - 1 = 2, which is greater than dist. It can be shown that there is no possible way to divide nums into 3 subarrays at a cost lower than 36. &amp;nbsp; Constraints: 3 &amp;lt;= n &amp;lt;= 105 1 &amp;lt;= nums[i] &amp;lt;= 109 3 &amp;lt;= k &amp;lt;= n k - 2 &amp;lt;= dist &amp;lt;= n - 2 Solutions Solution 1 Java C++ Python Go TypeScript class Solution..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    3013 - Divide an Array Into Subarrays With Minimum Cost II | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="3013 - Divide an Array Into Subarrays With Minimum Cost II" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-3013.html" rel="canonical">
          <meta content="https://leetcode.ca/2024-01-24-3013-Divide-an-Array-Into-Subarrays-With-Minimum-Cost-II/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2024-01-24T00:00:00-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"3013 - Divide an Array Into Subarrays With Minimum Cost II","dateModified":"2024-01-24T00:00:00-08:00","datePublished":"2024-01-24T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2024-01-24-3013-Divide-an-Array-Into-Subarrays-With-Minimum-Cost-II/"},"url":"https://leetcode.ca/2024-01-24-3013-Divide-an-Array-Into-Subarrays-With-Minimum-Cost-II/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="3013-divide-an-array-into-subarrays-with-minimum-cost-ii">
       <a href="solution-3013.html">
        3013. Divide an Array Into Subarrays With Minimum Cost II
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       You are given a
       <strong>
        0-indexed
       </strong>
       array of integers
       <code>
        nums
       </code>
       of length
       <code>
        n
       </code>
       , and two
       <strong>
        positive
       </strong>
       integers
       <code>
        k
       </code>
       and
       <code>
        dist
       </code>
       .
      </p>
      <p>
       The
       <strong>
        cost
       </strong>
       of an array is the value of its
       <strong>
        first
       </strong>
       element. For example, the cost of
       <code>
        [1,2,3]
       </code>
       is
       <code>
        1
       </code>
       while the cost of
       <code>
        [3,4,1]
       </code>
       is
       <code>
        3
       </code>
       .
      </p>
      <p>
       You need to divide
       <code>
        nums
       </code>
       into
       <code>
        k
       </code>
       <strong>
        disjoint contiguous
       </strong>
       <span data-keyword="subarray-nonempty">
        subarrays
       </span>
       , such that the difference between the starting index of the
       <strong>
        second
       </strong>
       subarray and the starting index of the
       <code>
        kth
       </code>
       subarray should be
       <strong>
        less than or equal to
       </strong>
       <code>
        dist
       </code>
       . In other words, if you divide
       <code>
        nums
       </code>
       into the subarrays
       <code>
        nums[0..(i
        <sub>
         1
        </sub>
        - 1)], nums[i
        <sub>
         1
        </sub>
        ..(i
        <sub>
         2
        </sub>
        - 1)], ..., nums[i
        <sub>
         k-1
        </sub>
        ..(n - 1)]
       </code>
       , then
       <code>
        i
        <sub>
         k-1
        </sub>
        - i
        <sub>
         1
        </sub>
        &lt;= dist
       </code>
       .
      </p>
      <p>
       Return
       <em>
        the
        <strong>
         minimum
        </strong>
        possible sum of the cost of these
       </em>
       <em>
        subarrays
       </em>
       .
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> nums = [1,3,2,6,4,2], k = 3, dist = 3
<strong>Output:</strong> 5
<strong>Explanation:</strong> The best possible way to divide nums into 3 subarrays is: [1,3], [2,6,4], and [2]. This choice is valid because i<sub>k-1</sub> - i<sub>1</sub> is 5 - 2 = 3 which is equal to dist. The total cost is nums[0] + nums[2] + nums[5] which is 1 + 2 + 2 = 5.
It can be shown that there is no possible way to divide nums into 3 subarrays at a cost lower than 5.
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> nums = [10,1,2,2,2,1], k = 4, dist = 3
<strong>Output:</strong> 15
<strong>Explanation:</strong> The best possible way to divide nums into 4 subarrays is: [10], [1], [2], and [2,2,1]. This choice is valid because i<sub>k-1</sub> - i<sub>1</sub> is 3 - 1 = 2 which is less than dist. The total cost is nums[0] + nums[1] + nums[2] + nums[3] which is 10 + 1 + 2 + 2 = 15.
The division [10], [1], [2,2,2], and [1] is not valid, because the difference between i<sub>k-1</sub> and i<sub>1</sub> is 5 - 1 = 4, which is greater than dist.
It can be shown that there is no possible way to divide nums into 4 subarrays at a cost lower than 15.
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> nums = [10,8,18,9], k = 3, dist = 1
<strong>Output:</strong> 36
<strong>Explanation:</strong> The best possible way to divide nums into 4 subarrays is: [10], [8], and [18,9]. This choice is valid because i<sub>k-1</sub> - i<sub>1</sub> is 2 - 1 = 1 which is equal to dist.The total cost is nums[0] + nums[1] + nums[2] which is 10 + 8 + 18 = 36.
The division [10], [8,18], and [9] is not valid, because the difference between i<sub>k-1</sub> and i<sub>1</sub> is 3 - 1 = 2, which is greater than dist.
It can be shown that there is no possible way to divide nums into 3 subarrays at a cost lower than 36.
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         3 &lt;= n &lt;= 10
         <sup>
          5
         </sup>
        </code>
       </li>
       <li>
        <code>
         1 &lt;= nums[i] &lt;= 10
         <sup>
          9
         </sup>
        </code>
       </li>
       <li>
        <code>
         3 &lt;= k &lt;= n
        </code>
       </li>
       <li>
        <code>
         k - 2 &lt;= dist &lt;= n - 2
        </code>
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <h3 id="solution-1">
       Solution 1
      </h3>
      <ul class="uk-tab" data-uk-switcher="{connect:'#2b2b35ff-208b-46e9-af00-7384c709c750'}">
       <li class="uk-active">
        <a href="solution-3013.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-3013.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-3013.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-3013.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-3013.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="2b2b35ff-208b-46e9-af00-7384c709c750">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">minimumCost</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">dist</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0L</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="nc">TreeSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set1</span>
            <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeSet</span><span class="o">&lt;&gt;((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span> <span class="o">?</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="o">:</span> <span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]);</span>
        <span class="nc">TreeSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set2</span>
            <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeSet</span><span class="o">&lt;&gt;((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span> <span class="o">?</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="o">:</span> <span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">set1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">set1</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">set1</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
                <span class="n">sum</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
                <span class="n">set2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">sum</span><span class="o">);</span>
                <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">dist</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">set1</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">temp</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">set1</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>
                    <span class="n">sum</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">temp</span><span class="o">];</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">set2</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">set2</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
                        <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">y</span><span class="o">];</span>
                        <span class="n">set1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">set2</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">dist</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">minimumCost</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dist</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sml</span><span class="p">,</span> <span class="n">big</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">sz</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sml</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">sml</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">big</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">*</span><span class="n">sml</span><span class="p">.</span><span class="n">rbegin</span><span class="p">());</span>
            <span class="n">sum</span> <span class="o">-=</span> <span class="o">*</span><span class="n">sml</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span>
            <span class="n">sml</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">sml</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">*</span><span class="n">sml</span><span class="p">.</span><span class="n">rbegin</span><span class="p">()));</span>
        <span class="p">}</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">sml</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">big</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">sz</span><span class="p">])</span> <span class="o">!=</span> <span class="n">big</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">big</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">big</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">sz</span><span class="p">]));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">sum</span> <span class="o">-=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">sz</span><span class="p">];</span>
                <span class="n">sml</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">sml</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">sz</span><span class="p">]));</span>
            <span class="p">}</span>

            <span class="k">while</span> <span class="p">(</span><span class="n">sml</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sum</span> <span class="o">-=</span> <span class="o">*</span><span class="n">sml</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span>
                <span class="n">big</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">*</span><span class="n">sml</span><span class="p">.</span><span class="n">rbegin</span><span class="p">());</span>
                <span class="n">sml</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">sml</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">*</span><span class="n">sml</span><span class="p">.</span><span class="n">rbegin</span><span class="p">()));</span>
            <span class="p">}</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">sml</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">big</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
                <span class="n">sml</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">*</span><span class="n">big</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
                <span class="n">big</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">big</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">sml</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">big</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">sml</span><span class="p">.</span><span class="n">rbegin</span><span class="p">()</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">big</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">sum</span> <span class="o">-=</span> <span class="o">*</span><span class="n">sml</span><span class="p">.</span><span class="n">rbegin</span><span class="p">()</span> <span class="o">-</span> <span class="o">*</span><span class="n">big</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
                <span class="n">sml</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">*</span><span class="n">big</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
                <span class="n">big</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">*</span><span class="n">sml</span><span class="p">.</span><span class="n">rbegin</span><span class="p">());</span>
                <span class="n">sml</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">sml</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">*</span><span class="n">sml</span><span class="p">.</span><span class="n">rbegin</span><span class="p">()));</span>
                <span class="n">big</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">big</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kn">from</span> <span class="nn">sortedcontainers</span> <span class="kn">import</span> <span class="n">SortedList</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minimumCost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dist</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

        <span class="n">sl</span> <span class="o">=</span> <span class="n">SortedList</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">"inf"</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">running_sum</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect</span><span class="p">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">sl</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">sl</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">running_sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">running_sum</span> <span class="o">-=</span> <span class="n">sl</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

            <span class="k">while</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">:</span>
                <span class="n">removed_pos</span> <span class="o">=</span> <span class="n">sl</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">removed_element</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">sl</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">removed_element</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">removed_pos</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">running_sum</span> <span class="o">-=</span> <span class="n">removed_element</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">running_sum</span> <span class="o">+=</span> <span class="n">sl</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">running_sum</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ans</span> <span class="o">+</span> <span class="n">y</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">minimumCost</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">k</span> <span class="kt">int</span><span class="p">,</span> <span class="n">dist</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="n">res</span> <span class="o">:=</span> <span class="n">nums</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">slices</span><span class="o">.</span><span class="n">Min</span><span class="p">(</span><span class="n">windowTopKSum</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">],</span> <span class="n">dist</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="m">1</span><span class="p">,</span> <span class="no">true</span><span class="p">))</span>
	<span class="k">return</span> <span class="kt">int64</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">windowTopKSum</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">windowSize</span><span class="p">,</span> <span class="n">k</span> <span class="kt">int</span><span class="p">,</span> <span class="n">min</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
	<span class="n">ts</span> <span class="o">:=</span> <span class="n">NewTopKSum</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">min</span><span class="p">)</span>
	<span class="n">res</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="k">for</span> <span class="n">right</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">right</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">ts</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">])</span>
		<span class="k">if</span> <span class="n">right</span> <span class="o">&gt;=</span> <span class="n">windowSize</span> <span class="p">{</span>
			<span class="n">ts</span><span class="o">.</span><span class="n">Discard</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="o">-</span><span class="n">windowSize</span><span class="p">])</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">right</span> <span class="o">&gt;=</span> <span class="n">windowSize</span><span class="o">-</span><span class="m">1</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">Query</span><span class="p">())</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">TopKSum</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">sum</span>     <span class="kt">int</span>
	<span class="n">k</span>       <span class="kt">int</span>
	<span class="n">in</span>      <span class="o">*</span><span class="n">Heap</span>
	<span class="n">out</span>     <span class="o">*</span><span class="n">Heap</span>
	<span class="n">dIn</span>     <span class="o">*</span><span class="n">Heap</span>
	<span class="n">dOut</span>    <span class="o">*</span><span class="n">Heap</span>
	<span class="n">counter</span> <span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewTopKSum</span><span class="p">(</span><span class="n">k</span> <span class="kt">int</span><span class="p">,</span> <span class="n">min</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="n">TopKSum</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">less</span> <span class="k">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span>
	<span class="k">if</span> <span class="n">min</span> <span class="p">{</span>
		<span class="n">less</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">less</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">TopKSum</span><span class="p">{</span>
		<span class="n">k</span><span class="o">:</span>       <span class="n">k</span><span class="p">,</span>
		<span class="n">in</span><span class="o">:</span>      <span class="n">NewHeap</span><span class="p">(</span><span class="n">less</span><span class="p">),</span>
		<span class="n">out</span><span class="o">:</span>     <span class="n">NewHeap</span><span class="p">(</span><span class="n">less</span><span class="p">),</span>
		<span class="n">dIn</span><span class="o">:</span>     <span class="n">NewHeap</span><span class="p">(</span><span class="n">less</span><span class="p">),</span>
		<span class="n">dOut</span><span class="o">:</span>    <span class="n">NewHeap</span><span class="p">(</span><span class="n">less</span><span class="p">),</span>
		<span class="n">counter</span><span class="o">:</span> <span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">{},</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">TopKSum</span><span class="p">)</span> <span class="n">Query</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">sum</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">TopKSum</span><span class="p">)</span> <span class="n">Add</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">t</span><span class="o">.</span><span class="n">counter</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">++</span>
	<span class="n">t</span><span class="o">.</span><span class="n">in</span><span class="o">.</span><span class="n">Push</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
	<span class="n">t</span><span class="o">.</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span>
	<span class="n">t</span><span class="o">.</span><span class="n">modify</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">TopKSum</span><span class="p">)</span> <span class="n">Discard</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">counter</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">false</span>
	<span class="p">}</span>
	<span class="n">t</span><span class="o">.</span><span class="n">counter</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span>
	<span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">in</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="o">-</span><span class="n">t</span><span class="o">.</span><span class="n">in</span><span class="o">.</span><span class="n">Top</span><span class="p">()</span> <span class="o">==</span> <span class="n">x</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">.</span><span class="n">sum</span> <span class="o">-=</span> <span class="n">x</span>
		<span class="n">t</span><span class="o">.</span><span class="n">in</span><span class="o">.</span><span class="n">Pop</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">in</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="o">-</span><span class="n">t</span><span class="o">.</span><span class="n">in</span><span class="o">.</span><span class="n">Top</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">.</span><span class="n">sum</span> <span class="o">-=</span> <span class="n">x</span>
		<span class="n">t</span><span class="o">.</span><span class="n">dIn</span><span class="o">.</span><span class="n">Push</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">.</span><span class="n">dOut</span><span class="o">.</span><span class="n">Push</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">t</span><span class="o">.</span><span class="n">modify</span><span class="p">()</span>
	<span class="k">return</span> <span class="no">true</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">TopKSum</span><span class="p">)</span> <span class="n">SetK</span><span class="p">(</span><span class="n">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">t</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
	<span class="n">t</span><span class="o">.</span><span class="n">modify</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">TopKSum</span><span class="p">)</span> <span class="n">GetK</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">k</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">TopKSum</span><span class="p">)</span> <span class="n">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">in</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="o">.</span><span class="n">dIn</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="o">.</span><span class="n">dOut</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">TopKSum</span><span class="p">)</span> <span class="n">Has</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">counter</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="m">0</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">TopKSum</span><span class="p">)</span> <span class="n">modify</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">t</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">in</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span><span class="o">-</span><span class="n">t</span><span class="o">.</span><span class="n">dIn</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">:=</span> <span class="n">t</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">Pop</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">dOut</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">dOut</span><span class="o">.</span><span class="n">Top</span><span class="p">()</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">.</span><span class="n">dOut</span><span class="o">.</span><span class="n">Pop</span><span class="p">()</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">.</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">p</span>
			<span class="n">t</span><span class="o">.</span><span class="n">in</span><span class="o">.</span><span class="n">Push</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="n">t</span><span class="o">.</span><span class="n">in</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span><span class="o">-</span><span class="n">t</span><span class="o">.</span><span class="n">dIn</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">k</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">:=</span> <span class="o">-</span><span class="n">t</span><span class="o">.</span><span class="n">in</span><span class="o">.</span><span class="n">Pop</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">dIn</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">==</span> <span class="o">-</span><span class="n">t</span><span class="o">.</span><span class="n">dIn</span><span class="o">.</span><span class="n">Top</span><span class="p">()</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">.</span><span class="n">dIn</span><span class="o">.</span><span class="n">Pop</span><span class="p">()</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">.</span><span class="n">sum</span> <span class="o">-=</span> <span class="n">p</span>
			<span class="n">t</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">Push</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="n">t</span><span class="o">.</span><span class="n">dIn</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="o">.</span><span class="n">in</span><span class="o">.</span><span class="n">Top</span><span class="p">()</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">dIn</span><span class="o">.</span><span class="n">Top</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">.</span><span class="n">in</span><span class="o">.</span><span class="n">Pop</span><span class="p">()</span>
		<span class="n">t</span><span class="o">.</span><span class="n">dIn</span><span class="o">.</span><span class="n">Pop</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">H</span> <span class="o">=</span> <span class="kt">int</span>

<span class="k">func</span> <span class="n">NewHeap</span><span class="p">(</span><span class="n">less</span> <span class="k">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="n">H</span><span class="p">)</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">nums</span> <span class="o">...</span><span class="n">H</span><span class="p">)</span> <span class="o">*</span><span class="n">Heap</span> <span class="p">{</span>
	<span class="n">nums</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="o">:</span><span class="m">0</span><span class="o">:</span><span class="m">0</span><span class="p">],</span> <span class="n">nums</span><span class="o">...</span><span class="p">)</span>
	<span class="n">heap</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Heap</span><span class="p">{</span><span class="n">less</span><span class="o">:</span> <span class="n">less</span><span class="p">,</span> <span class="n">data</span><span class="o">:</span> <span class="n">nums</span><span class="p">}</span>
	<span class="n">heap</span><span class="o">.</span><span class="n">heapify</span><span class="p">()</span>
	<span class="k">return</span> <span class="n">heap</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Heap</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">data</span> <span class="p">[]</span><span class="n">H</span>
	<span class="n">less</span> <span class="k">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="n">H</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">h</span> <span class="o">*</span><span class="n">Heap</span><span class="p">)</span> <span class="n">Push</span><span class="p">(</span><span class="n">value</span> <span class="n">H</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">h</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
	<span class="n">h</span><span class="o">.</span><span class="n">pushUp</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span> <span class="o">-</span> <span class="m">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">h</span> <span class="o">*</span><span class="n">Heap</span><span class="p">)</span> <span class="n">Pop</span><span class="p">()</span> <span class="p">(</span><span class="n">value</span> <span class="n">H</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">"heap is empty"</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="n">value</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
	<span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">h</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
	<span class="n">h</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">:</span><span class="n">h</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
	<span class="n">h</span><span class="o">.</span><span class="n">pushDown</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">h</span> <span class="o">*</span><span class="n">Heap</span><span class="p">)</span> <span class="n">Top</span><span class="p">()</span> <span class="p">(</span><span class="n">value</span> <span class="n">H</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">h</span> <span class="o">*</span><span class="n">Heap</span><span class="p">)</span> <span class="n">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">h</span> <span class="o">*</span><span class="n">Heap</span><span class="p">)</span> <span class="n">heapify</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="n">h</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="m">1</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="o">-</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="n">h</span><span class="o">.</span><span class="n">pushDown</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">h</span> <span class="o">*</span><span class="n">Heap</span><span class="p">)</span> <span class="n">pushUp</span><span class="p">(</span><span class="n">root</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">parent</span> <span class="o">:=</span> <span class="p">(</span><span class="n">root</span> <span class="o">-</span> <span class="m">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="m">1</span><span class="p">;</span> <span class="n">parent</span> <span class="o">&gt;=</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">root</span><span class="p">],</span> <span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">parent</span><span class="p">]);</span> <span class="n">parent</span> <span class="o">=</span> <span class="p">(</span><span class="n">root</span> <span class="o">-</span> <span class="m">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="m">1</span> <span class="p">{</span>
		<span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">root</span><span class="p">],</span> <span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">parent</span><span class="p">],</span> <span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">parent</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">h</span> <span class="o">*</span><span class="n">Heap</span><span class="p">)</span> <span class="n">pushDown</span><span class="p">(</span><span class="n">root</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="n">h</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span>
	<span class="k">for</span> <span class="n">left</span> <span class="o">:=</span> <span class="p">(</span><span class="n">root</span><span class="o">&lt;&lt;</span><span class="m">1</span> <span class="o">+</span> <span class="m">1</span><span class="p">);</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">left</span> <span class="o">=</span> <span class="p">(</span><span class="n">root</span><span class="o">&lt;&lt;</span><span class="m">1</span> <span class="o">+</span> <span class="m">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">right</span> <span class="o">:=</span> <span class="n">left</span> <span class="o">+</span> <span class="m">1</span>
		<span class="n">minIndex</span> <span class="o">:=</span> <span class="n">root</span>

		<span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">minIndex</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">minIndex</span> <span class="o">=</span> <span class="n">left</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">minIndex</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">minIndex</span> <span class="o">=</span> <span class="n">right</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="n">minIndex</span> <span class="o">==</span> <span class="n">root</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">root</span><span class="p">],</span> <span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">minIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">minIndex</span><span class="p">],</span> <span class="n">h</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">minIndex</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">function</span> <span class="nx">minimumCost</span><span class="p">(</span><span class="nx">nums</span><span class="p">:</span> <span class="kr">number</span><span class="p">[],</span> <span class="nx">k</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">dist</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="o">--</span><span class="nx">k</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">l</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TreapMultiSet</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TreapMultiSet</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">dist</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">s</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="nx">l</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">l2r</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span><span class="o">!</span><span class="p">;</span>
        <span class="nx">s</span> <span class="o">-=</span> <span class="nx">x</span><span class="p">;</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="kd">const</span> <span class="nx">r2l</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span><span class="o">!</span><span class="p">;</span>
        <span class="nx">l</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
        <span class="nx">s</span> <span class="o">+=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">l2r</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">ans</span> <span class="o">=</span> <span class="nx">s</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">dist</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="nx">dist</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">l</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
            <span class="nx">s</span> <span class="o">-=</span> <span class="nx">x</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">r</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="kd">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">last</span><span class="p">()</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">l</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
            <span class="nx">s</span> <span class="o">+=</span> <span class="nx">y</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">r</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">size</span> <span class="o">&lt;</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">r2l</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">l2r</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="nx">ans</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">ans</span><span class="p">,</span> <span class="nx">s</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">CompareFunction</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">R</span> <span class="kd">extends</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">boolean</span><span class="dl">'</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span>
    <span class="nx">a</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span>
    <span class="nx">b</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span>
<span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">R</span> <span class="kd">extends</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span> <span class="p">?</span> <span class="kr">number</span> <span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>

<span class="kr">interface</span> <span class="nx">ITreapMultiSet</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nx">Iterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="na">add</span><span class="p">:</span> <span class="p">(...</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">[])</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">;</span>
    <span class="nl">has</span><span class="p">:</span> <span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">boolean</span><span class="p">;</span>
    <span class="nl">delete</span><span class="p">:</span> <span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>

    <span class="nl">bisectLeft</span><span class="p">:</span> <span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">bisectRight</span><span class="p">:</span> <span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">number</span><span class="p">;</span>

    <span class="nl">indexOf</span><span class="p">:</span> <span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">lastIndexOf</span><span class="p">:</span> <span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">number</span><span class="p">;</span>

    <span class="nl">at</span><span class="p">:</span> <span class="p">(</span><span class="na">index</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="nl">first</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="nl">last</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span>

    <span class="nl">lower</span><span class="p">:</span> <span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="nl">higher</span><span class="p">:</span> <span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="nl">floor</span><span class="p">:</span> <span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="nl">ceil</span><span class="p">:</span> <span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span>

    <span class="nl">shift</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="nl">pop</span><span class="p">:</span> <span class="p">(</span><span class="nx">index</span><span class="p">?:</span> <span class="kr">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span>

    <span class="nl">count</span><span class="p">:</span> <span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">number</span><span class="p">;</span>

    <span class="nl">keys</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">IterableIterator</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="nl">values</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">IterableIterator</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="nl">rvalues</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">IterableIterator</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="nl">entries</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">IterableIterator</span><span class="o">&lt;</span><span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="nx">T</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">readonly</span> <span class="na">size</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="kr">number</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
    <span class="nl">count</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">size</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">priority</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">left</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nl">right</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">;</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">priority</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">();</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="nx">getSize</span><span class="p">(</span><span class="na">node</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="kr">any</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">node</span><span class="p">?.</span><span class="nx">size</span> <span class="o">??</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="nx">getFac</span><span class="p">(</span><span class="na">node</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="kr">any</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">node</span><span class="p">?.</span><span class="nx">priority</span> <span class="o">??</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">pushUp</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">count</span><span class="p">;</span>
        <span class="nx">tmp</span> <span class="o">+=</span> <span class="nx">TreapNode</span><span class="p">.</span><span class="nx">getSize</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
        <span class="nx">tmp</span> <span class="o">+=</span> <span class="nx">TreapNode</span><span class="p">.</span><span class="nx">getSize</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="nx">tmp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">rotateRight</span><span class="p">():</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// eslint-disable-next-line @typescript-eslint/no-this-alias</span>
        <span class="kd">let</span> <span class="na">node</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">;</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">left</span><span class="p">?.</span><span class="nx">right</span> <span class="o">??</span> <span class="kc">null</span><span class="p">;</span>
        <span class="nx">left</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">left</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">node</span><span class="p">);</span>
        <span class="nx">left</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">node</span> <span class="o">=</span> <span class="nx">left</span><span class="p">);</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">?.</span><span class="nx">pushUp</span><span class="p">();</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">pushUp</span><span class="p">();</span>
        <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">rotateLeft</span><span class="p">():</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// eslint-disable-next-line @typescript-eslint/no-this-alias</span>
        <span class="kd">let</span> <span class="na">node</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">;</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">right</span><span class="p">?.</span><span class="nx">left</span> <span class="o">??</span> <span class="kc">null</span><span class="p">;</span>
        <span class="nx">right</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">right</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">node</span><span class="p">);</span>
        <span class="nx">right</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">node</span> <span class="o">=</span> <span class="nx">right</span><span class="p">);</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">?.</span><span class="nx">pushUp</span><span class="p">();</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">pushUp</span><span class="p">();</span>
        <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">TreapMultiSet</span><span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="kr">number</span><span class="o">&gt;</span> <span class="k">implements</span> <span class="nx">ITreapMultiSet</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="na">root</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="na">compareFn</span><span class="p">:</span> <span class="nx">CompareFunction</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="na">leftBound</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="na">rightBound</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="nx">compareFn</span><span class="p">?:</span> <span class="nx">CompareFunction</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span><span class="o">&gt;</span><span class="p">);</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="na">compareFn</span><span class="p">:</span> <span class="nx">CompareFunction</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span><span class="o">&gt;</span><span class="p">,</span> <span class="na">leftBound</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span> <span class="na">rightBound</span><span class="p">:</span> <span class="nx">T</span><span class="p">);</span>
    <span class="kd">constructor</span><span class="p">(</span>
        <span class="na">compareFn</span><span class="p">:</span> <span class="nx">CompareFunction</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="kr">any</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="na">a</span><span class="p">:</span> <span class="kr">any</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="kr">any</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">,</span>
        <span class="na">leftBound</span><span class="p">:</span> <span class="kr">any</span> <span class="o">=</span> <span class="o">-</span><span class="kc">Infinity</span><span class="p">,</span>
        <span class="na">rightBound</span><span class="p">:</span> <span class="kr">any</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">,</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">rightBound</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">priority</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">leftBound</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">.</span><span class="nx">priority</span> <span class="o">=</span> <span class="o">-</span><span class="kc">Infinity</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">pushUp</span><span class="p">();</span>

        <span class="k">this</span><span class="p">.</span><span class="nx">leftBound</span> <span class="o">=</span> <span class="nx">leftBound</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">rightBound</span> <span class="o">=</span> <span class="nx">rightBound</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">compareFn</span> <span class="o">=</span> <span class="nx">compareFn</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">get</span> <span class="nx">size</span><span class="p">():</span> <span class="kr">number</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">size</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">get</span> <span class="nx">height</span><span class="p">():</span> <span class="kr">number</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">getHeight</span> <span class="o">=</span> <span class="p">(</span><span class="na">node</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">getHeight</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">),</span> <span class="nx">getHeight</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">));</span>
        <span class="p">};</span>

        <span class="k">return</span> <span class="nx">getHeight</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/**
     *
     * @complexity `O(logn)`
     * @description Returns true if value is a member.
     */</span>
    <span class="nx">has</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">boolean</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">compare</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">compareFn</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="na">node</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">boolean</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
            <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
        <span class="p">};</span>

        <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/**
     *
     * @complexity `O(logn)`
     * @description Add value to sorted set.
     */</span>
    <span class="nx">add</span><span class="p">(...</span><span class="na">values</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]):</span> <span class="k">this</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">compare</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">compareFn</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="na">node</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
            <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span>
            <span class="na">parent</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span>
            <span class="na">direction</span><span class="p">:</span> <span class="dl">'</span><span class="s1">left</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">right</span><span class="dl">'</span><span class="p">,</span>
        <span class="p">):</span> <span class="k">void</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">node</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span><span class="p">;</span>
                <span class="nx">node</span><span class="p">.</span><span class="nx">pushUp</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">node</span><span class="p">,</span> <span class="dl">'</span><span class="s1">left</span><span class="dl">'</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TreapNode</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
                    <span class="nx">node</span><span class="p">.</span><span class="nx">pushUp</span><span class="p">();</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="p">(</span><span class="nx">TreapNode</span><span class="p">.</span><span class="nx">getFac</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">priority</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">parent</span><span class="p">[</span><span class="nx">direction</span><span class="p">]</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">rotateRight</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">node</span><span class="p">,</span> <span class="dl">'</span><span class="s1">right</span><span class="dl">'</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TreapNode</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
                    <span class="nx">node</span><span class="p">.</span><span class="nx">pushUp</span><span class="p">();</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="p">(</span><span class="nx">TreapNode</span><span class="p">.</span><span class="nx">getFac</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">priority</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">parent</span><span class="p">[</span><span class="nx">direction</span><span class="p">]</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">rotateLeft</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nx">parent</span><span class="p">.</span><span class="nx">pushUp</span><span class="p">();</span>
        <span class="p">};</span>

        <span class="nx">values</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">value</span> <span class="o">=&gt;</span> <span class="nx">dfs</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="dl">'</span><span class="s1">left</span><span class="dl">'</span><span class="p">));</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     *
     * @complexity `O(logn)`
     * @description Remove value from sorted set if it is a member.
     * If value is not a member, do nothing.
     */</span>
    <span class="k">delete</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">compare</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">compareFn</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="na">node</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
            <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span>
            <span class="na">parent</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span>
            <span class="na">direction</span><span class="p">:</span> <span class="dl">'</span><span class="s1">left</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">right</span><span class="dl">'</span><span class="p">,</span>
        <span class="p">):</span> <span class="k">void</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">node</span><span class="p">.</span><span class="nx">count</span><span class="o">--</span><span class="p">;</span>
                    <span class="nx">node</span><span class="p">?.</span><span class="nx">pushUp</span><span class="p">();</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">parent</span><span class="p">[</span><span class="nx">direction</span><span class="p">]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// æå°æ ¹èç¹</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span>
                        <span class="nx">TreapNode</span><span class="p">.</span><span class="nx">getFac</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nx">TreapNode</span><span class="p">.</span><span class="nx">getFac</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
                    <span class="p">)</span> <span class="p">{</span>
                        <span class="nx">parent</span><span class="p">[</span><span class="nx">direction</span><span class="p">]</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">rotateRight</span><span class="p">();</span>
                        <span class="nx">dfs</span><span class="p">(</span><span class="nx">parent</span><span class="p">[</span><span class="nx">direction</span><span class="p">]?.</span><span class="nx">right</span> <span class="o">??</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">parent</span><span class="p">[</span><span class="nx">direction</span><span class="p">]</span><span class="o">!</span><span class="p">,</span> <span class="dl">'</span><span class="s1">right</span><span class="dl">'</span><span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nx">parent</span><span class="p">[</span><span class="nx">direction</span><span class="p">]</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">rotateLeft</span><span class="p">();</span>
                        <span class="nx">dfs</span><span class="p">(</span><span class="nx">parent</span><span class="p">[</span><span class="nx">direction</span><span class="p">]?.</span><span class="nx">left</span> <span class="o">??</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">parent</span><span class="p">[</span><span class="nx">direction</span><span class="p">]</span><span class="o">!</span><span class="p">,</span> <span class="dl">'</span><span class="s1">left</span><span class="dl">'</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">node</span><span class="p">,</span> <span class="dl">'</span><span class="s1">left</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">node</span><span class="p">,</span> <span class="dl">'</span><span class="s1">right</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="nx">parent</span><span class="p">?.</span><span class="nx">pushUp</span><span class="p">();</span>
        <span class="p">};</span>

        <span class="nx">dfs</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="dl">'</span><span class="s1">left</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/**
     *
     * @complexity `O(logn)`
     * @description Returns an index to insert value in the sorted set.
     * If the value is already present, the insertion point will be before (to the left of) any existing values.
     */</span>
    <span class="nx">bisectLeft</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">compare</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">compareFn</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="na">node</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">TreapNode</span><span class="p">.</span><span class="nx">getSize</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">+</span> <span class="nx">TreapNode</span><span class="p">.</span><span class="nx">getSize</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">+</span> <span class="nx">node</span><span class="p">.</span><span class="nx">count</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     *
     * @complexity `O(logn)`
     * @description Returns an index to insert value in the sorted set.
     * If the value is already present, the insertion point will be before (to the right of) any existing values.
     */</span>
    <span class="nx">bisectRight</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">compare</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">compareFn</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="na">node</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">TreapNode</span><span class="p">.</span><span class="nx">getSize</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">+</span> <span class="nx">node</span><span class="p">.</span><span class="nx">count</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">+</span> <span class="nx">TreapNode</span><span class="p">.</span><span class="nx">getSize</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">+</span> <span class="nx">node</span><span class="p">.</span><span class="nx">count</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     *
     * @complexity `O(logn)`
     * @description Returns the index of the first occurrence of a value in the set, or -1 if it is not present.
     */</span>
    <span class="nx">indexOf</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">compare</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">compareFn</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">isExist</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

        <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="na">node</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">isExist</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
                <span class="k">return</span> <span class="nx">TreapNode</span><span class="p">.</span><span class="nx">getSize</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">+</span> <span class="nx">TreapNode</span><span class="p">.</span><span class="nx">getSize</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">+</span> <span class="nx">node</span><span class="p">.</span><span class="nx">count</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">isExist</span> <span class="p">?</span> <span class="nx">res</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     *
     * @complexity `O(logn)`
     * @description Returns the index of the last occurrence of a value in the set, or -1 if it is not present.
     */</span>
    <span class="nx">lastIndexOf</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">compare</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">compareFn</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">isExist</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

        <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="na">node</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">isExist</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
                <span class="k">return</span> <span class="nx">TreapNode</span><span class="p">.</span><span class="nx">getSize</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">+</span> <span class="nx">node</span><span class="p">.</span><span class="nx">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">+</span> <span class="nx">TreapNode</span><span class="p">.</span><span class="nx">getSize</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">+</span> <span class="nx">node</span><span class="p">.</span><span class="nx">count</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">isExist</span> <span class="p">?</span> <span class="nx">res</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     *
     * @complexity `O(logn)`
     * @description Returns the item located at the specified index.
     * @param index The zero-based index of the desired code unit. A negative index will count back from the last item.
     */</span>
    <span class="nx">at</span><span class="p">(</span><span class="na">index</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">index</span> <span class="o">+=</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span> <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>

        <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="na">node</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span> <span class="na">rank</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">TreapNode</span><span class="p">.</span><span class="nx">getSize</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">rank</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">rank</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">TreapNode</span><span class="p">.</span><span class="nx">getSize</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">+</span> <span class="nx">node</span><span class="p">.</span><span class="nx">count</span> <span class="o">&gt;=</span> <span class="nx">rank</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">rank</span> <span class="o">-</span> <span class="nx">TreapNode</span><span class="p">.</span><span class="nx">getSize</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">-</span> <span class="nx">node</span><span class="p">.</span><span class="nx">count</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="nx">index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">([</span><span class="k">this</span><span class="p">.</span><span class="nx">leftBound</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">rightBound</span><span class="p">]</span> <span class="k">as</span> <span class="kr">any</span><span class="p">[]).</span><span class="nx">includes</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">?</span> <span class="kc">undefined</span> <span class="p">:</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     *
     * @complexity `O(logn)`
     * @description Find and return the element less than `val`, return `undefined` if no such element found.
     */</span>
    <span class="nx">lower</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">compare</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">compareFn</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="na">node</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>

            <span class="kd">const</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">tmp</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">tmp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">tmp</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="k">as</span> <span class="kr">any</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">res</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">leftBound</span> <span class="p">?</span> <span class="kc">undefined</span> <span class="p">:</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     *
     * @complexity `O(logn)`
     * @description Find and return the element greater than `val`, return `undefined` if no such element found.
     */</span>
    <span class="nx">higher</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">compare</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">compareFn</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="na">node</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>

            <span class="kd">const</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">tmp</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">tmp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">tmp</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="k">as</span> <span class="kr">any</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">res</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">rightBound</span> <span class="p">?</span> <span class="kc">undefined</span> <span class="p">:</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     *
     * @complexity `O(logn)`
     * @description Find and return the element less than or equal to `val`, return `undefined` if no such element found.
     */</span>
    <span class="nx">floor</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">compare</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">compareFn</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="na">node</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>

            <span class="kd">const</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">tmp</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">tmp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">tmp</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="k">as</span> <span class="kr">any</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">res</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">leftBound</span> <span class="p">?</span> <span class="kc">undefined</span> <span class="p">:</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     *
     * @complexity `O(logn)`
     * @description Find and return the element greater than or equal to `val`, return `undefined` if no such element found.
     */</span>
    <span class="nx">ceil</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">compare</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">compareFn</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="na">node</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>

            <span class="kd">const</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">tmp</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">tmp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">tmp</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="k">as</span> <span class="kr">any</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">res</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">rightBound</span> <span class="p">?</span> <span class="kc">undefined</span> <span class="p">:</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     * @complexity `O(logn)`
     * @description
     * Returns the last element from set.
     * If the set is empty, undefined is returned.
     */</span>
    <span class="nx">first</span><span class="p">():</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">iter</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">inOrder</span><span class="p">();</span>
        <span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
        <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">res</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">rightBound</span> <span class="p">?</span> <span class="kc">undefined</span> <span class="p">:</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     * @complexity `O(logn)`
     * @description
     * Returns the last element from set.
     * If the set is empty, undefined is returned .
     */</span>
    <span class="nx">last</span><span class="p">():</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">iter</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">reverseInOrder</span><span class="p">();</span>
        <span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
        <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">res</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">leftBound</span> <span class="p">?</span> <span class="kc">undefined</span> <span class="p">:</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     * @complexity `O(logn)`
     * @description
     * Removes the first element from an set and returns it.
     * If the set is empty, undefined is returned and the set is not modified.
     */</span>
    <span class="nx">shift</span><span class="p">():</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">first</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">first</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">first</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">first</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">first</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     * @complexity `O(logn)`
     * @description
     * Removes the last element from an set and returns it.
     * If the set is empty, undefined is returned and the set is not modified.
     */</span>
    <span class="nx">pop</span><span class="p">(</span><span class="nx">index</span><span class="p">?:</span> <span class="kr">number</span><span class="p">):</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">last</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">last</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">last</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">last</span><span class="p">);</span>
            <span class="k">return</span> <span class="nx">last</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">const</span> <span class="nx">toDelete</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="nx">index</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">toDelete</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">toDelete</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">toDelete</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     *
     * @complexity `O(logn)`
     * @description
     * Returns number of occurrences of value in the sorted set.
     */</span>
    <span class="nx">count</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">compare</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">compareFn</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="na">node</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">count</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
            <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
        <span class="p">};</span>

        <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]():</span> <span class="nx">Generator</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="kr">any</span><span class="p">,</span> <span class="kr">any</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">yield</span><span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="cm">/**
     * @description
     * Returns an iterable of keys in the set.
     */</span>
    <span class="o">*</span><span class="nx">keys</span><span class="p">():</span> <span class="nx">Generator</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="kr">any</span><span class="p">,</span> <span class="kr">any</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">yield</span><span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="cm">/**
     * @description
     * Returns an iterable of values in the set.
     */</span>
    <span class="o">*</span><span class="nx">values</span><span class="p">():</span> <span class="nx">Generator</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="kr">any</span><span class="p">,</span> <span class="kr">any</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">iter</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">inOrder</span><span class="p">();</span>
        <span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
        <span class="kd">const</span> <span class="nx">steps</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">_</span> <span class="o">&lt;</span> <span class="nx">steps</span><span class="p">;</span> <span class="nx">_</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">yield</span> <span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/**
     * @description
     * Returns a generator for reversed order traversing the set.
     */</span>
    <span class="o">*</span><span class="nx">rvalues</span><span class="p">():</span> <span class="nx">Generator</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="kr">any</span><span class="p">,</span> <span class="kr">any</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">iter</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">reverseInOrder</span><span class="p">();</span>
        <span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
        <span class="kd">const</span> <span class="nx">steps</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">_</span> <span class="o">&lt;</span> <span class="nx">steps</span><span class="p">;</span> <span class="nx">_</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">yield</span> <span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/**
     * @description
     * Returns an iterable of key, value pairs for every entry in the set.
     */</span>
    <span class="o">*</span><span class="nx">entries</span><span class="p">():</span> <span class="nx">IterableIterator</span><span class="o">&lt;</span><span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="nx">T</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">iter</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">inOrder</span><span class="p">();</span>
        <span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
        <span class="kd">const</span> <span class="nx">steps</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">steps</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">yield</span> <span class="p">[</span><span class="nx">i</span><span class="p">,</span> <span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="o">*</span><span class="nx">inOrder</span><span class="p">(</span><span class="na">root</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">):</span> <span class="nx">Generator</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="kr">any</span><span class="p">,</span> <span class="kr">any</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">yield</span><span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">inOrder</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">count</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">count</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">_</span> <span class="o">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">_</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">yield</span> <span class="nx">root</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">yield</span><span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">inOrder</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="o">*</span><span class="nx">reverseInOrder</span><span class="p">(</span><span class="na">root</span><span class="p">:</span> <span class="nx">TreapNode</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">):</span> <span class="nx">Generator</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="kr">any</span><span class="p">,</span> <span class="kr">any</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">yield</span><span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">reverseInOrder</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">count</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">count</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">_</span> <span class="o">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">_</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">yield</span> <span class="nx">root</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">yield</span><span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">reverseInOrder</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-3013.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
