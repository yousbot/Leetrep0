<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-147.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-147.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>147 - Insertion Sort List</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 147. Insertion Sort List Description Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list&amp;#39;s head. The steps of the insertion sort algorithm: Insertion sort iterates, consuming one input element each repetition and growing a sorted...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-147.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-147.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-147.html" rel="stylesheet"/>
   <link href="solution-147.html" rel="stylesheet"/>
   <link href="solution-147.html" rel="stylesheet"/>
   <link href="solution-147.html" rel="stylesheet"/>
   <link href="solution-147.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="147 - Insertion Sort List" property="og:title"/>
   <meta content="Leetcode 147. Insertion Sort List Description Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list&amp;#39;s head. The steps of the insertion sort algorithm: Insertion sort iterates, consuming one input element each repetition and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there. It repeats until no input elements remain. The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration. &amp;nbsp; Example 1: Input: head = [4,2,1,3] Output: [1,2,3,4] Example 2: Input: head = [-1,5,3,4,0] Output: [-1,0,3,4,5] &amp;nbsp; Constraints: The number of nodes in the list is in the range [1, 5000]. -5000 &amp;lt;= Node.val &amp;lt;= 5000 Solutions Insertion sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort. However, it has several advantages, such as simplicity and the ability to sort a list as it receives it. Code Explanation: Base Case Check: If the list is empty (head is None) or contains only one element (head.next is None), itâs already sorted, so return head. Dummy Head Initialization: A dummy node is created and pointed to the head of the list. This dummy node serves as an anchor and simplifies edge case handling, such as inserting elements at the head of the list. Iteration Setup: Two pointers, pre and cur, are initialized to help traverse the list. pre starts at the dummy node, and cur starts at the head of the list. The idea is to iterate through the list with cur, and for each node, find its correct position in the portion of the list before cur that has already been sorted. Main Loop: The loop continues as long as cur is not None, indicating there are still elements to be sorted. Direct Append Check: If the current element pointed by pre is less than or equal to cur, it means cur is already in the correct position relative to pre, so move both pointers forward. Finding Insertion Point: If cur needs to be moved to an earlier position to maintain sorting, start from the dummy node with a pointer p and move forward until finding the insertion point where p.next.val &amp;gt; cur.val. This indicates that cur should be inserted between p and p.next. Re-linking: Once the insertion point is found: Temporarily store cur.next in t, as the next element to sort after reinserting cur. Insert cur between p and p.next by setting cur.next = p.next and p.next = cur. Update pre.next to t because cur has been moved out of its original..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-04-25T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-04-25-147-Insertion-Sort-List/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-147.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="147 - Insertion Sort List" property="twitter:title"/>
   <meta content="Leetcode 147. Insertion Sort List Description Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list&amp;#39;s head. The steps of the insertion sort algorithm: Insertion sort iterates, consuming one input element each repetition and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there. It repeats until no input elements remain. The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration. &amp;nbsp; Example 1: Input: head = [4,2,1,3] Output: [1,2,3,4] Example 2: Input: head = [-1,5,3,4,0] Output: [-1,0,3,4,5] &amp;nbsp; Constraints: The number of nodes in the list is in the range [1, 5000]. -5000 &amp;lt;= Node.val &amp;lt;= 5000 Solutions Insertion sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort. However, it has several advantages, such as simplicity and the ability to sort a list as it receives it. Code Explanation: Base Case Check: If the list is empty (head is None) or contains only one element (head.next is None), itâs already sorted, so return head. Dummy Head Initialization: A dummy node is created and pointed to the head of the list. This dummy node serves as an anchor and simplifies edge case handling, such as inserting elements at the head of the list. Iteration Setup: Two pointers, pre and cur, are initialized to help traverse the list. pre starts at the dummy node, and cur starts at the head of the list. The idea is to iterate through the list with cur, and for each node, find its correct position in the portion of the list before cur that has already been sorted. Main Loop: The loop continues as long as cur is not None, indicating there are still elements to be sorted. Direct Append Check: If the current element pointed by pre is less than or equal to cur, it means cur is already in the correct position relative to pre, so move both pointers forward. Finding Insertion Point: If cur needs to be moved to an earlier position to maintain sorting, start from the dummy node with a pointer p and move forward until finding the insertion point where p.next.val &amp;gt; cur.val. This indicates that cur should be inserted between p and p.next. Re-linking: Once the insertion point is found: Temporarily store cur.next in t, as the next element to sort after reinserting cur. Insert cur between p and p.next by setting cur.next = p.next and p.next = cur. Update pre.next to t because cur has been moved out of its original..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    147 - Insertion Sort List | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="147 - Insertion Sort List" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-147.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-04-25-147-Insertion-Sort-List/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-04-25T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"147 - Insertion Sort List","dateModified":"2016-04-25T00:00:00-07:00","datePublished":"2016-04-25T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-04-25-147-Insertion-Sort-List/"},"url":"https://leetcode.ca/2016-04-25-147-Insertion-Sort-List/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="147-insertion-sort-list">
       <a href="solution-147.html">
        147. Insertion Sort List
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given the
       <code>
        head
       </code>
       of a singly linked list, sort the list using
       <strong>
        insertion sort
       </strong>
       , and return
       <em>
        the sorted list's head
       </em>
       .
      </p>
      <p>
       The steps of the
       <strong>
        insertion sort
       </strong>
       algorithm:
      </p>
      <ol>
       <li>
        Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.
       </li>
       <li>
        At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.
       </li>
       <li>
        It repeats until no input elements remain.
       </li>
      </ol>
      <p>
       The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0147.Insertion%20Sort%20List/images/Insertion-sort-example-300px.gif" style="height:180px; width:300px"/>
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0147.Insertion%20Sort%20List/images/sort1linked-list.jpg" style="width: 422px; height: 222px;"/>
      </p>
      <pre>
<strong>Input:</strong> head = [4,2,1,3]
<strong>Output:</strong> [1,2,3,4]
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0147.Insertion%20Sort%20List/images/sort2linked-list.jpg" style="width: 542px; height: 222px;"/>
      </p>
      <pre>
<strong>Input:</strong> head = [-1,5,3,4,0]
<strong>Output:</strong> [-1,0,3,4,5]
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the list is in the range
        <code>
         [1, 5000]
        </code>
        .
       </li>
       <li>
        <code>
         -5000 &lt;= Node.val &lt;= 5000
        </code>
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       Insertion sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort. However, it has several advantages, such as simplicity and the ability to sort a list as it receives it.
      </p>
      <h3 id="code-explanation">
       Code Explanation:
      </h3>
      <ol>
       <li>
        <p>
         <strong>
          Base Case Check
         </strong>
         : If the list is empty (
         <code class="language-plaintext highlighter-rouge">
          head is None
         </code>
         ) or contains only one element (
         <code class="language-plaintext highlighter-rouge">
          head.next is None
         </code>
         ), itâs already sorted, so return
         <code class="language-plaintext highlighter-rouge">
          head
         </code>
         .
        </p>
       </li>
       <li>
        <p>
         <strong>
          Dummy Head Initialization
         </strong>
         : A dummy node is created and pointed to the
         <code class="language-plaintext highlighter-rouge">
          head
         </code>
         of the list. This dummy node serves as an anchor and simplifies edge case handling, such as inserting elements at the head of the list.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Iteration Setup
         </strong>
         : Two pointers,
         <code class="language-plaintext highlighter-rouge">
          pre
         </code>
         and
         <code class="language-plaintext highlighter-rouge">
          cur
         </code>
         , are initialized to help traverse the list.
         <code class="language-plaintext highlighter-rouge">
          pre
         </code>
         starts at the dummy node, and
         <code class="language-plaintext highlighter-rouge">
          cur
         </code>
         starts at the
         <code class="language-plaintext highlighter-rouge">
          head
         </code>
         of the list. The idea is to iterate through the list with
         <code class="language-plaintext highlighter-rouge">
          cur
         </code>
         , and for each node, find its correct position in the portion of the list before
         <code class="language-plaintext highlighter-rouge">
          cur
         </code>
         that has already been sorted.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Main Loop
         </strong>
         : The loop continues as long as
         <code class="language-plaintext highlighter-rouge">
          cur
         </code>
         is not
         <code class="language-plaintext highlighter-rouge">
          None
         </code>
         , indicating there are still elements to be sorted.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Direct Append Check
         </strong>
         : If the current element pointed by
         <code class="language-plaintext highlighter-rouge">
          pre
         </code>
         is less than or equal to
         <code class="language-plaintext highlighter-rouge">
          cur
         </code>
         , it means
         <code class="language-plaintext highlighter-rouge">
          cur
         </code>
         is already in the correct position relative to
         <code class="language-plaintext highlighter-rouge">
          pre
         </code>
         , so move both pointers forward.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Finding Insertion Point
         </strong>
         : If
         <code class="language-plaintext highlighter-rouge">
          cur
         </code>
         needs to be moved to an earlier position to maintain sorting, start from the dummy node with a pointer
         <code class="language-plaintext highlighter-rouge">
          p
         </code>
         and move forward until finding the insertion point where
         <code class="language-plaintext highlighter-rouge">
          p.next.val &gt; cur.val
         </code>
         . This indicates that
         <code class="language-plaintext highlighter-rouge">
          cur
         </code>
         should be inserted between
         <code class="language-plaintext highlighter-rouge">
          p
         </code>
         and
         <code class="language-plaintext highlighter-rouge">
          p.next
         </code>
         .
        </p>
       </li>
       <li>
        <strong>
         Re-linking
        </strong>
        : Once the insertion point is found:
        <ul>
         <li>
          Temporarily store
          <code class="language-plaintext highlighter-rouge">
           cur.next
          </code>
          in
          <code class="language-plaintext highlighter-rouge">
           t
          </code>
          , as the next element to sort after reinserting
          <code class="language-plaintext highlighter-rouge">
           cur
          </code>
          .
         </li>
         <li>
          Insert
          <code class="language-plaintext highlighter-rouge">
           cur
          </code>
          between
          <code class="language-plaintext highlighter-rouge">
           p
          </code>
          and
          <code class="language-plaintext highlighter-rouge">
           p.next
          </code>
          by setting
          <code class="language-plaintext highlighter-rouge">
           cur.next = p.next
          </code>
          and
          <code class="language-plaintext highlighter-rouge">
           p.next = cur
          </code>
          .
         </li>
         <li>
          Update
          <code class="language-plaintext highlighter-rouge">
           pre.next
          </code>
          to
          <code class="language-plaintext highlighter-rouge">
           t
          </code>
          because
          <code class="language-plaintext highlighter-rouge">
           cur
          </code>
          has been moved out of its original position.
         </li>
         <li>
          Move
          <code class="language-plaintext highlighter-rouge">
           cur
          </code>
          to
          <code class="language-plaintext highlighter-rouge">
           t
          </code>
          , preparing for the next iteration.
         </li>
        </ul>
       </li>
       <li>
        <strong>
         Return
        </strong>
        : Once all elements have been correctly positioned, return
        <code class="language-plaintext highlighter-rouge">
         dummy.next
        </code>
        , which points to the head of the newly sorted list.
       </li>
      </ol>
      <h3 id="important-points">
       Important Points:
      </h3>
      <ul>
       <li>
        The use of a dummy head node simplifies edge cases, especially when inserting at the beginning of the list.
       </li>
       <li>
        The algorithm iteratively takes each element from the unsorted portion of the list and finds its correct position in the sorted portion, effectively extending the sorted portion one element at a time.
       </li>
       <li>
        The while loop that moves pointer
        <code class="language-plaintext highlighter-rouge">
         p
        </code>
        is crucial for maintaining the sorted order by finding the correct insertion point for each element in
        <code class="language-plaintext highlighter-rouge">
         cur
        </code>
        .
       </li>
      </ul>
      <ul class="uk-tab" data-uk-switcher="{connect:'#36607087-c0c9-490c-9cb5-c4561152962e'}">
       <li class="uk-active">
        <a href="solution-147.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-147.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-147.html">
         Javascript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="36607087-c0c9-490c-9cb5-c4561152962e">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">insertionSortList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="n">head</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pre</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;=</span> <span class="n">cur</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="nc">ListNode</span> <span class="n">p</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;=</span> <span class="n">cur</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="nc">ListNode</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
            <span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">insertionSortList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">head</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">head</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span>
        <span class="n">pre</span><span class="p">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pre</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">cur</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">pre</span><span class="p">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">,</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
                <span class="k">continue</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">dummy</span>
            <span class="k">while</span> <span class="n">p</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">cur</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">p</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">cur</span>
            <span class="n">pre</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">t</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">t</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-js highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */</span>
<span class="cm">/**
 * @param {ListNode} head
 * @return {ListNode}
 */</span>
<span class="kd">var</span> <span class="nx">insertionSortList</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="nx">head</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">head</span><span class="p">.</span><span class="nx">val</span><span class="p">,</span> <span class="nx">head</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">prev</span> <span class="o">=</span> <span class="nx">dummy</span><span class="p">,</span>
        <span class="nx">cur</span> <span class="o">=</span> <span class="nx">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">prev</span><span class="p">.</span><span class="nx">val</span> <span class="o">&lt;=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">prev</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">;</span>
            <span class="nx">cur</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">dummy</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">val</span> <span class="o">&lt;=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">p</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
        <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
        <span class="nx">p</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">;</span>
        <span class="nx">prev</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">t</span><span class="p">;</span>
        <span class="nx">cur</span> <span class="o">=</span> <span class="nx">t</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">dummy</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
<span class="p">};</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-147.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
