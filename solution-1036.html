<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-1036.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-1036.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>1036 - Escape a Large Maze</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 1036. Escape a Large Maze Description There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square are (x, y). We start at the source = [sx, sy] square and want to reach the target = [tx,...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-1036.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-1036.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-1036.html" rel="stylesheet"/>
   <link href="solution-1036.html" rel="stylesheet"/>
   <link href="solution-1036.html" rel="stylesheet"/>
   <link href="solution-1036.html" rel="stylesheet"/>
   <link href="solution-1036.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="1036 - Escape a Large Maze" property="og:title"/>
   <meta content="Leetcode 1036. Escape a Large Maze Description There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square are (x, y). We start at the source = [sx, sy] square and want to reach the target = [tx, ty] square. There is also an array of blocked squares, where each blocked[i] = [xi, yi] represents a blocked square with coordinates (xi, yi). Each move, we can walk one square north, east, south, or west if the square is not in the array of blocked squares. We are also not allowed to walk outside of the grid. Return true if and only if it is possible to reach the target square from the source square through a sequence of valid moves. &amp;nbsp; Example 1: Input: blocked = [[0,1],[1,0]], source = [0,0], target = [0,2] Output: false Explanation: The target square is inaccessible starting from the source square because we cannot move. We cannot move north or east because those squares are blocked. We cannot move south or west because we cannot go outside of the grid. Example 2: Input: blocked = [], source = [0,0], target = [999999,999999] Output: true Explanation: Because there are no blocked cells, it is possible to reach the target square. &amp;nbsp; Constraints: 0 &amp;lt;= blocked.length &amp;lt;= 200 blocked[i].length == 2 0 &amp;lt;= xi, yi &amp;lt; 106 source.length == target.length == 2 0 &amp;lt;= sx, sy, tx, ty &amp;lt; 106 source != target It is guaranteed that source and target are not blocked. Solutions Java C++ Python Go RenderScript class Solution { private int[][] dirs = new int[][] { {1, 0}, {-1, 0}, {0, 1}, {0, -1} }; private static final int N = (int) 1e6; private Set&amp;lt;Integer&amp;gt; blocked; public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) { this.blocked = new HashSet&amp;lt;&amp;gt;(); for (int[] b : blocked) { this.blocked.add(b[0] * N + b[1]); } return dfs(source, target, new HashSet&amp;lt;&amp;gt;()) &amp;amp;&amp;amp; dfs(target, source, new HashSet&amp;lt;&amp;gt;()); } private boolean dfs(int[] source, int[] target, Set&amp;lt;Integer&amp;gt; seen) { int sx = source[0], sy = source[1]; int tx = target[0], ty = target[1]; if (sx &amp;lt; 0 || sx &amp;gt;= N || sy &amp;lt; 0 || sy &amp;gt;= N || tx &amp;lt; 0 || tx &amp;gt;= N || ty &amp;lt; 0 || ty &amp;gt;= N || blocked.contains(sx * N + sy) || seen.contains(sx * N + sy)) { return false; } seen.add(sx * N + sy); if (seen.size() &amp;gt; 20000 || (sx == target[0] &amp;amp;&amp;amp; sy == target[1])) { return true; } for (int[] dir : dirs) { if (dfs(new int[] {sx + dir[0], sy + dir[1]}, target, seen)) { return true; } } return false; } } typedef unsigned long long ULL; class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dirs = { {0, 1}, {0, -1}, {1, 0}, {-1, 0} }; unordered_set&amp;lt;ULL&amp;gt; blocked; int N = 1e6; bool isEscapePossible(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; blocked, vector&amp;lt;int&amp;gt;&amp;amp; source, vector&amp;lt;int&amp;gt;&amp;amp; target) { this-&amp;gt;blocked.clear(); for (auto&amp;amp; b : blocked) this-&amp;gt;blocked.insert((ULL) b[0] * N + b[1]); unordered_set&amp;lt;ULL&amp;gt; s1; unordered_set&amp;lt;ULL&amp;gt; s2;..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2018-10-01T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2018-10-01-1036-Escape-a-Large-Maze/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-1036.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="1036 - Escape a Large Maze" property="twitter:title"/>
   <meta content="Leetcode 1036. Escape a Large Maze Description There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square are (x, y). We start at the source = [sx, sy] square and want to reach the target = [tx, ty] square. There is also an array of blocked squares, where each blocked[i] = [xi, yi] represents a blocked square with coordinates (xi, yi). Each move, we can walk one square north, east, south, or west if the square is not in the array of blocked squares. We are also not allowed to walk outside of the grid. Return true if and only if it is possible to reach the target square from the source square through a sequence of valid moves. &amp;nbsp; Example 1: Input: blocked = [[0,1],[1,0]], source = [0,0], target = [0,2] Output: false Explanation: The target square is inaccessible starting from the source square because we cannot move. We cannot move north or east because those squares are blocked. We cannot move south or west because we cannot go outside of the grid. Example 2: Input: blocked = [], source = [0,0], target = [999999,999999] Output: true Explanation: Because there are no blocked cells, it is possible to reach the target square. &amp;nbsp; Constraints: 0 &amp;lt;= blocked.length &amp;lt;= 200 blocked[i].length == 2 0 &amp;lt;= xi, yi &amp;lt; 106 source.length == target.length == 2 0 &amp;lt;= sx, sy, tx, ty &amp;lt; 106 source != target It is guaranteed that source and target are not blocked. Solutions Java C++ Python Go RenderScript class Solution { private int[][] dirs = new int[][] { {1, 0}, {-1, 0}, {0, 1}, {0, -1} }; private static final int N = (int) 1e6; private Set&amp;lt;Integer&amp;gt; blocked; public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) { this.blocked = new HashSet&amp;lt;&amp;gt;(); for (int[] b : blocked) { this.blocked.add(b[0] * N + b[1]); } return dfs(source, target, new HashSet&amp;lt;&amp;gt;()) &amp;amp;&amp;amp; dfs(target, source, new HashSet&amp;lt;&amp;gt;()); } private boolean dfs(int[] source, int[] target, Set&amp;lt;Integer&amp;gt; seen) { int sx = source[0], sy = source[1]; int tx = target[0], ty = target[1]; if (sx &amp;lt; 0 || sx &amp;gt;= N || sy &amp;lt; 0 || sy &amp;gt;= N || tx &amp;lt; 0 || tx &amp;gt;= N || ty &amp;lt; 0 || ty &amp;gt;= N || blocked.contains(sx * N + sy) || seen.contains(sx * N + sy)) { return false; } seen.add(sx * N + sy); if (seen.size() &amp;gt; 20000 || (sx == target[0] &amp;amp;&amp;amp; sy == target[1])) { return true; } for (int[] dir : dirs) { if (dfs(new int[] {sx + dir[0], sy + dir[1]}, target, seen)) { return true; } } return false; } } typedef unsigned long long ULL; class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dirs = { {0, 1}, {0, -1}, {1, 0}, {-1, 0} }; unordered_set&amp;lt;ULL&amp;gt; blocked; int N = 1e6; bool isEscapePossible(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; blocked, vector&amp;lt;int&amp;gt;&amp;amp; source, vector&amp;lt;int&amp;gt;&amp;amp; target) { this-&amp;gt;blocked.clear(); for (auto&amp;amp; b : blocked) this-&amp;gt;blocked.insert((ULL) b[0] * N + b[1]); unordered_set&amp;lt;ULL&amp;gt; s1; unordered_set&amp;lt;ULL&amp;gt; s2;..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    1036 - Escape a Large Maze | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="1036 - Escape a Large Maze" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-1036.html" rel="canonical">
          <meta content="https://leetcode.ca/2018-10-01-1036-Escape-a-Large-Maze/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2018-10-01T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"1036 - Escape a Large Maze","dateModified":"2018-10-01T00:00:00-07:00","datePublished":"2018-10-01T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2018-10-01-1036-Escape-a-Large-Maze/"},"url":"https://leetcode.ca/2018-10-01-1036-Escape-a-Large-Maze/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="1036-escape-a-large-maze">
       <a href="solution-1036.html">
        1036. Escape a Large Maze
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square are
       <code>
        (x, y)
       </code>
       .
      </p>
      <p>
       We start at the
       <code>
        source = [s
        <sub>
         x
        </sub>
        , s
        <sub>
         y
        </sub>
        ]
       </code>
       square and want to reach the
       <code>
        target = [t
        <sub>
         x
        </sub>
        , t
        <sub>
         y
        </sub>
        ]
       </code>
       square. There is also an array of
       <code>
        blocked
       </code>
       squares, where each
       <code>
        blocked[i] = [x
        <sub>
         i
        </sub>
        , y
        <sub>
         i
        </sub>
        ]
       </code>
       represents a blocked square with coordinates
       <code>
        (x
        <sub>
         i
        </sub>
        , y
        <sub>
         i
        </sub>
        )
       </code>
       .
      </p>
      <p>
       Each move, we can walk one square north, east, south, or west if the square is
       <strong>
        not
       </strong>
       in the array of
       <code>
        blocked
       </code>
       squares. We are also not allowed to walk outside of the grid.
      </p>
      <p>
       Return
       <code>
        true
       </code>
       <em>
        if and only if it is possible to reach the
       </em>
       <code>
        target
       </code>
       <em>
        square from the
       </em>
       <code>
        source
       </code>
       <em>
        square through a sequence of valid moves
       </em>
       .
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]
<strong>Output:</strong> false
<strong>Explanation:</strong> The target square is inaccessible starting from the source square because we cannot move.
We cannot move north or east because those squares are blocked.
We cannot move south or west because we cannot go outside of the grid.
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> blocked = [], source = [0,0], target = [999999,999999]
<strong>Output:</strong> true
<strong>Explanation:</strong> Because there are no blocked cells, it is possible to reach the target square.
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         0 &lt;= blocked.length &lt;= 200
        </code>
       </li>
       <li>
        <code>
         blocked[i].length == 2
        </code>
       </li>
       <li>
        <code>
         0 &lt;= x
         <sub>
          i
         </sub>
         , y
         <sub>
          i
         </sub>
         &lt; 10
         <sup>
          6
         </sup>
        </code>
       </li>
       <li>
        <code>
         source.length == target.length == 2
        </code>
       </li>
       <li>
        <code>
         0 &lt;= s
         <sub>
          x
         </sub>
         , s
         <sub>
          y
         </sub>
         , t
         <sub>
          x
         </sub>
         , t
         <sub>
          y
         </sub>
         &lt; 10
         <sup>
          6
         </sup>
        </code>
       </li>
       <li>
        <code>
         source != target
        </code>
       </li>
       <li>
        It is guaranteed that
        <code>
         source
        </code>
        and
        <code>
         target
        </code>
        are not blocked.
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <ul class="uk-tab" data-uk-switcher="{connect:'#a3e30840-bbec-4723-bdd2-6bb3e6419965'}">
       <li class="uk-active">
        <a href="solution-1036.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-1036.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-1036.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-1036.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-1036.html">
         RenderScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="a3e30840-bbec-4723-bdd2-6bb3e6419965">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">dirs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[][]</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">}</span> <span class="o">};</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="mi">1</span><span class="n">e6</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">blocked</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEscapePossible</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">blocked</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">source</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">blocked</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">b</span> <span class="o">:</span> <span class="n">blocked</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">blocked</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">*</span> <span class="no">N</span> <span class="o">+</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">target</span><span class="o">,</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;())</span> <span class="o">&amp;&amp;</span> <span class="n">dfs</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">source</span><span class="o">,</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;());</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">source</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">target</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">seen</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sx</span> <span class="o">=</span> <span class="n">source</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">sy</span> <span class="o">=</span> <span class="n">source</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">target</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">ty</span> <span class="o">=</span> <span class="n">target</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">sx</span> <span class="o">&gt;=</span> <span class="no">N</span> <span class="o">||</span> <span class="n">sy</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">sy</span> <span class="o">&gt;=</span> <span class="no">N</span> <span class="o">||</span> <span class="n">tx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tx</span> <span class="o">&gt;=</span> <span class="no">N</span> <span class="o">||</span> <span class="n">ty</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ty</span> <span class="o">&gt;=</span> <span class="no">N</span>
            <span class="o">||</span> <span class="n">blocked</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">sx</span> <span class="o">*</span> <span class="no">N</span> <span class="o">+</span> <span class="n">sy</span><span class="o">)</span> <span class="o">||</span> <span class="n">seen</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">sx</span> <span class="o">*</span> <span class="no">N</span> <span class="o">+</span> <span class="n">sy</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">seen</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">sx</span> <span class="o">*</span> <span class="no">N</span> <span class="o">+</span> <span class="n">sy</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">seen</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">20000</span> <span class="o">||</span> <span class="o">(</span><span class="n">sx</span> <span class="o">==</span> <span class="n">target</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">sy</span> <span class="o">==</span> <span class="n">target</span><span class="o">[</span><span class="mi">1</span><span class="o">]))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">dir</span> <span class="o">:</span> <span class="n">dirs</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">sx</span> <span class="o">+</span> <span class="n">dir</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">sy</span> <span class="o">+</span> <span class="n">dir</span><span class="o">[</span><span class="mi">1</span><span class="o">]},</span> <span class="n">target</span><span class="o">,</span> <span class="n">seen</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ULL</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">dirs</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span> <span class="p">};</span>
    <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">ULL</span><span class="o">&gt;</span> <span class="n">blocked</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mf">1e6</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">isEscapePossible</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">blocked</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">:</span> <span class="n">blocked</span><span class="p">)</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">.</span><span class="n">insert</span><span class="p">((</span><span class="n">ULL</span><span class="p">)</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">ULL</span><span class="o">&gt;</span> <span class="n">s1</span><span class="p">;</span>
        <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">ULL</span><span class="o">&gt;</span> <span class="n">s2</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">dfs</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">target</span><span class="p">,</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">ULL</span><span class="o">&gt;&amp;</span> <span class="n">seen</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sx</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sy</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ty</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">sx</span> <span class="o">&gt;=</span> <span class="n">N</span> <span class="o">||</span> <span class="n">sy</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">sy</span> <span class="o">&gt;=</span> <span class="n">N</span> <span class="o">||</span> <span class="n">tx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tx</span> <span class="o">&gt;=</span> <span class="n">N</span> <span class="o">||</span> <span class="n">ty</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ty</span> <span class="o">&gt;=</span> <span class="n">N</span> <span class="o">||</span> <span class="n">blocked</span><span class="p">.</span><span class="n">count</span><span class="p">((</span><span class="n">ULL</span><span class="p">)</span> <span class="n">sx</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">sy</span><span class="p">)</span> <span class="o">||</span> <span class="n">seen</span><span class="p">.</span><span class="n">count</span><span class="p">((</span><span class="n">ULL</span><span class="p">)</span> <span class="n">sx</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">sy</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">seen</span><span class="p">.</span><span class="n">insert</span><span class="p">((</span><span class="n">ULL</span><span class="p">)</span> <span class="n">sx</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">sy</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">seen</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">20000</span> <span class="o">||</span> <span class="p">(</span><span class="n">sx</span> <span class="o">==</span> <span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">sy</span> <span class="o">==</span> <span class="n">target</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">dir</span> <span class="o">:</span> <span class="n">dirs</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="p">{</span><span class="n">sx</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sy</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="mi">1</span><span class="p">]};</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">seen</span><span class="p">))</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isEscapePossible</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">blocked</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">source</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">seen</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">source</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">blocked</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">seen</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">20000</span> <span class="ow">or</span> <span class="n">source</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]:</span>
                <span class="nb">next</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">b</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">dfs</span><span class="p">(</span><span class="nb">next</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">seen</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="n">blocked</span> <span class="o">=</span> <span class="nb">set</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">blocked</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span> <span class="ow">and</span> <span class="n">dfs</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">isEscapePossible</span><span class="p">(</span><span class="n">blocked</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="n">source</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">target</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">const</span> <span class="n">N</span> <span class="o">=</span> <span class="m">1e6</span>
	<span class="n">dirs</span> <span class="o">:=</span> <span class="p">[</span><span class="m">4</span><span class="p">][</span><span class="m">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span> <span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="o">-</span><span class="m">1</span><span class="p">},</span> <span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">},</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">}</span> <span class="p">}</span>
	<span class="n">block</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">blocked</span> <span class="p">{</span>
		<span class="n">block</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="n">b</span><span class="p">[</span><span class="m">1</span><span class="p">]]</span> <span class="o">=</span> <span class="no">true</span>
	<span class="p">}</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">seen</span> <span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">seen</span> <span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="n">sx</span><span class="p">,</span> <span class="n">sy</span> <span class="o">:=</span> <span class="n">source</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="n">source</span><span class="p">[</span><span class="m">1</span><span class="p">]</span>
		<span class="n">tx</span><span class="p">,</span> <span class="n">ty</span> <span class="o">:=</span> <span class="n">target</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="n">target</span><span class="p">[</span><span class="m">1</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">sx</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="o">||</span> <span class="n">sx</span> <span class="o">&gt;=</span> <span class="n">N</span> <span class="o">||</span> <span class="n">sy</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="o">||</span> <span class="n">sy</span> <span class="o">&gt;=</span> <span class="n">N</span> <span class="o">||</span> <span class="n">tx</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="o">||</span> <span class="n">tx</span> <span class="o">&gt;=</span> <span class="n">N</span> <span class="o">||</span> <span class="n">ty</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="o">||</span> <span class="n">ty</span> <span class="o">&gt;=</span> <span class="n">N</span> <span class="o">||</span> <span class="n">block</span><span class="p">[</span><span class="n">sx</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="n">sy</span><span class="p">]</span> <span class="o">||</span> <span class="n">seen</span><span class="p">[</span><span class="n">sx</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="n">sy</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="no">false</span>
		<span class="p">}</span>
		<span class="n">seen</span><span class="p">[</span><span class="n">sx</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="n">sy</span><span class="p">]</span> <span class="o">=</span> <span class="no">true</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">20000</span> <span class="o">||</span> <span class="p">(</span><span class="n">sx</span> <span class="o">==</span> <span class="n">target</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">sy</span> <span class="o">==</span> <span class="n">target</span><span class="p">[</span><span class="m">1</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">return</span> <span class="no">true</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">dir</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">dirs</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="n">sx</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="n">sy</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="m">1</span><span class="p">]}</span>
			<span class="k">if</span> <span class="n">dfs</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">seen</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="no">true</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="no">false</span>
	<span class="p">}</span>
	<span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span><span class="p">),</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">dfs</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-rs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::{</span> <span class="n">HashSet</span><span class="p">,</span> <span class="n">VecDeque</span> <span class="p">};</span>

<span class="k">const</span> <span class="n">BOUNDARY</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="mi">1_000_000</span><span class="p">;</span>
<span class="k">const</span> <span class="n">MAX</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">Solution</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">is_escape_possible</span><span class="p">(</span><span class="n">blocked</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">block</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">blocked</span><span class="nf">.len</span><span class="p">());</span>
        <span class="k">for</span> <span class="n">b</span> <span class="k">in</span> <span class="n">blocked</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">block</span><span class="nf">.insert</span><span class="p">((</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
        <span class="p">}</span>
        <span class="nf">bfs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">source</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">target</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">bfs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">target</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">source</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">block</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">dir</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)];</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">queue</span> <span class="o">=</span> <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">vis</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">queue</span><span class="nf">.push_back</span><span class="p">((</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
    <span class="n">vis</span><span class="nf">.insert</span><span class="p">((</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>

    <span class="k">while</span> <span class="o">!</span><span class="n">queue</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">vis</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">MAX</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">queue</span><span class="nf">.pop_front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">target</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span> <span class="k">in</span> <span class="n">dir</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">);</span>
            <span class="k">if</span>
                <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">||</span>
                <span class="n">nx</span> <span class="o">&gt;=</span> <span class="n">BOUNDARY</span> <span class="p">||</span>
                <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">||</span>
                <span class="n">ny</span> <span class="o">&gt;=</span> <span class="n">BOUNDARY</span> <span class="p">||</span>
                <span class="n">vis</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">))</span> <span class="p">||</span>
                <span class="n">block</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">queue</span><span class="nf">.push_back</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">));</span>
            <span class="n">vis</span><span class="nf">.insert</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">vis</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">MAX</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-1036.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
