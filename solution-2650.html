<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-2650.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-2650.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>2650 - Design Cancellable Function</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 2650. Design Cancellable Function Description Sometimes you have a long running task, and you may wish to cancel it before it completes. To help with this goal, write a function&amp;nbsp;cancellable that accepts a generator object and returns an array of two values: a cancel function...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-2650.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-2650.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-2650.html" rel="stylesheet"/>
   <link href="solution-2650.html" rel="stylesheet"/>
   <link href="solution-2650.html" rel="stylesheet"/>
   <link href="solution-2650.html" rel="stylesheet"/>
   <link href="solution-2650.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="2650 - Design Cancellable Function" property="og:title"/>
   <meta content="Leetcode 2650. Design Cancellable Function Description Sometimes you have a long running task, and you may wish to cancel it before it completes. To help with this goal, write a function&amp;nbsp;cancellable that accepts a generator object and returns an array of two values: a cancel function and a promise. You may assume the generator function will only&amp;nbsp;yield promises. It is your function&amp;#39;s responsibility to pass the values resolved by the promise back to the generator. If the promise rejects, your function should throw that&amp;nbsp;error back to the generator. If the cancel callback is called before the generator is done, your function should throw an error back to the generator. That error should be the string&amp;nbsp;&amp;quot;Cancelled&amp;quot;&amp;nbsp;(Not an Error&amp;nbsp;object). If the error was caught, the returned&amp;nbsp;promise should resolve with the next value that was yielded or returned. Otherwise, the promise should reject with the thrown error. No more code should be executed. When the generator is done, the promise your function returned should resolve the value the generator returned. If, however, the generator throws an error, the returned promise should reject with the error. An example of how your code would be used: function* tasks() { const val = yield new Promise(resolve =&amp;gt; resolve(2 + 2)); yield new Promise(resolve =&amp;gt; setTimeout(resolve, 100)); return val + 1; // calculation shouldn&amp;#39;t be done. } const [cancel, promise] = cancellable(tasks()); setTimeout(cancel, 50); promise.catch(console.log); // logs &amp;quot;Cancelled&amp;quot; at t=50ms If&amp;nbsp;instead&amp;nbsp;cancel() was not called or was called after t=100ms, the promise would&amp;nbsp;have resolved&amp;nbsp;5. &amp;nbsp; Example 1: Input: generatorFunction = function*() { &amp;nbsp; return 42; } cancelledAt = 100 Output: {&amp;quot;resolved&amp;quot;: 42} Explanation: const generator = generatorFunction(); const [cancel, promise] = cancellable(generator); setTimeout(cancel, 100); promise.then(console.log); // resolves 42 at t=0ms The generator immediately yields 42 and finishes. Because of that, the returned promise immediately resolves 42. Note that cancelling a finished generator does nothing. Example 2: Input: generatorFunction = function*() { &amp;nbsp; const msg = yield new Promise(res =&amp;gt; res(&amp;quot;Hello&amp;quot;)); &amp;nbsp; throw `Error: ${msg}`; } cancelledAt = null Output: {&amp;quot;rejected&amp;quot;: &amp;quot;Error: Hello&amp;quot;} Explanation: A promise is yielded. The function handles this by waiting for it to resolve and then passes the resolved value back to the generator. Then an error is thrown which has the effect of causing the promise to reject with the same thrown error. Example 3: Input: generatorFunction = function*() { &amp;nbsp; yield new Promise(res =&amp;gt; setTimeout(res, 200)); &amp;nbsp; return &amp;quot;Success&amp;quot;; } cancelledAt = 100 Output: {&amp;quot;rejected&amp;quot;: &amp;quot;Cancelled&amp;quot;} Explanation: While the function is waiting for the yielded promise to resolve, cancel() is called. This causes an error message to be sent back to the generator. Since this error is uncaught, the returned promise rejected with this error. Example 4: Input: generatorFunction = function*() { &amp;nbsp; let result = 0; &amp;nbsp; yield new Promise(res =&amp;gt; setTimeout(res, 100)); &amp;nbsp; result += yield new Promise(res =&amp;gt; res(1)); &amp;nbsp; yield new Promise(res =&amp;gt; setTimeout(res, 100)); &amp;nbsp; result += yield new Promise(res =&amp;gt; res(1)); &amp;nbsp; return result; } cancelledAt = null Output: {&amp;quot;resolved&amp;quot;: 2} Explanation: 4..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2023-03-03T00:00:00-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2023-03-03-2650-Design-Cancellable-Function/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-2650.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="2650 - Design Cancellable Function" property="twitter:title"/>
   <meta content="Leetcode 2650. Design Cancellable Function Description Sometimes you have a long running task, and you may wish to cancel it before it completes. To help with this goal, write a function&amp;nbsp;cancellable that accepts a generator object and returns an array of two values: a cancel function and a promise. You may assume the generator function will only&amp;nbsp;yield promises. It is your function&amp;#39;s responsibility to pass the values resolved by the promise back to the generator. If the promise rejects, your function should throw that&amp;nbsp;error back to the generator. If the cancel callback is called before the generator is done, your function should throw an error back to the generator. That error should be the string&amp;nbsp;&amp;quot;Cancelled&amp;quot;&amp;nbsp;(Not an Error&amp;nbsp;object). If the error was caught, the returned&amp;nbsp;promise should resolve with the next value that was yielded or returned. Otherwise, the promise should reject with the thrown error. No more code should be executed. When the generator is done, the promise your function returned should resolve the value the generator returned. If, however, the generator throws an error, the returned promise should reject with the error. An example of how your code would be used: function* tasks() { const val = yield new Promise(resolve =&amp;gt; resolve(2 + 2)); yield new Promise(resolve =&amp;gt; setTimeout(resolve, 100)); return val + 1; // calculation shouldn&amp;#39;t be done. } const [cancel, promise] = cancellable(tasks()); setTimeout(cancel, 50); promise.catch(console.log); // logs &amp;quot;Cancelled&amp;quot; at t=50ms If&amp;nbsp;instead&amp;nbsp;cancel() was not called or was called after t=100ms, the promise would&amp;nbsp;have resolved&amp;nbsp;5. &amp;nbsp; Example 1: Input: generatorFunction = function*() { &amp;nbsp; return 42; } cancelledAt = 100 Output: {&amp;quot;resolved&amp;quot;: 42} Explanation: const generator = generatorFunction(); const [cancel, promise] = cancellable(generator); setTimeout(cancel, 100); promise.then(console.log); // resolves 42 at t=0ms The generator immediately yields 42 and finishes. Because of that, the returned promise immediately resolves 42. Note that cancelling a finished generator does nothing. Example 2: Input: generatorFunction = function*() { &amp;nbsp; const msg = yield new Promise(res =&amp;gt; res(&amp;quot;Hello&amp;quot;)); &amp;nbsp; throw `Error: ${msg}`; } cancelledAt = null Output: {&amp;quot;rejected&amp;quot;: &amp;quot;Error: Hello&amp;quot;} Explanation: A promise is yielded. The function handles this by waiting for it to resolve and then passes the resolved value back to the generator. Then an error is thrown which has the effect of causing the promise to reject with the same thrown error. Example 3: Input: generatorFunction = function*() { &amp;nbsp; yield new Promise(res =&amp;gt; setTimeout(res, 200)); &amp;nbsp; return &amp;quot;Success&amp;quot;; } cancelledAt = 100 Output: {&amp;quot;rejected&amp;quot;: &amp;quot;Cancelled&amp;quot;} Explanation: While the function is waiting for the yielded promise to resolve, cancel() is called. This causes an error message to be sent back to the generator. Since this error is uncaught, the returned promise rejected with this error. Example 4: Input: generatorFunction = function*() { &amp;nbsp; let result = 0; &amp;nbsp; yield new Promise(res =&amp;gt; setTimeout(res, 100)); &amp;nbsp; result += yield new Promise(res =&amp;gt; res(1)); &amp;nbsp; yield new Promise(res =&amp;gt; setTimeout(res, 100)); &amp;nbsp; result += yield new Promise(res =&amp;gt; res(1)); &amp;nbsp; return result; } cancelledAt = null Output: {&amp;quot;resolved&amp;quot;: 2} Explanation: 4..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    2650 - Design Cancellable Function | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="2650 - Design Cancellable Function" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-2650.html" rel="canonical">
          <meta content="https://leetcode.ca/2023-03-03-2650-Design-Cancellable-Function/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2023-03-03T00:00:00-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"2650 - Design Cancellable Function","dateModified":"2023-03-03T00:00:00-08:00","datePublished":"2023-03-03T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2023-03-03-2650-Design-Cancellable-Function/"},"url":"https://leetcode.ca/2023-03-03-2650-Design-Cancellable-Function/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="2650-design-cancellable-function">
       <a href="solution-2650.html">
        2650. Design Cancellable Function
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Sometimes you have a long running task, and you may wish to cancel it before it completes. To help with this goal, write a function
       <code>
        cancellable
       </code>
       that accepts a generator object and returns an array of two values: a
       <strong>
        cancel function
       </strong>
       and a
       <strong>
        promise
       </strong>
       .
      </p>
      <p>
       You may assume the generator function will only yield promises. It is your function's responsibility to pass the values resolved by the promise back to the generator. If the promise rejects, your function should throw that error back to the generator.
      </p>
      <p>
       If the cancel callback is called before the generator is done, your function should throw an error back to the generator. That error should be the string
       <code>
        "Cancelled"
       </code>
       (Not an
       <code>
        Error
       </code>
       object). If the error was caught, the returned promise should resolve with the next value that was yielded or returned. Otherwise, the promise should reject with the thrown error. No more code should be executed.
      </p>
      <p>
       When the generator is done, the promise your function returned should resolve the value the generator returned. If, however, the generator throws an error, the returned promise should reject with the error.
      </p>
      <p>
       An example of how your code would be used:
      </p>
      <pre>
function* tasks() {
  const val = yield new Promise(resolve =&gt; resolve(2 + 2));
  yield new Promise(resolve =&gt; setTimeout(resolve, 100));
  return val + 1; // calculation shouldn't be done.
}
const [cancel, promise] = cancellable(tasks());
setTimeout(cancel, 50);
promise.catch(console.log); // logs "Cancelled" at t=50ms
</pre>
      <p>
       If instead
       <code>
        cancel()
       </code>
       was not called or was called after
       <code>
        t=100ms
       </code>
       , the promise would have resolved
       <code>
        5
       </code>
       .
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> 
generatorFunction = function*() { 
  return 42; 
}
cancelledAt = 100
<strong>Output:</strong> {"resolved": 42}
<strong>Explanation:</strong>
const generator = generatorFunction();
const [cancel, promise] = cancellable(generator);
setTimeout(cancel, 100);
promise.then(console.log); // resolves 42 at t=0ms

The generator immediately yields 42 and finishes. Because of that, the returned promise immediately resolves 42. Note that cancelling a finished generator does nothing.
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong>
generatorFunction = function*() { 
  const msg = yield new Promise(res =&gt; res("Hello")); 
  throw `Error: ${msg}`; 
}
cancelledAt = null
<strong>Output:</strong> {"rejected": "Error: Hello"}
<strong>Explanation:</strong>
A promise is yielded. The function handles this by waiting for it to resolve and then passes the resolved value back to the generator. Then an error is thrown which has the effect of causing the promise to reject with the same thrown error.
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> 
generatorFunction = function*() { 
  yield new Promise(res =&gt; setTimeout(res, 200)); 
  return "Success"; 
}
cancelledAt = 100
<strong>Output:</strong> {"rejected": "Cancelled"}
<strong>Explanation:</strong>
While the function is waiting for the yielded promise to resolve, cancel() is called. This causes an error message to be sent back to the generator. Since this error is uncaught, the returned promise rejected with this error.
</pre>
      <p>
       <strong class="example">
        Example 4:
       </strong>
      </p>
      <pre>
<strong>Input:</strong>
generatorFunction = function*() { 
  let result = 0; 
  yield new Promise(res =&gt; setTimeout(res, 100));
  result += yield new Promise(res =&gt; res(1)); 
  yield new Promise(res =&gt; setTimeout(res, 100)); 
  result += yield new Promise(res =&gt; res(1)); 
  return result;
}
cancelledAt = null
<strong>Output:</strong> {"resolved": 2}
<strong>Explanation:</strong>
4 promises are yielded. Two of those promises have their values added to the result. After 200ms, the generator finishes with a value of 2, and that value is resolved by the returned promise.
</pre>
      <p>
       <strong class="example">
        Example 5:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> 
generatorFunction = function*() { 
  let result = 0; 
  try { 
    yield new Promise(res =&gt; setTimeout(res, 100)); 
    result += yield new Promise(res =&gt; res(1)); 
    yield new Promise(res =&gt; setTimeout(res, 100)); 
    result += yield new Promise(res =&gt; res(1)); 
  } catch(e) { 
    return result; 
  } 
  return result; 
}
cancelledAt = 150
<strong>Output:</strong> {"resolved": 1}
<strong>Explanation:</strong>
The first two yielded promises resolve and cause the result to increment. However, at t=150ms, the generator is cancelled. The error sent to the generator is caught and the result is returned and finally resolved by the returned promise.
</pre>
      <p>
       <strong class="example">
        Example 6:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> 
generatorFunction = function*() { 
  try { 
    yield new Promise((resolve, reject) =&gt; reject("Promise Rejected")); 
  } catch(e) { 
    let a = yield new Promise(resolve =&gt; resolve(2));
    let b = yield new Promise(resolve =&gt; resolve(2)); 
    return a + b; 
  }; 
}
cancelledAt = null
<strong>Output:</strong> {"resolved": 4}
<strong>Explanation:</strong>
The first yielded promise immediately rejects. This error is caught. Because the generator hasn't been cancelled, execution continues as usual. It ends up resolving 2 + 2 = 4.</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         cancelledAt == null or 0 &lt;= cancelledAt &lt;= 1000
        </code>
       </li>
       <li>
        <code>
         generatorFunction
        </code>
        returns a generator object
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <ul class="uk-tab" data-uk-switcher="{connect:'#5ed6e175-f460-4d4e-bcd0-64843d27f391'}">
       <li class="uk-active">
        <a href="solution-2650.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="5ed6e175-f460-4d4e-bcd0-64843d27f391">
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">function</span> <span class="nx">cancellable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">generator</span><span class="p">:</span> <span class="nx">Generator</span><span class="o">&lt;</span><span class="nb">Promise</span><span class="o">&lt;</span><span class="kr">any</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">unknown</span><span class="o">&gt;</span><span class="p">):</span> <span class="p">[()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">,</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">cancel</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{};</span>
    <span class="kd">const</span> <span class="nx">cancelPromise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">cancel</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">reject</span><span class="p">(</span><span class="dl">'</span><span class="s1">Cancelled</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="nx">cancelPromise</span><span class="p">.</span><span class="k">catch</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{});</span>

    <span class="kd">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">next</span> <span class="o">=</span> <span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">next</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="nx">next</span> <span class="o">=</span> <span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="k">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span><span class="nx">next</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">cancelPromise</span><span class="p">]));</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">next</span> <span class="o">=</span> <span class="nx">generator</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">next</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="p">})();</span>

    <span class="k">return</span> <span class="p">[</span><span class="nx">cancel</span><span class="p">,</span> <span class="nx">promise</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**
 * function* tasks() {
 *   const val = yield new Promise(resolve =&gt; resolve(2 + 2));
 *   yield new Promise(resolve =&gt; setTimeout(resolve, 100));
 *   return val + 1;
 * }
 * const [cancel, promise] = cancellable(tasks());
 * setTimeout(cancel, 50);
 * promise.catch(console.log); // logs "Cancelled" at t=50ms
 */</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-2650.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
