<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-538.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-538.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>538 - Convert BST to Greater Tree</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode Formatted question description: https://leetcode.ca/all/538.html 538. Convert BST to Greater Tree Level Easy Description Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-538.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-538.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-538.html" rel="stylesheet"/>
   <link href="solution-538.html" rel="stylesheet"/>
   <link href="solution-538.html" rel="stylesheet"/>
   <link href="solution-538.html" rel="stylesheet"/>
   <link href="solution-538.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="538 - Convert BST to Greater Tree" property="og:title"/>
   <meta content="Leetcode Formatted question description: https://leetcode.ca/all/538.html 538. Convert BST to Greater Tree Level Easy Description Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. Example: Input: The root of a Binary Search Tree like this: 5 / \ 2 13 Output: The root of a Greater Tree like this: 18 / \ 20 13 Solution Same but just left/right mirror of https://leetcode.ca/2016-03-03-94-Binary-Tree-Inorder-Traversal Begin by obtaining the inorder traversal of the binary search tree. This traversal lists all the nodes of the tree in ascending order based on their values. Next, iterate over the inorder traversal in reverse order, skipping the last node (which corresponds to the highest value node in the original tree). For each node, find its immediate successor in the inorder traversal (i.e., the next node in the forward direction) and add its value to the nodeâs own value. After this operation, the nodeâs value will be updated to its original value plus the sum of all values greater than its own value in the original tree. Finally, return the modified root node of the binary search tree. Java C++ Python Go Javascript public class Convert_BST_to_Greater_Tree { /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { int sum = 0; public TreeNode convertBST(TreeNode root) { if (root == null) { return null; } convertBST(root.right); sum += root.val; root.val = sum; convertBST(root.left); return root; } } } ############ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode convertBST(TreeNode root) { int s = 0; TreeNode node = root; while (root != null) { if (root.right == null) { s += root.val; root.val = s; root = root.left; } else { TreeNode next = root.right; while (next.left != null &amp;amp;&amp;amp; next.left != root) { next = next.left; } if (next.left == null) { next.left = root; root = root.right; } else { s += root.val; root.val = s; next.left = null; root = root.left; } } } return node; } } // OJ: https://leetcode.com/problems/convert-bst-to-greater-tree/ // Time: O(N) // Space: O(H) class Solution { int sum = 0; public: TreeNode* convertBST(TreeNode* root) { if (!root) return nullptr; convertBST(root-&amp;gt;right); root-&amp;gt;val = (sum += root-&amp;gt;val); convertBST(root-&amp;gt;left); return root; } }; # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right # same..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2017-05-21T22:21:01-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2017-05-21-538-Convert-BST-to-Greater-Tree/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-538.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="538 - Convert BST to Greater Tree" property="twitter:title"/>
   <meta content="Leetcode Formatted question description: https://leetcode.ca/all/538.html 538. Convert BST to Greater Tree Level Easy Description Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. Example: Input: The root of a Binary Search Tree like this: 5 / \ 2 13 Output: The root of a Greater Tree like this: 18 / \ 20 13 Solution Same but just left/right mirror of https://leetcode.ca/2016-03-03-94-Binary-Tree-Inorder-Traversal Begin by obtaining the inorder traversal of the binary search tree. This traversal lists all the nodes of the tree in ascending order based on their values. Next, iterate over the inorder traversal in reverse order, skipping the last node (which corresponds to the highest value node in the original tree). For each node, find its immediate successor in the inorder traversal (i.e., the next node in the forward direction) and add its value to the nodeâs own value. After this operation, the nodeâs value will be updated to its original value plus the sum of all values greater than its own value in the original tree. Finally, return the modified root node of the binary search tree. Java C++ Python Go Javascript public class Convert_BST_to_Greater_Tree { /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { int sum = 0; public TreeNode convertBST(TreeNode root) { if (root == null) { return null; } convertBST(root.right); sum += root.val; root.val = sum; convertBST(root.left); return root; } } } ############ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode convertBST(TreeNode root) { int s = 0; TreeNode node = root; while (root != null) { if (root.right == null) { s += root.val; root.val = s; root = root.left; } else { TreeNode next = root.right; while (next.left != null &amp;amp;&amp;amp; next.left != root) { next = next.left; } if (next.left == null) { next.left = root; root = root.right; } else { s += root.val; root.val = s; next.left = null; root = root.left; } } } return node; } } // OJ: https://leetcode.com/problems/convert-bst-to-greater-tree/ // Time: O(N) // Space: O(H) class Solution { int sum = 0; public: TreeNode* convertBST(TreeNode* root) { if (!root) return nullptr; convertBST(root-&amp;gt;right); root-&amp;gt;val = (sum += root-&amp;gt;val); convertBST(root-&amp;gt;left); return root; } }; # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right # same..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    538 - Convert BST to Greater Tree | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="538 - Convert BST to Greater Tree" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-538.html" rel="canonical">
          <meta content="https://leetcode.ca/2017-05-21-538-Convert-BST-to-Greater-Tree/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2017-05-21T22:21:01-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"538 - Convert BST to Greater Tree","dateModified":"2017-05-21T22:21:01-07:00","datePublished":"2017-05-21T22:21:01-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2017-05-21-538-Convert-BST-to-Greater-Tree/"},"url":"https://leetcode.ca/2017-05-21-538-Convert-BST-to-Greater-Tree/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <p>
       Formatted question description:
       <a href="solution-538.html">
        https://leetcode.ca/all/538.html
       </a>
      </p>
      <h1 id="538-convert-bst-to-greater-tree">
       538. Convert BST to Greater Tree
      </h1>
      <h2 id="level">
       Level
      </h2>
      <p>
       Easy
      </p>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.
      </p>
      <p>
       <strong>
        Example:
       </strong>
      </p>
      <div class="language-plaintext highlighter-rouge">
       <div class="highlight">
        <pre class="highlight"><code>Input: The root of a Binary Search Tree like this:
              5
            /   \
           2     13

Output: The root of a Greater Tree like this:
             18
            /   \
          20     13
</code></pre>
       </div>
      </div>
      <h2 id="solution">
       Solution
      </h2>
      <p>
       Same but just left/right mirror of
       <a href="solution-538.html">
        https://leetcode.ca/2016-03-03-94-Binary-Tree-Inorder-Traversal
       </a>
      </p>
      <p>
       Begin by obtaining the inorder traversal of the binary search tree. This traversal lists all the nodes of the tree in ascending order based on their values.
      </p>
      <p>
       Next, iterate over the inorder traversal in reverse order, skipping the last node (which corresponds to the highest value node in the original tree). For each node, find its immediate successor in the inorder traversal (i.e., the next node in the forward direction) and add its value to the nodeâs own value. After this operation, the nodeâs value will be updated to its original value plus the sum of all values greater than its own value in the original tree.
      </p>
      <p>
       Finally, return the modified root node of the binary search tree.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#2f2066ae-e903-4378-a49a-4fd5002676f3'}">
       <li class="uk-active">
        <a href="solution-538.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-538.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-538.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-538.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-538.html">
         Javascript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="2f2066ae-e903-4378-a49a-4fd5002676f3">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Convert_BST_to_Greater_Tree</span> <span class="o">{</span>
    <span class="cm">/**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode(int x) { val = x; }
     * }
     */</span>
    <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">convertBST</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="n">convertBST</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>
            <span class="n">convertBST</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>

            <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="err">############</span>

<span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">convertBST</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
                <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="nc">TreeNode</span> <span class="n">next</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">next</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">next</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
                    <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
                    <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
                    <span class="n">next</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1">// OJ: https://leetcode.com/problems/convert-bst-to-greater-tree/</span>
<span class="c1">// Time: O(N)</span>
<span class="c1">// Space: O(H)</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">convertBST</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">convertBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">convertBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-python highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span>
<span class="c1"># same but just left/right mirror of https://leetcode.ca/2016-03-03-94-Binary-Tree-Inorder-Traversal/
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">convertBST</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">root</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># sum
</span>        <span class="k">while</span> <span class="n">stack</span> <span class="ow">or</span> <span class="n">current</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">right</span>

            <span class="n">right_or_middle</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">right_or_middle</span><span class="p">.</span><span class="n">val</span>
            <span class="n">right_or_middle</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">s</span>

            <span class="n">current</span> <span class="o">=</span> <span class="n">right_or_middle</span><span class="p">.</span><span class="n">left</span>

        <span class="k">return</span> <span class="n">root</span>

<span class="c1">############
</span>
<span class="c1"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">lSum</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="nf">convertBST</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="s">"""
    :type root: TreeNode
    :rtype: TreeNode
    """</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">None</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">convertBST</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">lSum</span> <span class="o">+=</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span>
    <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">lSum</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">convertBST</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">root</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */</span>
<span class="k">func</span> <span class="n">convertBST</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="n">TreeNode</span> <span class="p">{</span>
	<span class="n">s</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">root</span>
	<span class="k">for</span> <span class="n">root</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">Right</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">s</span> <span class="o">+=</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span>
			<span class="n">root</span><span class="o">.</span><span class="n">Val</span> <span class="o">=</span> <span class="n">s</span>
			<span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">Left</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">:=</span> <span class="n">root</span><span class="o">.</span><span class="n">Right</span>
			<span class="k">for</span> <span class="n">next</span><span class="o">.</span><span class="n">Left</span> <span class="o">!=</span> <span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="n">next</span><span class="o">.</span><span class="n">Left</span> <span class="o">!=</span> <span class="n">root</span> <span class="p">{</span>
				<span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">.</span><span class="n">Left</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="n">next</span><span class="o">.</span><span class="n">Left</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="n">next</span><span class="o">.</span><span class="n">Left</span> <span class="o">=</span> <span class="n">root</span>
				<span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">Right</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">s</span> <span class="o">+=</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span>
				<span class="n">root</span><span class="o">.</span><span class="n">Val</span> <span class="o">=</span> <span class="n">s</span>
				<span class="n">next</span><span class="o">.</span><span class="n">Left</span> <span class="o">=</span> <span class="no">nil</span>
				<span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">Left</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">node</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-js highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-538.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
