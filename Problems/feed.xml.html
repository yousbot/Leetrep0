<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
  <title>
   Leetcode
  </title>
  <description>
   leetcode.ca
  </description>
  <link/>
  https://leetcode.ca/
  <atom:link href="https://leetcode.ca/feed.xml" rel="self" type="application/rss+xml">
  </atom:link>
  <item>
   <title>
    3407 - Substring Matching Pattern
   </title>
   <description>
    Leetcode






3407. Substring Matching Pattern

Description



You are given a string s and a pattern string p, where p contains exactly one &amp;#39;*&amp;#39; character.

The &amp;#39;*&amp;#39; in p can be replaced with any sequence of zero or more characters.

Return true if p can be made a substring of s, and false otherwise.

&amp;nbsp;
Example 1:


Input: s = &amp;quot;leetcode&amp;quot;, p = &amp;quot;ee*e&amp;quot;

Output: true

Explanation:

By replacing the &amp;#39;*&amp;#39; with &amp;quot;tcod&amp;quot;, the substring &amp;quot;eetcode&amp;quot; matches the pattern.


Example 2:


Input: s = &amp;quot;car&amp;quot;, p = &amp;quot;c*v&amp;quot;

Output: false

Explanation:

There is no substring matching the pattern.


Example 3:


Input: s = &amp;quot;luck&amp;quot;, p = &amp;quot;u*&amp;quot;

Output: true

Explanation:

The substrings &amp;quot;u&amp;quot;, &amp;quot;uc&amp;quot;, and &amp;quot;uck&amp;quot; match the pattern.


&amp;nbsp;
Constraints:


	1 &amp;lt;= s.length &amp;lt;= 50
	1 &amp;lt;= p.length &amp;lt;= 50 
	s contains only lowercase English letters.
	p contains only lowercase English letters and exactly one &amp;#39;*&amp;#39;




Solutions



Solution 1



	Java

	C++

	Python

	Go

	TypeScript





	
class Solution {
    public boolean hasMatch(String s, String p) {
        int i = 0;
        for (String t : p.split("\\*")) {
            int j = s.indexOf(t, i);
            if (j == -1) {
                return false;
            }
            i = j + t.length();
        }
        return true;
    }
}




	
class Solution {
public:
    bool hasMatch(string s, string p) {
        int i = 0;
        int pos = 0;
        int start = 0, end;
        while ((end = p.find("*", start)) != string::npos) {
            string t = p.substr(start, end - start);
            pos = s.find(t, i);
            if (pos == string::npos) {
                return false;
            }
            i = pos + t.length();
            start = end + 1;
        }
        string t = p.substr(start);
        pos = s.find(t, i);
        if (pos == string::npos) {
            return false;
        }
        return true;
    }
};




	
class Solution:
    def hasMatch(self, s: str, p: str) -&amp;gt; bool:
        i = 0
        for t in p.split("*"):
            j = s.find(t, i)
            if j == -1:
                return False
            i = j + len(t)
        return True




	
func hasMatch(s string, p string) bool {
	i := 0
	for _, t := range strings.Split(p, "*") {
		j := strings.Index(s[i:], t)
		if j == -1 {
			return false
		}
		i += j + len(t)
	}
	return true
}




	
function hasMatch(s: string, p: string): boolean {
    let i = 0;
    for (const t of p.split('*')) {
        const j = s.indexOf(t, i);
        if (j === -1) {
            return false;
        }
        i = j + t.length;
    }
    return true;
}






All Problems

All Solutions
   </description>
   <pubdate>
    Mon, 20 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-20-3407-Substring-Matching-Pattern/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-20-3407-Substring-Matching-Pattern/
   </guid>
  </item>
  <item>
   <title>
    3406 - Find the Lexicographically Largest String From the Box II
   </title>
   <description>
    Leetcode






3406. Find the Lexicographically Largest String From the Box II ðŸ”’

Description



You are given a string word, and an integer numFriends.

Alice is organizing a game for her numFriends friends. There are multiple rounds in the game, where in each round:


	word is split into numFriends non-empty strings, such that no previous round has had the exact same split.
	All the split words are put into a box.


Find the lexicographically largest string from the box after all the rounds are finished.

A string a is lexicographically smaller than a string b if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.
If the first min(a.length, b.length) characters do not differ, then the shorter string is the lexicographically smaller one.

&amp;nbsp;
Example 1:


Input: word = &amp;quot;dbca&amp;quot;, numFriends = 2

Output: &amp;quot;dbc&amp;quot;

Explanation:

All possible splits are:


	&amp;quot;d&amp;quot; and &amp;quot;bca&amp;quot;.
	&amp;quot;db&amp;quot; and &amp;quot;ca&amp;quot;.
	&amp;quot;dbc&amp;quot; and &amp;quot;a&amp;quot;.



Example 2:


Input: word = &amp;quot;gggg&amp;quot;, numFriends = 4

Output: &amp;quot;g&amp;quot;

Explanation:

The only possible split is: &amp;quot;g&amp;quot;, &amp;quot;g&amp;quot;, &amp;quot;g&amp;quot;, and &amp;quot;g&amp;quot;.


&amp;nbsp;
Constraints:


	1 &amp;lt;= word.length &amp;lt;= 2 * 105
	word consists only of lowercase English letters.
	1 &amp;lt;= numFriends &amp;lt;= word.length




Solutions



Solution 1

All Problems

All Solutions
   </description>
   <pubdate>
    Sun, 19 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-19-3406-Find-the-Lexicographically-Largest-String-From-the-Box-II/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-19-3406-Find-the-Lexicographically-Largest-String-From-the-Box-II/
   </guid>
  </item>
  <item>
   <title>
    3405 - Count the Number of Arrays with K Matching Adjacent Elements
   </title>
   <description>
    Leetcode






3405. Count the Number of Arrays with K Matching Adjacent Elements

Description



You are given three integers n, m, k. A good array arr of size n is defined as follows:


	Each element in arr is in the inclusive range [1, m].
	Exactly k indices i (where 1 &amp;lt;= i &amp;lt; n) satisfy the condition arr[i - 1] == arr[i].


Return the number of good arrays that can be formed.

Since the answer may be very large, return it modulo 109 + 7.

&amp;nbsp;
Example 1:


Input: n = 3, m = 2, k = 1

Output: 4

Explanation:


	There are 4 good arrays. They are [1, 1, 2], [1, 2, 2], [2, 1, 1] and [2, 2, 1].
	Hence, the answer is 4.



Example 2:


Input: n = 4, m = 2, k = 2

Output: 6

Explanation:


	The good arrays are [1, 1, 1, 2], [1, 1, 2, 2], [1, 2, 2, 2], [2, 1, 1, 1], [2, 2, 1, 1] and [2, 2, 2, 1].
	Hence, the answer is 6.



Example 3:


Input: n = 5, m = 2, k = 0

Output: 2

Explanation:


	The good arrays are [1, 2, 1, 2, 1] and [2, 1, 2, 1, 2]. Hence, the answer is 2.



&amp;nbsp;
Constraints:


	1 &amp;lt;= n &amp;lt;= 105
	1 &amp;lt;= m &amp;lt;= 105
	0 &amp;lt;= k &amp;lt;= n - 1




Solutions



Solution 1

All Problems

All Solutions
   </description>
   <pubdate>
    Sat, 18 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-18-3405-Count-the-Number-of-Arrays-with-K-Matching-Adjacent-Elements/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-18-3405-Count-the-Number-of-Arrays-with-K-Matching-Adjacent-Elements/
   </guid>
  </item>
  <item>
   <title>
    3404 - Count Special Subsequences
   </title>
   <description>
    Leetcode 3404. Count Special Subsequences Description You are given an array nums consisting of positive integers. A special subsequence is defined as a subsequence of length 4, represented by indices (p, q, r, s), where p &amp;lt; q &amp;lt; r &amp;lt; s. This subsequence must satisfy the following conditions: nums[p] * nums[r] == nums[q] * nums[s] There must be at least one element between each pair of indices. In other words, q - p &amp;gt; 1, r - q &amp;gt; 1 and s - r &amp;gt; 1. Return the number of different special subsequences in nums. &amp;nbsp; Example 1: Input: nums = [1,2,3,4,3,6,1] Output: 1 Explanation: There is one special subsequence in nums. (p, q, r, s) = (0, 2, 4, 6): This corresponds to elements (1, 3, 3, 1). nums[p] * nums[r] = nums[0] * nums[4] = 1 * 3 = 3 nums[q] * nums[s] = nums[2] * nums[6] = 3 * 1 = 3 Example 2: Input: nums = [3,4,3,4,3,4,3,4] Output: 3 Explanation: There are three special subsequences in nums. (p, q, r, s) = (0, 2, 4, 6): This corresponds to elements (3, 3, 3, 3). nums[p] * nums[r] = nums[0] * nums[4] = 3 * 3 = 9 nums[q] * nums[s] = nums[2] * nums[6] = 3 * 3 = 9 (p, q, r, s) = (1, 3, 5, 7): This corresponds to elements (4, 4, 4, 4). nums[p] * nums[r] = nums[1] * nums[5] = 4 * 4 = 16 nums[q] * nums[s] = nums[3] * nums[7] = 4 * 4 = 16 (p, q, r, s) = (0, 2, 5, 7): This corresponds to elements (3, 3, 4, 4). nums[p] * nums[r] = nums[0] * nums[5] = 3 * 4 = 12 nums[q] * nums[s] = nums[2] * nums[7] = 3 * 4 = 12 &amp;nbsp; Constraints: 7 &amp;lt;= nums.length &amp;lt;= 1000 1 &amp;lt;= nums[i] &amp;lt;= 1000 Solutions Solution 1 Java C++ Python Go TypeScript class Solution { public long numberOfSubsequences(int[] nums) { int n = nums.length; Map&amp;lt;Integer, Integer&amp;gt; cnt = new HashMap&amp;lt;&amp;gt;(); for (int r = 4; r &amp;lt; n - 2; ++r) { int c = nums[r]; for (int s = r + 2; s &amp;lt; n; ++s) { int d = nums[s]; int g = gcd(c, d); cnt.merge(((d / g) &amp;lt;&amp;lt; 12) | (c / g), 1, Integer::sum); } } long ans = 0; for (int q = 2; q &amp;lt; n - 4; ++q) { int b = nums[q]; for (int p = 0; p &amp;lt; q - 1; ++p) { int a = nums[p]; int g = gcd(a, b); ans += cnt.getOrDefault(((a / g) &amp;lt;&amp;lt; 12) | (b / g), 0); } int c = nums[q + 2]; for (int s = q + 4; s &amp;lt; n; ++s) { int d = nums[s]; int g = gcd(c, d); cnt.merge(((d / g) &amp;lt;&amp;lt; 12) | (c / g), -1, Integer::sum); } } return ans; } private int gcd(int a, int b) { return b ==...
   </description>
   <pubdate>
    Fri, 17 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-17-3404-Count-Special-Subsequences/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-17-3404-Count-Special-Subsequences/
   </guid>
  </item>
  <item>
   <title>
    3403 - Find the Lexicographically Largest String From the Box I
   </title>
   <description>
    Leetcode






3403. Find the Lexicographically Largest String From the Box I

Description



You are given a string word, and an integer numFriends.

Alice is organizing a game for her numFriends friends. There are multiple rounds in the game, where in each round:


	word is split into numFriends non-empty strings, such that no previous round has had the exact same split.
	All the split words are put into a box.


Find the lexicographically largest string from the box after all the rounds are finished.

&amp;nbsp;
Example 1:


Input: word = &amp;quot;dbca&amp;quot;, numFriends = 2

Output: &amp;quot;dbc&amp;quot;

Explanation:&amp;nbsp;

All possible splits are:


	&amp;quot;d&amp;quot; and &amp;quot;bca&amp;quot;.
	&amp;quot;db&amp;quot; and &amp;quot;ca&amp;quot;.
	&amp;quot;dbc&amp;quot; and &amp;quot;a&amp;quot;.



Example 2:


Input: word = &amp;quot;gggg&amp;quot;, numFriends = 4

Output: &amp;quot;g&amp;quot;

Explanation:&amp;nbsp;

The only possible split is: &amp;quot;g&amp;quot;, &amp;quot;g&amp;quot;, &amp;quot;g&amp;quot;, and &amp;quot;g&amp;quot;.


&amp;nbsp;
Constraints:


	1 &amp;lt;= word.length &amp;lt;= 5&amp;nbsp;* 103
	word consists only of lowercase English letters.
	1 &amp;lt;= numFriends &amp;lt;= word.length




Solutions



Solution 1



	Java

	C++

	Python

	Go

	TypeScript





	
class Solution {
    public String answerString(String word, int numFriends) {
        if (numFriends == 1) {
            return word;
        }
        int n = word.length();
        String ans = "";
        for (int i = 0; i &amp;lt; n; ++i) {
            int k = Math.min(n - i, n - numFriends + 1);
            String t = word.substring(i, i + k);
            if (ans.compareTo(t) &amp;lt; 0) {
                ans = t;
            }
        }
        return ans;
    }
}




	
class Solution {
public:
    string answerString(string word, int numFriends) {
        if (numFriends == 1) {
            return word;
        }
        int n = word.size();
        string ans;
        for (int i = 0; i &amp;lt; n; ++i) {
            int k = min(n - i, n - numFriends + 1);
            string t = word.substr(i, k);
            ans = max(ans, t);
        }
        return ans;
    }
};




	
class Solution:
    def answerString(self, word: str, numFriends: int) -&amp;gt; str:
        if numFriends == 1:
            return word
        n = len(word)
        ans = ""
        for i in range(n):
            k = min(n - i, n - numFriends + 1)
            ans = max(ans, word[i : i + k])
        return ans




	
func answerString(word string, numFriends int) (ans string) {
	if numFriends == 1 {
		return word
	}
	n := len(word)
	for i := range word {
		k := min(n-i, n-numFriends+1)
		t := word[i : i+k]
		ans = max(ans, t)
	}
	return
}




	
function answerString(word: string, numFriends: number): string {
    if (numFriends === 1) {
        return word;
    }
    let ans: string = '';
    const n = word.length;
    for (let i = 0; i &amp;lt; n; ++i) {
        const k = Math.min(n - i, n - numFriends + 1);
        const t = word.slice(i, i + k);
        if (ans &amp;lt; t) {
            ans = t;
        }
    }
    return ans;
}






All Problems

All Solutions
   </description>
   <pubdate>
    Thu, 16 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-16-3403-Find-the-Lexicographically-Largest-String-From-the-Box-I/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-16-3403-Find-the-Lexicographically-Largest-String-From-the-Box-I/
   </guid>
  </item>
  <item>
   <title>
    3402 - Minimum Operations to Make Columns Strictly Increasing
   </title>
   <description>
    Leetcode 3402. Minimum Operations to Make Columns Strictly Increasing Description You are given a m x n matrix grid consisting of non-negative integers. In one operation, you can increment the value of any grid[i][j] by 1. Return the minimum number of operations needed to make all columns of grid strictly increasing. &amp;nbsp; Example 1: Input: grid = [[3,2],[1,3],[3,4],[0,1]] Output: 15 Explanation: To make the 0th column strictly increasing, we can apply 3 operations on grid[1][0], 2 operations on grid[2][0], and 6 operations on grid[3][0]. To make the 1st column strictly increasing, we can apply 4 operations on grid[3][1]. Example 2: Input: grid = [[3,2,1],[2,1,0],[1,2,3]] Output: 12 Explanation: To make the 0th column strictly increasing, we can apply 2 operations on grid[1][0], and 4 operations on grid[2][0]. To make the 1st column strictly increasing, we can apply 2 operations on grid[1][1], and 2 operations on grid[2][1]. To make the 2nd column strictly increasing, we can apply 2 operations on grid[1][2]. &amp;nbsp; Constraints: m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 50 0 &amp;lt;= grid[i][j] &amp;lt; 2500 &amp;nbsp; &amp;nbsp; Solutions Solution 1: Column-wise Calculation We can traverse the matrix column by column. For each column, we calculate the minimum number of operations required to make it strictly increasing. Specifically, for each column, we maintain a variable $\textit{pre}$ to represent the value of the previous element in the current column. Then, we traverse the current column from top to bottom. For the current element $\textit{cur}$, if $\textit{pre} &amp;lt; \textit{cur}$, it means the current element is already greater than the previous element, so we only need to update $\textit{pre} = \textit{cur}$. Otherwise, we need to increase the current element to $\textit{pre} + 1$ and add the number of increases to the answer. The time complexity is $O(m \times n)$, where $m$ and $n$ are the number of rows and columns of the matrix $\textit{grid}$, respectively. The space complexity is $O(1)$. Java C++ Python Go TypeScript class Solution { public int minimumOperations(int[][] grid) { int m = grid.length, n = grid[0].length; int ans = 0; for (int j = 0; j &amp;lt; n; ++j) { int pre = -1; for (int i = 0; i &amp;lt; m; ++i) { int cur = grid[i][j]; if (pre &amp;lt; cur) { pre = cur; } else { ++pre; ans += pre - cur; } } } return ans; } } class Solution { public: int minimumOperations(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.size(), n = grid[0].size(); int ans = 0; for (int j = 0; j &amp;lt; n; ++j) { int pre = -1; for (int i = 0; i &amp;lt; m; ++i) { int cur = grid[i][j]; if (pre &amp;lt; cur) { pre = cur; } else { ++pre; ans += pre - cur; } } } return ans; } }; class Solution: def minimumOperations(self, grid: List[List[int]]) -&amp;gt; int: ans = 0 for col in zip(*grid): pre = -1 for cur in col: if pre &amp;lt; cur: pre = cur else:...
   </description>
   <pubdate>
    Wed, 15 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-15-3402-Minimum-Operations-to-Make-Columns-Strictly-Increasing/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-15-3402-Minimum-Operations-to-Make-Columns-Strictly-Increasing/
   </guid>
  </item>
  <item>
   <title>
    3401 - Find Circular Gift Exchange Chains
   </title>
   <description>
    Leetcode






3401. Find Circular Gift Exchange Chains ðŸ”’

Description



Table: SecretSanta


+-++
\| Column Name \| Type \|
+-++
\| giver_id    \| int  \|
\| receiver_id \| int  \|
\| gift_value  \| int  \|
+-++
(giver_id, receiver_id) is the unique key for this table.   
Each row represents a record of a gift exchange between two employees, giver_id represents the employee who gives a gift, receiver_id represents the employee who receives the gift and gift_value represents the value of the gift given.  


Write a solution to find the total gift value and length of circular chains of Secret Santa gift exchanges:

A circular chain is defined as a series of exchanges where:


	Each employee gives a gift to exactly one other employee.
	Each employee receives a gift from exactly one other employee.
	The exchanges form a continuous loop (e.g., employee A gives a gift to B, B gives to C, and C gives back to A).


Return the result ordered by the chain length and total gift value of the chain in&amp;nbsp;descending order.&amp;nbsp;

The result format is in the following example.

&amp;nbsp;
Example:


Input:

SecretSanta table:


+-+-++
\| 1        \| 2           \| 20         \|
\| 2        \| 3           \| 30         \|
\| 3        \| 1           \| 40         \|
\| 4        \| 5           \| 25         \|
\| 5        \| 4           \| 35         \|
+-+--++
\| chain_id \| chain_length \| total_gift_value \|
+-+--++


Explanation:


	Chain 1 involves employees 1, 2, and 3:

    
    	Employee 1 gives a gift to 2, employee 2 gives a gift to 3, and employee 3 gives a gift to 1.
    	Total gift value for this chain = 20 + 30 + 40 = 90.
    
    
    Chain 2 involves employees 4 and 5:
    
    	Employee 4 gives a gift to 5, and employee 5 gives a gift to 4.
    	Total gift value for this chain = 25 + 35 = 60.
    
    



The result table is ordered by the chain length and total gift value of the chain in descending order.




Solutions



Solution 1

All Problems

All Solutions
   </description>
   <pubdate>
    Tue, 14 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-14-3401-Find-Circular-Gift-Exchange-Chains/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-14-3401-Find-Circular-Gift-Exchange-Chains/
   </guid>
  </item>
  <item>
   <title>
    3400 - Maximum Number of Matching Indices After Right Shifts
   </title>
   <description>
    Leetcode 3400. Maximum Number of Matching Indices After Right Shifts ðŸ”’ Description You are given two integer arrays, nums1 and nums2, of the same length. An index i is considered matching if nums1[i] == nums2[i]. Return the maximum number of matching indices after performing any number of right shifts on nums1. A right shift is defined as shifting the element at index i to index (i + 1) % n, for all indices. &amp;nbsp; Example 1: Input: nums1 = [3,1,2,3,1,2], nums2 = [1,2,3,1,2,3] Output: 6 Explanation: If we right shift nums1 2 times, it becomes [1, 2, 3, 1, 2, 3]. Every index matches, so the output is 6. Example 2: Input: nums1 = [1,4,2,5,3,1], nums2 = [2,3,1,2,4,6] Output: 3 Explanation: If we right shift nums1 3 times, it becomes [5, 3, 1, 1, 4, 2]. Indices 1, 2, and 4 match, so the output is 3. &amp;nbsp; Constraints: nums1.length == nums2.length 1 &amp;lt;= nums1.length, nums2.length &amp;lt;= 3000 1 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 109 Solutions Solution 1: Enumeration We can enumerate the number of right shifts $k$, where $0 \leq k &amp;lt; n$. For each $k$, we can calculate the number of matching indices between the array $\textit{nums1}$ after right shifting $k$ times and $\textit{nums2}$. The maximum value is taken as the answer. The time complexity is $O(n^2)$, where $n$ is the length of the array $\textit{nums1}$. The space complexity is $O(1)$. Java C++ Python Go TypeScript class Solution { public int maximumMatchingIndices(int[] nums1, int[] nums2) { int n = nums1.length; int ans = 0; for (int k = 0; k &amp;lt; n; ++k) { int t = 0; for (int i = 0; i &amp;lt; n; ++i) { if (nums1[(i + k) % n] == nums2[i]) { ++t; } } ans = Math.max(ans, t); } return ans; } } class Solution { public: int maximumMatchingIndices(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) { int n = nums1.size(); int ans = 0; for (int k = 0; k &amp;lt; n; ++k) { int t = 0; for (int i = 0; i &amp;lt; n; ++i) { if (nums1[(i + k) % n] == nums2[i]) { ++t; } } ans = max(ans, t); } return ans; } }; class Solution: def maximumMatchingIndices(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: n = len(nums1) ans = 0 for k in range(n): t = sum(nums1[(i + k) % n] == x for i, x in enumerate(nums2)) ans = max(ans, t) return ans func maximumMatchingIndices(nums1 []int, nums2 []int) (ans int) { n := len(nums1) for k := range nums1 { t := 0 for i, x := range nums2 { if nums1[(i+k)%n] == x { t++ } } ans = max(ans, t) } return } function maximumMatchingIndices(nums1: number[], nums2: number[]): number { const n = nums1.length; let ans: number = 0; for (let k = 0; k &amp;lt; n; ++k) { let t: number = 0; for (let i = 0; i &amp;lt; n; ++i) { if (nums1[(i + k) % n] === nums2[i]) { ++t;...
   </description>
   <pubdate>
    Mon, 13 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-13-3400-Maximum-Number-of-Matching-Indices-After-Right-Shifts/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-13-3400-Maximum-Number-of-Matching-Indices-After-Right-Shifts/
   </guid>
  </item>
  <item>
   <title>
    3399 - Smallest Substring With Identical Characters II
   </title>
   <description>
    Leetcode 3399. Smallest Substring With Identical Characters II Description You are given a binary string s of length n and an integer numOps. You are allowed to perform the following operation on s at most numOps times: Select any index i (where 0 &amp;lt;= i &amp;lt; n) and flip s[i]. If s[i] == &amp;#39;1&amp;#39;, change s[i] to &amp;#39;0&amp;#39; and vice versa. You need to minimize the length of the longest substring of s such that all the characters in the substring are identical. Return the minimum length after the operations. &amp;nbsp; Example 1: Input: s = &amp;quot;000001&amp;quot;, numOps = 1 Output: 2 Explanation:&amp;nbsp; By changing s[2] to &amp;#39;1&amp;#39;, s becomes &amp;quot;001001&amp;quot;. The longest substrings with identical characters are s[0..1] and s[3..4]. Example 2: Input: s = &amp;quot;0000&amp;quot;, numOps = 2 Output: 1 Explanation:&amp;nbsp; By changing s[0] and s[2] to &amp;#39;1&amp;#39;, s becomes &amp;quot;1010&amp;quot;. Example 3: Input: s = &amp;quot;0101&amp;quot;, numOps = 0 Output: 1 &amp;nbsp; Constraints: 1 &amp;lt;= n == s.length &amp;lt;= 105 s consists only of &amp;#39;0&amp;#39; and &amp;#39;1&amp;#39;. 0 &amp;lt;= numOps &amp;lt;= n Solutions Solution 1 Java C++ Python Go TypeScript class Solution { private char[] s; private int numOps; public int minLength(String s, int numOps) { this.numOps = numOps; this.s = s.toCharArray(); int l = 1, r = s.length(); while (l &amp;lt; r) { int mid = (l + r) &amp;gt;&amp;gt; 1; if (check(mid)) { r = mid; } else { l = mid + 1; } } return l; } private boolean check(int m) { int cnt = 0; if (m == 1) { char[] t = {'0', '1'}; for (int i = 0; i &amp;lt; s.length; ++i) { if (s[i] == t[i &amp;amp; 1]) { ++cnt; } } cnt = Math.min(cnt, s.length - cnt); } else { int k = 0; for (int i = 0; i &amp;lt; s.length; ++i) { ++k; if (i == s.length - 1 || s[i] != s[i + 1]) { cnt += k / (m + 1); k = 0; } } } return cnt &amp;lt;= numOps; } } class Solution { public: int minLength(string s, int numOps) { int n = s.size(); auto check = [&amp;amp;](int m) { int cnt = 0; if (m == 1) { string t = "01"; for (int i = 0; i &amp;lt; n; ++i) { if (s[i] == t[i &amp;amp; 1]) { ++cnt; } } cnt = min(cnt, n - cnt); } else { int k = 0; for (int i = 0; i &amp;lt; n; ++i) { ++k; if (i == n - 1 || s[i] != s[i + 1]) { cnt += k / (m + 1); k = 0; } } } return cnt &amp;lt;= numOps; }; int l = 1, r = n; while (l &amp;lt; r) { int mid = (l + r) &amp;gt;&amp;gt; 1; if (check(mid)) { r = mid; } else { l = mid + 1; } } return l; } }; class Solution: def minLength(self, s: str, numOps: int) -&amp;gt;...
   </description>
   <pubdate>
    Sun, 12 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-12-3399-Smallest-Substring-With-Identical-Characters-II/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-12-3399-Smallest-Substring-With-Identical-Characters-II/
   </guid>
  </item>
  <item>
   <title>
    3398 - Smallest Substring With Identical Characters I
   </title>
   <description>
    Leetcode 3398. Smallest Substring With Identical Characters I Description You are given a binary string s of length n and an integer numOps. You are allowed to perform the following operation on s at most numOps times: Select any index i (where 0 &amp;lt;= i &amp;lt; n) and flip s[i]. If s[i] == &amp;#39;1&amp;#39;, change s[i] to &amp;#39;0&amp;#39; and vice versa. You need to minimize the length of the longest substring of s such that all the characters in the substring are identical. Return the minimum length after the operations. &amp;nbsp; Example 1: Input: s = &amp;quot;000001&amp;quot;, numOps = 1 Output: 2 Explanation:&amp;nbsp; By changing s[2] to &amp;#39;1&amp;#39;, s becomes &amp;quot;001001&amp;quot;. The longest substrings with identical characters are s[0..1] and s[3..4]. Example 2: Input: s = &amp;quot;0000&amp;quot;, numOps = 2 Output: 1 Explanation:&amp;nbsp; By changing s[0] and s[2] to &amp;#39;1&amp;#39;, s becomes &amp;quot;1010&amp;quot;. Example 3: Input: s = &amp;quot;0101&amp;quot;, numOps = 0 Output: 1 &amp;nbsp; Constraints: 1 &amp;lt;= n == s.length &amp;lt;= 1000 s consists only of &amp;#39;0&amp;#39; and &amp;#39;1&amp;#39;. 0 &amp;lt;= numOps &amp;lt;= n Solutions Solution 1 Java C++ Python Go TypeScript class Solution { private char[] s; private int numOps; public int minLength(String s, int numOps) { this.numOps = numOps; this.s = s.toCharArray(); int l = 1, r = s.length(); while (l &amp;lt; r) { int mid = (l + r) &amp;gt;&amp;gt; 1; if (check(mid)) { r = mid; } else { l = mid + 1; } } return l; } private boolean check(int m) { int cnt = 0; if (m == 1) { char[] t = {'0', '1'}; for (int i = 0; i &amp;lt; s.length; ++i) { if (s[i] == t[i &amp;amp; 1]) { ++cnt; } } cnt = Math.min(cnt, s.length - cnt); } else { int k = 0; for (int i = 0; i &amp;lt; s.length; ++i) { ++k; if (i == s.length - 1 || s[i] != s[i + 1]) { cnt += k / (m + 1); k = 0; } } } return cnt &amp;lt;= numOps; } } class Solution { public: int minLength(string s, int numOps) { int n = s.size(); auto check = [&amp;amp;](int m) { int cnt = 0; if (m == 1) { string t = "01"; for (int i = 0; i &amp;lt; n; ++i) { if (s[i] == t[i &amp;amp; 1]) { ++cnt; } } cnt = min(cnt, n - cnt); } else { int k = 0; for (int i = 0; i &amp;lt; n; ++i) { ++k; if (i == n - 1 || s[i] != s[i + 1]) { cnt += k / (m + 1); k = 0; } } } return cnt &amp;lt;= numOps; }; int l = 1, r = n; while (l &amp;lt; r) { int mid = (l + r) &amp;gt;&amp;gt; 1; if (check(mid)) { r = mid; } else { l = mid + 1; } } return l; } }; class Solution: def minLength(self, s: str, numOps: int) -&amp;gt;...
   </description>
   <pubdate>
    Sat, 11 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-11-3398-Smallest-Substring-With-Identical-Characters-I/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-11-3398-Smallest-Substring-With-Identical-Characters-I/
   </guid>
  </item>
  <item>
   <title>
    3397 - Maximum Number of Distinct Elements After Operations
   </title>
   <description>
    Leetcode 3397. Maximum Number of Distinct Elements After Operations Description You are given an integer array nums and an integer k. You are allowed to perform the following operation on each element of the array at most once: Add an integer in the range [-k, k] to the element. Return the maximum possible number of distinct elements in nums after performing the operations. &amp;nbsp; Example 1: Input: nums = [1,2,2,3,3,4], k = 2 Output: 6 Explanation: nums changes to [-1, 0, 1, 2, 3, 4] after performing operations on the first four elements. Example 2: Input: nums = [4,4,4,4], k = 1 Output: 3 Explanation: By adding -1 to nums[0] and 1 to nums[1], nums changes to [3, 5, 4, 4]. &amp;nbsp; Constraints: 1 &amp;lt;= nums.length &amp;lt;= 105 1 &amp;lt;= nums[i] &amp;lt;= 109 0 &amp;lt;= k &amp;lt;= 109 Solutions Solution 1: Greedy + Sorting We can sort the array $\textit{nums}$ and then consider each element $x$ from left to right. For the first element, we can greedily change it to $x - k$, making $x$ as small as possible to leave more space for subsequent elements. We use the variable $\textit{pre}$ to track the maximum value of the elements used so far, initialized to negative infinity. For subsequent elements $x$, we can greedily change it to $\min(x + k, \max(x - k, \textit{pre} + 1))$. Here, $\max(x - k, \textit{pre} + 1)$ means we try to make $x$ as small as possible but not smaller than $\textit{pre} + 1$. If this value exists and is less than $x + k$, we can change $x$ to this value, increment the count of distinct elements, and update $\textit{pre}$ to this value. After traversing the array, we obtain the maximum number of distinct elements. The time complexity is $O(n \times \log n)$, and the space complexity is $O(\log n)$. Here, $n$ is the length of the array $\textit{nums}$. Java C++ Python Go TypeScript class Solution { public int maxDistinctElements(int[] nums, int k) { Arrays.sort(nums); int n = nums.length; int ans = 0, pre = Integer.MIN_VALUE; for (int x : nums) { int cur = Math.min(x + k, Math.max(x - k, pre + 1)); if (cur &amp;gt; pre) { ++ans; pre = cur; } } return ans; } } class Solution { public: int maxDistinctElements(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { ranges::sort(nums); int ans = 0, pre = INT_MIN; for (int x : nums) { int cur = min(x + k, max(x - k, pre + 1)); if (cur &amp;gt; pre) { ++ans; pre = cur; } } return ans; } }; class Solution: def maxDistinctElements(self, nums: List[int], k: int) -&amp;gt; int: nums.sort() ans = 0 pre = -inf for x in nums: cur = min(x + k, max(x - k, pre + 1)) if cur &amp;gt; pre: ans += 1 pre = cur return ans func maxDistinctElements(nums []int, k int) (ans int) { sort.Ints(nums) pre := math.MinInt32 for _, x := range nums { cur := min(x+k, max(x-k, pre+1)) if cur...
   </description>
   <pubdate>
    Fri, 10 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-10-3397-Maximum-Number-of-Distinct-Elements-After-Operations/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-10-3397-Maximum-Number-of-Distinct-Elements-After-Operations/
   </guid>
  </item>
  <item>
   <title>
    3396 - Minimum Number of Operations to Make Elements in Array Distinct
   </title>
   <description>
    Leetcode 3396. Minimum Number of Operations to Make Elements in Array Distinct Description You are given an integer array nums. You need to ensure that the elements in the array are distinct. To achieve this, you can perform the following operation any number of times: Remove 3 elements from the beginning of the array. If the array has fewer than 3 elements, remove all remaining elements. Note that an empty array is considered to have distinct elements. Return the minimum number of operations needed to make the elements in the array distinct. &amp;nbsp; Example 1: Input: nums = [1,2,3,4,2,3,3,5,7] Output: 2 Explanation: In the first operation, the first 3 elements are removed, resulting in the array [4, 2, 3, 3, 5, 7]. In the second operation, the next 3 elements are removed, resulting in the array [3, 5, 7], which has distinct elements. Therefore, the answer is 2. Example 2: Input: nums = [4,5,6,4,4] Output: 2 Explanation: In the first operation, the first 3 elements are removed, resulting in the array [4, 4]. In the second operation, all remaining elements are removed, resulting in an empty array. Therefore, the answer is 2. Example 3: Input: nums = [6,7,8,9] Output: 0 Explanation: The array already contains distinct elements. Therefore, the answer is 0. &amp;nbsp; Constraints: 1 &amp;lt;= nums.length &amp;lt;= 100 1 &amp;lt;= nums[i] &amp;lt;= 100 Solutions Solution 1: Hash Table + Reverse Traversal We can traverse the array $\textit{nums}$ in reverse order and use a hash table $\textit{s}$ to record the elements that have already been traversed. When we encounter an element $\textit{nums}[i]$, if $\textit{nums}[i]$ is already in the hash table $\textit{s}$, it means we need to remove all elements from $\textit{nums}[0..i]$. The number of operations required is $\left\lfloor \frac{i}{3} \right\rfloor + 1$. Otherwise, we add $\textit{nums}[i]$ to the hash table $\textit{s}$ and continue to the next element. After traversing, if no duplicate elements are found, the elements in the array are already distinct, and no operations are needed, so the answer is $0$. The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array $\textit{nums}$. Java C++ Python Go TypeScript class Solution { public int minimumOperations(int[] nums) { Set&amp;lt;Integer&amp;gt; s = new HashSet&amp;lt;&amp;gt;(); for (int i = nums.length - 1; i &amp;gt;= 0; --i) { if (s.contains(nums[i])) { return i / 3 + 1; } s.add(nums[i]); } return 0; } } class Solution { public: int minimumOperations(vector&amp;lt;int&amp;gt;&amp;amp; nums) { unordered_set&amp;lt;int&amp;gt; s; for (int i = nums.size() - 1; ~i; --i) { if (s.contains(nums[i])) { return i / 3 + 1; } s.insert(nums[i]); } return 0; } }; class Solution: def minimumOperations(self, nums: List[int]) -&amp;gt; int: s = set() for i in range(len(nums) - 1, -1, -1): if nums[i] in s: return i // 3 + 1 s.add(nums[i]) return 0 func minimumOperations(nums []int) int { s := map[int]bool{} for i := len(nums) - 1; i &amp;gt;= 0; i-- { if s[nums[i]] { return i/3 + 1 } s[nums[i]] =...
   </description>
   <pubdate>
    Thu, 09 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-09-3396-Minimum-Number-of-Operations-to-Make-Elements-in-Array-Distinct/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-09-3396-Minimum-Number-of-Operations-to-Make-Elements-in-Array-Distinct/
   </guid>
  </item>
  <item>
   <title>
    3395 - Subsequences with a Unique Middle Mode I
   </title>
   <description>
    Leetcode






3395. Subsequences with a Unique Middle Mode I

Description



Given an integer array nums, find the number of subsequences of size 5 of&amp;nbsp;nums with a unique middle mode.

Since the answer may be very large, return it modulo 109 + 7.

A mode of a sequence of numbers is defined as the element that appears the maximum number of times in the sequence.

A sequence of numbers contains a unique mode if it has only one mode.

A sequence of numbers seq of size 5 contains a unique middle mode if the middle element (seq[2]) is a unique mode.

&amp;nbsp;
Example 1:


Input: nums = [1,1,1,1,1,1]

Output: 6

Explanation:

[1, 1, 1, 1, 1] is the only subsequence of size 5 that can be formed, and it has a unique middle mode of 1. This subsequence can be formed in 6 different ways, so the output is 6.&amp;nbsp;


Example 2:


Input: nums = [1,2,2,3,3,4]

Output: 4

Explanation:

[1, 2, 2, 3, 4] and [1, 2, 3, 3, 4]&amp;nbsp;each have a unique middle mode because the number at index 2 has the greatest frequency in the subsequence. [1, 2, 2, 3, 3] does not have a unique middle mode because 2 and 3 appear twice.


Example 3:


Input: nums = [0,1,2,3,4,5,6,7,8]

Output: 0

Explanation:

There is no subsequence of length 5 with a unique middle mode.


&amp;nbsp;
Constraints:


	5 &amp;lt;= nums.length &amp;lt;= 1000
	-109 &amp;lt;= nums[i] &amp;lt;= 109




Solutions



Solution 1

All Problems

All Solutions
   </description>
   <pubdate>
    Wed, 08 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-08-3395-Subsequences-with-a-Unique-Middle-Mode-I/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-08-3395-Subsequences-with-a-Unique-Middle-Mode-I/
   </guid>
  </item>
  <item>
   <title>
    3394 - Check if Grid can be Cut into Sections
   </title>
   <description>
    Leetcode






3394. Check if Grid can be Cut into Sections

Description



You are given an integer n representing the dimensions of an n x n grid, with the origin at the bottom-left corner of the grid. You are also given a 2D array of coordinates rectangles, where rectangles[i] is in the form [startx, starty, endx, endy], representing a rectangle on the grid. Each rectangle is defined as follows:


	(startx, starty): The bottom-left corner of the rectangle.
	(endx, endy): The top-right corner of the rectangle.


Note that the rectangles do not overlap. Your task is to determine if it is possible to make either two horizontal or two vertical cuts on the grid such that:


	Each of the three resulting sections formed by the cuts contains at least one rectangle.
	Every rectangle belongs to exactly one section.


Return true if such cuts can be made; otherwise, return false.

&amp;nbsp;
Example 1:


Input: n = 5, rectangles = [[1,0,5,2],[0,2,2,4],[3,2,5,3],[0,4,4,5]]

Output: true

Explanation:



The grid is shown in the diagram. We can make horizontal cuts at y = 2 and y = 4. Hence, output is true.


Example 2:


Input: n = 4, rectangles = [[0,0,1,1],[2,0,3,4],[0,2,2,3],[3,0,4,3]]

Output: true

Explanation:



We can make vertical cuts at x = 2 and x = 3. Hence, output is true.


Example 3:


Input: n = 4, rectangles = [[0,2,2,4],[1,0,3,2],[2,2,3,4],[3,0,4,2],[3,2,4,4]]

Output: false

Explanation:

We cannot make two horizontal or two vertical cuts that satisfy the conditions. Hence, output is false.


&amp;nbsp;
Constraints:


	3 &amp;lt;= n &amp;lt;= 109
	3 &amp;lt;= rectangles.length &amp;lt;= 105
	0 &amp;lt;= rectangles[i][0] &amp;lt; rectangles[i][2] &amp;lt;= n
	0 &amp;lt;= rectangles[i][1] &amp;lt; rectangles[i][3] &amp;lt;= n
	No two rectangles overlap.




Solutions



Solution 1

All Problems

All Solutions
   </description>
   <pubdate>
    Tue, 07 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-07-3394-Check-if-Grid-can-be-Cut-into-Sections/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-07-3394-Check-if-Grid-can-be-Cut-into-Sections/
   </guid>
  </item>
  <item>
   <title>
    3393 - Count Paths With the Given XOR Value
   </title>
   <description>
    Leetcode






3393. Count Paths With the Given XOR Value

Description



You are given a 2D integer array grid with size m x n. You are also given an integer k.

Your task is to calculate the number of paths you can take from the top-left cell (0, 0) to the bottom-right cell (m - 1, n - 1) satisfying the following constraints:


	You can either move to the right or down. Formally, from the cell (i, j) you may move to the cell (i, j + 1) or to the cell (i + 1, j) if the target cell exists.
	The XOR of all the numbers on the path must be equal to k.


Return the total number of such paths.

Since the answer can be very large, return the result modulo 109 + 7.

&amp;nbsp;
Example 1:


Input: grid = [[2, 1, 5], [7, 10, 0], [12, 6, 4]], k = 11

Output: 3

Explanation:&amp;nbsp;

The 3 paths are:


	(0, 0) &amp;rarr; (1, 0) &amp;rarr; (2, 0) &amp;rarr; (2, 1) &amp;rarr; (2, 2)
	(0, 0) &amp;rarr; (1, 0) &amp;rarr; (1, 1) &amp;rarr; (1, 2) &amp;rarr; (2, 2)
	(0, 0) &amp;rarr; (0, 1) &amp;rarr; (1, 1) &amp;rarr; (2, 1) &amp;rarr; (2, 2)



Example 2:


Input: grid = [[1, 3, 3, 3], [0, 3, 3, 2], [3, 0, 1, 1]], k = 2

Output: 5

Explanation:

The 5 paths are:


	(0, 0) &amp;rarr; (1, 0) &amp;rarr; (2, 0) &amp;rarr; (2, 1) &amp;rarr; (2, 2) &amp;rarr; (2, 3)
	(0, 0) &amp;rarr; (1, 0) &amp;rarr; (1, 1) &amp;rarr; (2, 1) &amp;rarr; (2, 2) &amp;rarr; (2, 3)
	(0, 0) &amp;rarr; (1, 0) &amp;rarr; (1, 1) &amp;rarr; (1, 2) &amp;rarr; (1, 3) &amp;rarr; (2, 3)
	(0, 0) &amp;rarr; (0, 1) &amp;rarr; (1, 1) &amp;rarr; (1, 2) &amp;rarr; (2, 2) &amp;rarr; (2, 3)
	(0, 0) &amp;rarr; (0, 1) &amp;rarr; (0, 2) &amp;rarr; (1, 2) &amp;rarr; (2, 2) &amp;rarr; (2, 3)



Example 3:


Input: grid = [[1, 1, 1, 2], [3, 0, 3, 2], [3, 0, 2, 2]], k = 10

Output: 0


&amp;nbsp;
Constraints:


	1 &amp;lt;= m == grid.length &amp;lt;= 300
	1 &amp;lt;= n == grid[r].length &amp;lt;= 300
	0 &amp;lt;= grid[r][c] &amp;lt; 16
	0 &amp;lt;= k &amp;lt; 16




Solutions



Solution 1

All Problems

All Solutions
   </description>
   <pubdate>
    Mon, 06 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-06-3393-Count-Paths-With-the-Given-XOR-Value/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-06-3393-Count-Paths-With-the-Given-XOR-Value/
   </guid>
  </item>
  <item>
   <title>
    3392 - Count Subarrays of Length Three With a Condition
   </title>
   <description>
    Leetcode






3392. Count Subarrays of Length Three With a Condition

Description



Given an integer array nums, return the number of subarrays of length 3 such that the sum of the first and third numbers equals exactly half of the second number.

&amp;nbsp;
Example 1:


Input: nums = [1,2,1,4,1]

Output: 1

Explanation:

Only the subarray [1,4,1] contains exactly 3 elements where the sum of the first and third numbers equals half the middle number.


Example 2:


Input: nums = [1,1,1]

Output: 0

Explanation:

[1,1,1] is the only subarray of length 3. However, its first and third numbers do not add to half the middle number.


&amp;nbsp;
Constraints:


	3 &amp;lt;= nums.length &amp;lt;= 100
	-100 &amp;lt;= nums[i] &amp;lt;= 100




Solutions



Solution 1: Single Pass

We traverse each subarray of length $3$ in the array $\textit{nums}$ and check if twice the sum of the first and third numbers equals the second number. If it does, we increment the answer by $1$.

After traversing, we return the answer.

The time complexity is $O(n)$, where $n$ is the length of the array $\textit{nums}$. The space complexity is $O(1)$.



	Java

	C++

	Python

	Go

	TypeScript





	
class Solution {
    public int countSubarrays(int[] nums) {
        int ans = 0;
        for (int i = 1; i + 1 &amp;lt; nums.length; ++i) {
            if ((nums[i - 1] + nums[i + 1]) * 2 == nums[i]) {
                ++ans;
            }
        }
        return ans;
    }
}




	
class Solution {
public:
    int countSubarrays(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int ans = 0;
        for (int i = 1; i + 1 &amp;lt; nums.size(); ++i) {
            if ((nums[i - 1] + nums[i + 1]) * 2 == nums[i]) {
                ++ans;
            }
        }
        return ans;
    }
};




	
class Solution:
    def countSubarrays(self, nums: List[int]) -&amp;gt; int:
        return sum(
            (nums[i - 1] + nums[i + 1]) * 2 == nums[i] for i in range(1, len(nums) - 1)
        )




	
func countSubarrays(nums []int) (ans int) {
	for i := 1; i+1 &amp;lt; len(nums); i++ {
		if (nums[i-1]+nums[i+1])*2 == nums[i] {
			ans++
		}
	}
	return
}




	
function countSubarrays(nums: number[]): number {
    let ans: number = 0;
    for (let i = 1; i + 1 &amp;lt; nums.length; ++i) {
        if ((nums[i - 1] + nums[i + 1]) * 2 === nums[i]) {
            ++ans;
        }
    }
    return ans;
}






All Problems

All Solutions
   </description>
   <pubdate>
    Sun, 05 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-05-3392-Count-Subarrays-of-Length-Three-With-a-Condition/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-05-3392-Count-Subarrays-of-Length-Three-With-a-Condition/
   </guid>
  </item>
  <item>
   <title>
    3391 - Design a 3D Binary Matrix with Efficient Layer Tracking
   </title>
   <description>
    Leetcode 3391. Design a 3D Binary Matrix with Efficient Layer Tracking ðŸ”’ Description You are given a n x n x n binary 3D array matrix. Implement the Matrix3D class: Matrix3D(int n) Initializes the object with the 3D binary array matrix, where all elements are initially set to 0. void setCell(int x, int y, int z) Sets the value at matrix[x][y][z] to 1. void unsetCell(int x, int y, int z) Sets the value at matrix[x][y][z] to 0. int largestMatrix() Returns the index x where matrix[x] contains the most number of 1&amp;#39;s. If there are multiple such indices, return the largest x. &amp;nbsp; Example 1: Input: [&amp;quot;Matrix3D&amp;quot;, &amp;quot;setCell&amp;quot;, &amp;quot;largestMatrix&amp;quot;, &amp;quot;setCell&amp;quot;, &amp;quot;largestMatrix&amp;quot;, &amp;quot;setCell&amp;quot;, &amp;quot;largestMatrix&amp;quot;] [[3], [0, 0, 0], [], [1, 1, 2], [], [0, 0, 1], []] Output: [null, null, 0, null, 1, null, 0] Explanation Matrix3D matrix3D = new Matrix3D(3); // Initializes a 3 x 3 x 3 3D array matrix, filled with all 0&amp;#39;s. matrix3D.setCell(0, 0, 0); // Sets matrix[0][0][0] to 1. matrix3D.largestMatrix(); // Returns 0. matrix[0] has the most number of 1&amp;#39;s. matrix3D.setCell(1, 1, 2); // Sets matrix[1][1][2] to 1. matrix3D.largestMatrix(); // Returns 1. matrix[0] and matrix[1] tie with the most number of 1&amp;#39;s, but index 1 is bigger. matrix3D.setCell(0, 0, 1); // Sets matrix[0][0][1] to 1. matrix3D.largestMatrix(); // Returns 0. matrix[0] has the most number of 1&amp;#39;s. Example 2: Input: [&amp;quot;Matrix3D&amp;quot;, &amp;quot;setCell&amp;quot;, &amp;quot;largestMatrix&amp;quot;, &amp;quot;unsetCell&amp;quot;, &amp;quot;largestMatrix&amp;quot;] [[4], [2, 1, 1], [], [2, 1, 1], []] Output: [null, null, 2, null, 3] Explanation Matrix3D matrix3D = new Matrix3D(4); // Initializes a 4 x 4 x 4 3D array matrix, filled with all 0&amp;#39;s. matrix3D.setCell(2, 1, 1); // Sets matrix[2][1][1] to 1. matrix3D.largestMatrix(); // Returns 2. matrix[2] has the most number of 1&amp;#39;s. matrix3D.unsetCell(2, 1, 1); // Sets matrix[2][1][1] to 0. matrix3D.largestMatrix(); // Returns 3. All indices from 0 to 3 tie with the same number of 1&amp;#39;s, but index 3 is the biggest. &amp;nbsp; Constraints: 1 &amp;lt;= n &amp;lt;= 100 0 &amp;lt;= x, y, z &amp;lt; n At most 105 calls are made in total to setCell and unsetCell. At most 104 calls are made to largestMatrix. Solutions Solution 1: Counting + Ordered Set We use a three-dimensional array $\textit{g}$ to represent the matrix, where $\textit{g}[x][y][z]$ represents the value at coordinate $(x, y, z)$ in the matrix. We use an array $\textit{cnt}$ of length $n$ to record the number of 1s in each layer. We use an ordered set $\textit{sl}$ to maintain the number of 1s and the layer number for each layer. The elements in $\textit{sl}$ are $(\textit{cnt}[x], x)$, so $\textit{sl}$ can be sorted in descending order by the number of 1s, and in descending order by layer number if the number of 1s is the same. When calling the setCell method, we first check if $(x, y, z)$ has already been set to 1. If it has, we return directly. Otherwise, we set $\textit{g}[x][y][z]$ to 1, remove $(\textit{cnt}[x], x)$ from $\textit{sl}$, increment $\textit{cnt}[x]$ by 1, and add $(\textit{cnt}[x], x)$ to $\textit{sl}$. When calling the...
   </description>
   <pubdate>
    Sat, 04 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-04-3391-Design-a-3D-Binary-Matrix-with-Efficient-Layer-Tracking/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-04-3391-Design-a-3D-Binary-Matrix-with-Efficient-Layer-Tracking/
   </guid>
  </item>
  <item>
   <title>
    3390 - Longest Team Pass Streak
   </title>
   <description>
    Leetcode






3390. Longest Team Pass Streak ðŸ”’

Description



Table: Teams


+-++
\| player_id   \| int     \|
\| team_name   \| varchar \| 
+-++
\| Column Name \| Type    \|
+-++
(pass_from, time_stamp) is the unique key for this table.
pass_from is a foreign key to player_id from Teams table.
Each row represents a pass made during a match, time_stamp represents the time in minutes (00:00-90:00) when the pass was made,
pass_to is the player_id of the player receiving the pass.


Write a solution to find the longest successful pass streak for each team during the match. The rules are as follows:


	A successful pass streak is defined as consecutive passes where:
	
		Both the pass_from and pass_to players belong to the same team
	
	
	A streak breaks when either:
	
		The pass is intercepted (received by a player from the opposing team)
	
	


Return the result table ordered by team_name in ascending order.

The result format is in the following example.

&amp;nbsp;
Example:


Input:

Teams table:


+--+
\| player_id \| team_name \|
+--+
\| 1         \| Arsenal   \|
\| 2         \| Arsenal   \|
\| 3         \| Arsenal   \|
\| 4         \| Arsenal   \|
\| 5         \| Chelsea   \|
\| 6         \| Chelsea   \|
\| 7         \| Chelsea   \|
\| 8         \| Chelsea   \|
+--+


Passes table:


++
\| pass_from \| time_stamp \| pass_to \|
++
\| 1         \| 00:05      \| 2       \|
\| 2         \| 00:07      \| 3       \|
\| 3         \| 00:08      \| 4       \|
\| 4         \| 00:10      \| 5       \|
\| 6         \| 00:15      \| 7       \|
\| 7         \| 00:17      \| 8       \|
\| 8         \| 00:20      \| 6       \|
\| 6         \| 00:22      \| 5       \|
\| 1         \| 00:25      \| 2       \|
\| 2         \| 00:27      \| 3       \|
++


Output:


+-+
\| team_name \| longest_streak \|
+-+
\| Arsenal   \| 3              \|
\| Chelsea   \| 4              \|
+-+


Explanation:


	Arsenal&amp;#39;s streaks:

    
    	First streak: 3 passes (1&amp;rarr;2&amp;rarr;3&amp;rarr;4) ended when player 4 passed to Chelsea&amp;#39;s player 5
    	Second streak: 2 passes (1&amp;rarr;2&amp;rarr;3)
    	Longest streak = 3
    
    
    Chelsea&amp;#39;s streaks:
    
    	First streak: 3 passes (6&amp;rarr;7&amp;rarr;8&amp;rarr;6&amp;rarr;5)
    	Longest streak = 4
    
    






Solutions



Solution 1



	SQL





	
WITH
    PassesWithTeams AS (
        SELECT
            p.pass_from,
            p.pass_to,
            t1.team_name AS team_from,
            t2.team_name AS team_to,
            IF(t1.team_name = t2.team_name, 1, 0) same_team_flag,
            p.time_stamp
        FROM
            Passes p
            JOIN Teams t1 ON p.pass_from = t1.player_id
            JOIN Teams t2 ON p.pass_to = t2.player_id
    ),
    StreakGroups AS (
        SELECT
            team_from AS team_name,
            time_stamp,
            same_team_flag,
            SUM(
                CASE
                    WHEN same_team_flag = 0 THEN 1
                    ELSE 0
                END
            ) OVER (
                PARTITION BY team_from
                ORDER BY time_stamp
            ) AS group_id
        FROM PassesWithTeams
    ),
    StreakLengths AS (
        SELECT
            team_name,
            group_id,
            COUNT(*) AS streak_length
        FROM StreakGroups
        WHERE same_team_flag = 1
        GROUP BY 1, 2
    ),
    LongestStreaks AS (
        SELECT
            team_name,
            MAX(streak_length) AS longest_streak
        FROM StreakLengths
        GROUP BY 1
    )
SELECT
    team_name,
    longest_streak
FROM LongestStreaks
ORDER BY 1;






All Problems

All Solutions
   </description>
   <pubdate>
    Fri, 03 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-03-3390-Longest-Team-Pass-Streak/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-03-3390-Longest-Team-Pass-Streak/
   </guid>
  </item>
  <item>
   <title>
    3389 - Minimum Operations to Make Character Frequencies Equal
   </title>
   <description>
    Leetcode






3389. Minimum Operations to Make Character Frequencies Equal

Description



You are given a string s.

A string t is called good if all characters of t occur the same number of times.

You can perform the following operations any number of times:


	Delete a character from s.
	Insert a character in s.
	Change a character in s to its next letter in the alphabet.


Note that you cannot change &amp;#39;z&amp;#39; to &amp;#39;a&amp;#39; using the third operation.

Return the minimum number of operations required to make s good.

&amp;nbsp;
Example 1:


Input: s = &amp;quot;acab&amp;quot;

Output: 1

Explanation:

We can make s good by deleting one occurrence of character &amp;#39;a&amp;#39;.


Example 2:


Input: s = &amp;quot;wddw&amp;quot;

Output: 0

Explanation:

We do not need to perform any operations since s is initially good.


Example 3:


Input: s = &amp;quot;aaabc&amp;quot;

Output: 2

Explanation:

We can make s good by applying these operations:


	Change one occurrence of &amp;#39;a&amp;#39; to &amp;#39;b&amp;#39;
	Insert one occurrence of &amp;#39;c&amp;#39; into s



&amp;nbsp;
Constraints:


	3 &amp;lt;= s.length &amp;lt;= 2&amp;nbsp;* 104
	s contains only lowercase English letters.




Solutions



Solution 1

All Problems

All Solutions
   </description>
   <pubdate>
    Thu, 02 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-02-3389-Minimum-Operations-to-Make-Character-Frequencies-Equal/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-02-3389-Minimum-Operations-to-Make-Character-Frequencies-Equal/
   </guid>
  </item>
  <item>
   <title>
    3388 - Count Beautiful Splits in an Array
   </title>
   <description>
    Leetcode 3388. Count Beautiful Splits in an Array Description You are given an array nums. A split of an array nums is beautiful if: The array nums is split into three subarrays: nums1, nums2, and nums3, such that nums can be formed by concatenating nums1, nums2, and nums3 in that order. The subarray nums1 is a prefix of nums2 OR nums2 is a prefix of nums3. Return the number of ways you can make this split. &amp;nbsp; Example 1: Input: nums = [1,1,2,1] Output: 2 Explanation: The beautiful splits are: A split with nums1 = [1], nums2 = [1,2], nums3 = [1]. A split with nums1 = [1], nums2 = [1], nums3 = [2,1]. Example 2: Input: nums = [1,2,3,4] Output: 0 Explanation: There are 0 beautiful splits. &amp;nbsp; Constraints: 1 &amp;lt;= nums.length &amp;lt;= 5000 0 &amp;lt;= nums[i] &amp;lt;= 50 Solutions Solution 1: LCP + Enumeration We can preprocess $\text{LCP}[i][j]$ to represent the length of the longest common prefix of $\textit{nums}[i:]$ and $\textit{nums}[j:]$. Initially, $\text{LCP}[i][j] = 0$. Next, we enumerate $i$ and $j$ in reverse order. For each pair of $i$ and $j$, if $\textit{nums}[i] = \textit{nums}[j]$, then we can get $\text{LCP}[i][j] = \text{LCP}[i + 1][j + 1] + 1$. Finally, we enumerate the ending position $i$ of the first subarray (excluding position $i$) and the ending position $j$ of the second subarray (excluding position $j$). The length of the first subarray is $i$, the length of the second subarray is $j - i$, and the length of the third subarray is $n - j$. If $i \leq j - i$ and $\text{LCP}[0][i] \geq i$, or $j - i \leq n - j$ and $\text{LCP}[i][j] \geq j - i$, then this split is beautiful, and we increment the answer by one. After enumerating, the answer is the number of beautiful splits. The time complexity is $O(n^2)$, and the space complexity is $O(n^2)$. Here, $n$ is the length of the array $\textit{nums}$. Java C++ Python Go TypeScript class Solution { public int beautifulSplits(int[] nums) { int n = nums.length; int[][] lcp = new int[n + 1][n + 1]; for (int i = n - 1; i &amp;gt;= 0; i--) { for (int j = n - 1; j &amp;gt; i; j--) { if (nums[i] == nums[j]) { lcp[i][j] = lcp[i + 1][j + 1] + 1; } } } int ans = 0; for (int i = 1; i &amp;lt; n - 1; i++) { for (int j = i + 1; j &amp;lt; n; j++) { boolean a = (i &amp;lt;= j - i) &amp;amp;&amp;amp; (lcp[0][i] &amp;gt;= i); boolean b = (j - i &amp;lt;= n - j) &amp;amp;&amp;amp; (lcp[i][j] &amp;gt;= j - i); if (a || b) { ans++; } } } return ans; } } class Solution { public: int beautifulSplits(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; lcp(n + 1, vector&amp;lt;int&amp;gt;(n + 1, 0)); for (int i = n - 1; i &amp;gt;= 0; i--) { for (int j = n - 1;...
   </description>
   <pubdate>
    Wed, 01 Jan 2025 00:00:00 -0800
   </pubdate>
   <link/>
   https://leetcode.ca/2025-01-01-3388-Count-Beautiful-Splits-in-an-Array/
   <guid ispermalink="true">
    https://leetcode.ca/2025-01-01-3388-Count-Beautiful-Splits-in-an-Array/
   </guid>
  </item>
 </channel>
</rss>
