<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-382.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-382.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>382 - Linked List Random Node</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 382. Linked List Random Node Description Given a singly linked list, return a random node&amp;#39;s value from the linked list. Each node must have the same probability of being chosen. Implement the Solution class: Solution(ListNode head) Initializes the object with the head of the singly-linked...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-382.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-382.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-382.html" rel="stylesheet"/>
   <link href="solution-382.html" rel="stylesheet"/>
   <link href="solution-382.html" rel="stylesheet"/>
   <link href="solution-382.html" rel="stylesheet"/>
   <link href="solution-382.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="382 - Linked List Random Node" property="og:title"/>
   <meta content="Leetcode 382. Linked List Random Node Description Given a singly linked list, return a random node&amp;#39;s value from the linked list. Each node must have the same probability of being chosen. Implement the Solution class: Solution(ListNode head) Initializes the object with the head of the singly-linked list head. int getRandom() Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen. &amp;nbsp; Example 1: Input [&amp;quot;Solution&amp;quot;, &amp;quot;getRandom&amp;quot;, &amp;quot;getRandom&amp;quot;, &amp;quot;getRandom&amp;quot;, &amp;quot;getRandom&amp;quot;, &amp;quot;getRandom&amp;quot;] [[[1, 2, 3]], [], [], [], [], []] Output [null, 1, 3, 2, 2, 3] Explanation Solution solution = new Solution([1, 2, 3]); solution.getRandom(); // return 1 solution.getRandom(); // return 3 solution.getRandom(); // return 2 solution.getRandom(); // return 2 solution.getRandom(); // return 3 // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning. &amp;nbsp; Constraints: The number of nodes in the linked list will be in the range [1, 104]. -104 &amp;lt;= Node.val &amp;lt;= 104 At most 104 calls will be made to getRandom. &amp;nbsp; Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? Solutions The challenge is to implement the solution in a way that each node has an equal probability of being chosen, given that the size of the linked list is unknown or may not fit into memory (thus, not allowing for a simple array-based solution where one could just pick a random index). Reservoir Sampling This solution uses a technique called Reservoir Sampling. Itâs a fantastic strategy for sampling from a population of unknown size with uniform distribution. The idea is to iterate through each element (or node, in this case), deciding whether to keep it as the current answer or not, until youâve seen all elements. Why Reservoir Sampling Works for Large or Unknown Length Lists: Unknown Length: The beauty of Reservoir Sampling is that it doesnât require knowledge of the population size (or the linked listâs length) beforehand. It processes each item (or node) one at a time and decides whether to include it in the sample (in this case, select it as the current answer). Efficiency: The algorithm only needs a single pass through the data, making it efficient for streaming data or large datasets where multiple passes are impractical or impossible. No Extra Space: Aside from variables for counting (n) and storing the current answer (ans), no additional storage is required. This is particularly advantageous when dealing with large data sets where storing all elements in memory would be infeasible. Hereâs a breakdown of how the code works: Initialization: The constructor simply stores the head of the list for future access. getRandom Function: n is a counter for the nodes seen so far. ans will store the value of the randomly selected node. The loop iterates over each node in the list one by one. For each node, it..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-12-16T00:00:00-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-12-16-382-Linked-List-Random-Node/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-382.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="382 - Linked List Random Node" property="twitter:title"/>
   <meta content="Leetcode 382. Linked List Random Node Description Given a singly linked list, return a random node&amp;#39;s value from the linked list. Each node must have the same probability of being chosen. Implement the Solution class: Solution(ListNode head) Initializes the object with the head of the singly-linked list head. int getRandom() Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen. &amp;nbsp; Example 1: Input [&amp;quot;Solution&amp;quot;, &amp;quot;getRandom&amp;quot;, &amp;quot;getRandom&amp;quot;, &amp;quot;getRandom&amp;quot;, &amp;quot;getRandom&amp;quot;, &amp;quot;getRandom&amp;quot;] [[[1, 2, 3]], [], [], [], [], []] Output [null, 1, 3, 2, 2, 3] Explanation Solution solution = new Solution([1, 2, 3]); solution.getRandom(); // return 1 solution.getRandom(); // return 3 solution.getRandom(); // return 2 solution.getRandom(); // return 2 solution.getRandom(); // return 3 // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning. &amp;nbsp; Constraints: The number of nodes in the linked list will be in the range [1, 104]. -104 &amp;lt;= Node.val &amp;lt;= 104 At most 104 calls will be made to getRandom. &amp;nbsp; Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? Solutions The challenge is to implement the solution in a way that each node has an equal probability of being chosen, given that the size of the linked list is unknown or may not fit into memory (thus, not allowing for a simple array-based solution where one could just pick a random index). Reservoir Sampling This solution uses a technique called Reservoir Sampling. Itâs a fantastic strategy for sampling from a population of unknown size with uniform distribution. The idea is to iterate through each element (or node, in this case), deciding whether to keep it as the current answer or not, until youâve seen all elements. Why Reservoir Sampling Works for Large or Unknown Length Lists: Unknown Length: The beauty of Reservoir Sampling is that it doesnât require knowledge of the population size (or the linked listâs length) beforehand. It processes each item (or node) one at a time and decides whether to include it in the sample (in this case, select it as the current answer). Efficiency: The algorithm only needs a single pass through the data, making it efficient for streaming data or large datasets where multiple passes are impractical or impossible. No Extra Space: Aside from variables for counting (n) and storing the current answer (ans), no additional storage is required. This is particularly advantageous when dealing with large data sets where storing all elements in memory would be infeasible. Hereâs a breakdown of how the code works: Initialization: The constructor simply stores the head of the list for future access. getRandom Function: n is a counter for the nodes seen so far. ans will store the value of the randomly selected node. The loop iterates over each node in the list one by one. For each node, it..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    382 - Linked List Random Node | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="382 - Linked List Random Node" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-382.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-12-16-382-Linked-List-Random-Node/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-12-16T00:00:00-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"382 - Linked List Random Node","dateModified":"2016-12-16T00:00:00-08:00","datePublished":"2016-12-16T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-12-16-382-Linked-List-Random-Node/"},"url":"https://leetcode.ca/2016-12-16-382-Linked-List-Random-Node/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="382-linked-list-random-node">
       <a href="solution-382.html">
        382. Linked List Random Node
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given a singly linked list, return a random node's value from the linked list. Each node must have the
       <strong>
        same probability
       </strong>
       of being chosen.
      </p>
      <p>
       Implement the
       <code>
        Solution
       </code>
       class:
      </p>
      <ul>
       <li>
        <code>
         Solution(ListNode head)
        </code>
        Initializes the object with the head of the singly-linked list
        <code>
         head
        </code>
        .
       </li>
       <li>
        <code>
         int getRandom()
        </code>
        Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen.
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0300-0399/0382.Linked%20List%20Random%20Node/images/getrand-linked-list.jpg" style="width: 302px; height: 62px;"/>
      </p>
      <pre>
<strong>Input</strong>
["Solution", "getRandom", "getRandom", "getRandom", "getRandom", "getRandom"]
[[[1, 2, 3]], [], [], [], [], []]
<strong>Output</strong>
[null, 1, 3, 2, 2, 3]

<strong>Explanation</strong>
Solution solution = new Solution([1, 2, 3]);
solution.getRandom(); // return 1
solution.getRandom(); // return 3
solution.getRandom(); // return 2
solution.getRandom(); // return 2
solution.getRandom(); // return 3
// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.

</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the linked list will be in the range
        <code>
         [1, 10
         <sup>
          4
         </sup>
         ]
        </code>
        .
       </li>
       <li>
        <code>
         -10
         <sup>
          4
         </sup>
         &lt;= Node.val &lt;= 10
         <sup>
          4
         </sup>
        </code>
       </li>
       <li>
        At most
        <code>
         10
         <sup>
          4
         </sup>
        </code>
        calls will be made to
        <code>
         getRandom
        </code>
        .
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong>
        Follow up:
       </strong>
      </p>
      <ul>
       <li>
        What if the linked list is extremely large and its length is unknown to you?
       </li>
       <li>
        Could you solve this efficiently without using extra space?
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       The challenge is to implement the solution in a way that each node has an equal probability of being chosen, given that the size of the linked list is
       <code class="language-plaintext highlighter-rouge">
        unknown
       </code>
       or
       <code class="language-plaintext highlighter-rouge">
        may not fit into memory
       </code>
       (thus, not allowing for a simple array-based solution where one could just pick a random index).
      </p>
      <h3 id="reservoir-sampling">
       Reservoir Sampling
      </h3>
      <p>
       This solution uses a technique called
       <strong>
        Reservoir Sampling
       </strong>
       . Itâs a fantastic strategy for sampling from a population of unknown size with uniform distribution. The idea is to iterate through each element (or node, in this case), deciding whether to keep it as the current answer or not, until youâve seen all elements.
      </p>
      <p>
       Why Reservoir Sampling Works for Large or Unknown Length Lists:
      </p>
      <ol>
       <li>
        <p>
         <strong>
          Unknown Length
         </strong>
         : The beauty of Reservoir Sampling is that it doesnât require knowledge of the population size (or the linked listâs length) beforehand. It processes each item (or node) one at a time and decides whether to include it in the sample (in this case, select it as the current answer).
        </p>
       </li>
       <li>
        <p>
         <strong>
          Efficiency
         </strong>
         : The algorithm only needs a single pass through the data, making it efficient for streaming data or large datasets where multiple passes are impractical or impossible.
        </p>
       </li>
       <li>
        <p>
         <strong>
          No Extra Space
         </strong>
         : Aside from variables for counting (
         <code class="language-plaintext highlighter-rouge">
          n
         </code>
         ) and storing the current answer (
         <code class="language-plaintext highlighter-rouge">
          ans
         </code>
         ), no additional storage is required. This is particularly advantageous when dealing with large data sets where storing all elements in memory would be infeasible.
        </p>
       </li>
      </ol>
      <p>
       Hereâs a breakdown of how the code works:
      </p>
      <ol>
       <li>
        <p>
         <strong>
          Initialization
         </strong>
         : The constructor simply stores the head of the list for future access.
        </p>
       </li>
       <li>
        <p>
         <strong>
          getRandom Function
         </strong>
         :
        </p>
        <ul>
         <li>
          <code class="language-plaintext highlighter-rouge">
           n
          </code>
          is a counter for the nodes seen so far.
         </li>
         <li>
          <code class="language-plaintext highlighter-rouge">
           ans
          </code>
          will store the value of the randomly selected node.
         </li>
         <li>
          The loop iterates over each node in the list one by one.
         </li>
         <li>
          For each node, it increments
          <code class="language-plaintext highlighter-rouge">
           n
          </code>
          (the count of nodes encountered so far).
         </li>
         <li>
          <code class="language-plaintext highlighter-rouge">
           x
          </code>
          is assigned a random integer between 1 and
          <code class="language-plaintext highlighter-rouge">
           n
          </code>
          . This random number decides if the current nodeâs value should replace the previous
          <code class="language-plaintext highlighter-rouge">
           ans
          </code>
          value.
         </li>
         <li>
          If
          <code class="language-plaintext highlighter-rouge">
           x
          </code>
          is equal to
          <code class="language-plaintext highlighter-rouge">
           n
          </code>
          , then
          <code class="language-plaintext highlighter-rouge">
           ans
          </code>
          is updated to the current nodeâs value. The probability of this happening is
          <code class="language-plaintext highlighter-rouge">
           1/n
          </code>
          , ensuring that each node has an equal chance of being chosen. For example, when youâre at the first node,
          <code class="language-plaintext highlighter-rouge">
           n
          </code>
          is 1, so the probability of choosing that node is 100%. When youâre at the second node, thereâs a 50% chance it becomes the answer, and so on.
         </li>
         <li>
          Finally, after traversing all nodes,
          <code class="language-plaintext highlighter-rouge">
           ans
          </code>
          holds the value of a randomly selected node, which is returned.
         </li>
        </ul>
       </li>
      </ol>
      <h3 id="why-it-works">
       Why It Works
      </h3>
      <p>
       The key part of this algorithm is the probability calculation that ensures each node has an equal chance of being selected. When youâre at the ith node, the probability that it gets chosen is
       <code class="language-plaintext highlighter-rouge">
        1/i
       </code>
       . For it to be the final answer, it must also
       <em>
        not
       </em>
       be replaced by subsequent nodes. For the ith node and the next node, the probability that the ith node stays as the answer is
       <code class="language-plaintext highlighter-rouge">
        (1/i) * (1 - 1/(i+1)) = 1/(i+1)
       </code>
       , and this logic extends to all nodes in the list.
      </p>
      <h3 id="complexity">
       Complexity
      </h3>
      <ul>
       <li>
        <strong>
         Time Complexity
        </strong>
        :
        <code class="language-plaintext highlighter-rouge">
         O(N)
        </code>
        , where
        <code class="language-plaintext highlighter-rouge">
         N
        </code>
        is the number of nodes in the list, since it iterates through each node once.
       </li>
       <li>
        <strong>
         Space Complexity
        </strong>
        :
        <code class="language-plaintext highlighter-rouge">
         O(1)
        </code>
        , as it uses only a few variables for any size of input linked list.
       </li>
      </ul>
      <ul class="uk-tab" data-uk-switcher="{connect:'#56c4b1a8-3170-40fe-bbde-4725210fc0a1'}">
       <li class="uk-active">
        <a href="solution-382.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-382.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-382.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-382.html">
         Go
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="56c4b1a8-3170-40fe-bbde-4725210fc0a1">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">ListNode</span> <span class="n">head</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>

    <span class="kd">public</span> <span class="nf">Solution</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getRandom</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">ListNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">++</span><span class="n">n</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(head);
 * int param_1 = obj.getRandom();
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>

    <span class="n">Solution</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">getRandom</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="n">node</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(head);
 * int param_1 = obj-&gt;getRandom();
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">head</span>

    <span class="k">def</span> <span class="nf">getRandom</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">head</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">val</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">ans</span>


<span class="c1"># Your Solution object will be instantiated and called as such:
# obj = Solution(head)
# param_1 = obj.getRandom()
</span>
<span class="c1">############
</span>
<span class="c1"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None
</span><span class="kn">import</span> <span class="nn">random</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">):</span>
    <span class="s">"""
    @param head The linked list's head.
    Note that the head is guaranteed to be not null, so it contains at least one node.
    :type head: ListNode
    """</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">head</span>

  <span class="k">def</span> <span class="nf">getRandom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="s">"""
    Returns a random node's value.
    :rtype: int
    """</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">val</span>
    <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">head</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">idx</span><span class="p">:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">val</span>
      <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span>
      <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">ans</span>

<span class="c1"># Your Solution object will be instantiated and called as such:
# obj = Solution(head)
# param_1 = obj.getRandom()
</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */</span>
<span class="k">type</span> <span class="n">Solution</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">head</span> <span class="o">*</span><span class="n">ListNode</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Constructor</span><span class="p">(</span><span class="n">head</span> <span class="o">*</span><span class="n">ListNode</span><span class="p">)</span> <span class="n">Solution</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">Solution</span><span class="p">{</span><span class="n">head</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Solution</span><span class="p">)</span> <span class="n">GetRandom</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">n</span><span class="p">,</span> <span class="n">ans</span> <span class="o">:=</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span>
	<span class="k">for</span> <span class="n">node</span> <span class="o">:=</span> <span class="n">this</span><span class="o">.</span><span class="n">head</span><span class="p">;</span> <span class="n">node</span> <span class="o">!=</span> <span class="no">nil</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">Next</span> <span class="p">{</span>
		<span class="n">n</span><span class="o">++</span>
		<span class="n">x</span> <span class="o">:=</span> <span class="m">1</span> <span class="o">+</span> <span class="n">rand</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">x</span> <span class="p">{</span>
			<span class="n">ans</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">Val</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ans</span>
<span class="p">}</span>

<span class="c">/**
 * Your Solution object will be instantiated and called as such:
 * obj := Constructor(head);
 * param_1 := obj.GetRandom();
 */</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-382.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
