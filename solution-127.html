<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-127.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-127.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>127 - Word Ladder</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 127. Word Ladder Description A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -&amp;gt; s1 -&amp;gt; s2 -&amp;gt; ... -&amp;gt; sk such that: Every adjacent pair of words differs by a single letter. Every si...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-127.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-127.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-127.html" rel="stylesheet"/>
   <link href="solution-127.html" rel="stylesheet"/>
   <link href="solution-127.html" rel="stylesheet"/>
   <link href="solution-127.html" rel="stylesheet"/>
   <link href="solution-127.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="127 - Word Ladder" property="og:title"/>
   <meta content="Leetcode 127. Word Ladder Description A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -&amp;gt; s1 -&amp;gt; s2 -&amp;gt; ... -&amp;gt; sk such that: Every adjacent pair of words differs by a single letter. Every si for 1 &amp;lt;= i &amp;lt;= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists. &amp;nbsp; Example 1: Input: beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;] Output: 5 Explanation: One shortest transformation sequence is &amp;quot;hit&amp;quot; -&amp;gt; &amp;quot;hot&amp;quot; -&amp;gt; &amp;quot;dot&amp;quot; -&amp;gt; &amp;quot;dog&amp;quot; -&amp;gt; cog&amp;quot;, which is 5 words long. Example 2: Input: beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;] Output: 0 Explanation: The endWord &amp;quot;cog&amp;quot; is not in wordList, therefore there is no valid transformation sequence. &amp;nbsp; Constraints: 1 &amp;lt;= beginWord.length &amp;lt;= 10 endWord.length == beginWord.length 1 &amp;lt;= wordList.length &amp;lt;= 5000 wordList[i].length == beginWord.length beginWord, endWord, and wordList[i] consist of lowercase English letters. beginWord != endWord All the words in wordList are unique. Solutions Solution 1: BFS BFS minimum step model. This problem can be solved with naive BFS, or it can be optimized with bidirectional BFS to reduce the search space and improve efficiency. Bidirectional BFS is a common optimization method for BFS, with the main implementation ideas as follows: Create two queues, q1 and q2, for âstart -&amp;gt; endâ and âend -&amp;gt; startâ search directions, respectively. Create two hash maps, m1 and m2, to record the visited nodes and their corresponding expansion times (steps). During each search, prioritize the queue with fewer elements for search expansion. If a node visited from the other direction is found during the expansion, it means the shortest path has been found. If one of the queues is empty, it means that the search in the current direction cannot continue, indicating that the start and end points are not connected, and there is no need to continue the search. Java C++ Python Go C# TypeScript class Solution { private Set&amp;lt;String&amp;gt; words; public int ladderLength(String beginWord, String endWord, List&amp;lt;String&amp;gt; wordList) { words = new HashSet&amp;lt;&amp;gt;(wordList); if (!words.contains(endWord)) { return 0; } Queue&amp;lt;String&amp;gt; q1 = new ArrayDeque&amp;lt;&amp;gt;(); Queue&amp;lt;String&amp;gt; q2 = new ArrayDeque&amp;lt;&amp;gt;(); Map&amp;lt;String, Integer&amp;gt; m1 = new HashMap&amp;lt;&amp;gt;(); Map&amp;lt;String, Integer&amp;gt; m2 = new HashMap&amp;lt;&amp;gt;(); q1.offer(beginWord); q2.offer(endWord); m1.put(beginWord, 0); m2.put(endWord, 0); while (!q1.isEmpty() &amp;amp;&amp;amp; !q2.isEmpty()) { int t = q1.size() &amp;lt;= q2.size() ? extend(m1, m2, q1) : extend(m2, m1, q2); if (t != -1) { return t + 1; } } return 0; } private int extend(Map&amp;lt;String, Integer&amp;gt; m1, Map&amp;lt;String, Integer&amp;gt; m2, Queue&amp;lt;String&amp;gt; q) { for (int i = q.size(); i &amp;gt; 0; --i) { String s = q.poll(); int step = m1.get(s); char[] chars = s.toCharArray(); for (int j = 0; j &amp;lt; chars.length; ++j) { char ch = chars[j]; for (char k =..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-04-05T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-04-05-127-Word-Ladder/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-127.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="127 - Word Ladder" property="twitter:title"/>
   <meta content="Leetcode 127. Word Ladder Description A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -&amp;gt; s1 -&amp;gt; s2 -&amp;gt; ... -&amp;gt; sk such that: Every adjacent pair of words differs by a single letter. Every si for 1 &amp;lt;= i &amp;lt;= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists. &amp;nbsp; Example 1: Input: beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;] Output: 5 Explanation: One shortest transformation sequence is &amp;quot;hit&amp;quot; -&amp;gt; &amp;quot;hot&amp;quot; -&amp;gt; &amp;quot;dot&amp;quot; -&amp;gt; &amp;quot;dog&amp;quot; -&amp;gt; cog&amp;quot;, which is 5 words long. Example 2: Input: beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;] Output: 0 Explanation: The endWord &amp;quot;cog&amp;quot; is not in wordList, therefore there is no valid transformation sequence. &amp;nbsp; Constraints: 1 &amp;lt;= beginWord.length &amp;lt;= 10 endWord.length == beginWord.length 1 &amp;lt;= wordList.length &amp;lt;= 5000 wordList[i].length == beginWord.length beginWord, endWord, and wordList[i] consist of lowercase English letters. beginWord != endWord All the words in wordList are unique. Solutions Solution 1: BFS BFS minimum step model. This problem can be solved with naive BFS, or it can be optimized with bidirectional BFS to reduce the search space and improve efficiency. Bidirectional BFS is a common optimization method for BFS, with the main implementation ideas as follows: Create two queues, q1 and q2, for âstart -&amp;gt; endâ and âend -&amp;gt; startâ search directions, respectively. Create two hash maps, m1 and m2, to record the visited nodes and their corresponding expansion times (steps). During each search, prioritize the queue with fewer elements for search expansion. If a node visited from the other direction is found during the expansion, it means the shortest path has been found. If one of the queues is empty, it means that the search in the current direction cannot continue, indicating that the start and end points are not connected, and there is no need to continue the search. Java C++ Python Go C# TypeScript class Solution { private Set&amp;lt;String&amp;gt; words; public int ladderLength(String beginWord, String endWord, List&amp;lt;String&amp;gt; wordList) { words = new HashSet&amp;lt;&amp;gt;(wordList); if (!words.contains(endWord)) { return 0; } Queue&amp;lt;String&amp;gt; q1 = new ArrayDeque&amp;lt;&amp;gt;(); Queue&amp;lt;String&amp;gt; q2 = new ArrayDeque&amp;lt;&amp;gt;(); Map&amp;lt;String, Integer&amp;gt; m1 = new HashMap&amp;lt;&amp;gt;(); Map&amp;lt;String, Integer&amp;gt; m2 = new HashMap&amp;lt;&amp;gt;(); q1.offer(beginWord); q2.offer(endWord); m1.put(beginWord, 0); m2.put(endWord, 0); while (!q1.isEmpty() &amp;amp;&amp;amp; !q2.isEmpty()) { int t = q1.size() &amp;lt;= q2.size() ? extend(m1, m2, q1) : extend(m2, m1, q2); if (t != -1) { return t + 1; } } return 0; } private int extend(Map&amp;lt;String, Integer&amp;gt; m1, Map&amp;lt;String, Integer&amp;gt; m2, Queue&amp;lt;String&amp;gt; q) { for (int i = q.size(); i &amp;gt; 0; --i) { String s = q.poll(); int step = m1.get(s); char[] chars = s.toCharArray(); for (int j = 0; j &amp;lt; chars.length; ++j) { char ch = chars[j]; for (char k =..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    127 - Word Ladder | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="127 - Word Ladder" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-127.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-04-05-127-Word-Ladder/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-04-05T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"127 - Word Ladder","dateModified":"2016-04-05T00:00:00-07:00","datePublished":"2016-04-05T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-04-05-127-Word-Ladder/"},"url":"https://leetcode.ca/2016-04-05-127-Word-Ladder/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="127-word-ladder">
       <a href="solution-127.html">
        127. Word Ladder
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       A
       <strong>
        transformation sequence
       </strong>
       from word
       <code>
        beginWord
       </code>
       to word
       <code>
        endWord
       </code>
       using a dictionary
       <code>
        wordList
       </code>
       is a sequence of words
       <code>
        beginWord -&gt; s
        <sub>
         1
        </sub>
        -&gt; s
        <sub>
         2
        </sub>
        -&gt; ... -&gt; s
        <sub>
         k
        </sub>
       </code>
       such that:
      </p>
      <ul>
       <li>
        Every adjacent pair of words differs by a single letter.
       </li>
       <li>
        Every
        <code>
         s
         <sub>
          i
         </sub>
        </code>
        for
        <code>
         1 &lt;= i &lt;= k
        </code>
        is in
        <code>
         wordList
        </code>
        . Note that
        <code>
         beginWord
        </code>
        does not need to be in
        <code>
         wordList
        </code>
        .
       </li>
       <li>
        <code>
         s
         <sub>
          k
         </sub>
         == endWord
        </code>
       </li>
      </ul>
      <p>
       Given two words,
       <code>
        beginWord
       </code>
       and
       <code>
        endWord
       </code>
       , and a dictionary
       <code>
        wordList
       </code>
       , return
       <em>
        the
        <strong>
         number of words
        </strong>
        in the
        <strong>
         shortest transformation sequence
        </strong>
        from
       </em>
       <code>
        beginWord
       </code>
       <em>
        to
       </em>
       <code>
        endWord
       </code>
       <em>
        , or
       </em>
       <code>
        0
       </code>
       <em>
        if no such sequence exists.
       </em>
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
<strong>Output:</strong> 5
<strong>Explanation:</strong> One shortest transformation sequence is "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; cog", which is 5 words long.
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The endWord "cog" is not in wordList, therefore there is no valid transformation sequence.
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= beginWord.length &lt;= 10
        </code>
       </li>
       <li>
        <code>
         endWord.length == beginWord.length
        </code>
       </li>
       <li>
        <code>
         1 &lt;= wordList.length &lt;= 5000
        </code>
       </li>
       <li>
        <code>
         wordList[i].length == beginWord.length
        </code>
       </li>
       <li>
        <code>
         beginWord
        </code>
        ,
        <code>
         endWord
        </code>
        , and
        <code>
         wordList[i]
        </code>
        consist of lowercase English letters.
       </li>
       <li>
        <code>
         beginWord != endWord
        </code>
       </li>
       <li>
        All the words in
        <code>
         wordList
        </code>
        are
        <strong>
         unique
        </strong>
        .
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       <strong>
        Solution 1: BFS
       </strong>
      </p>
      <p>
       BFS minimum step model. This problem can be solved with naive BFS, or it can be optimized with bidirectional BFS to reduce the search space and improve efficiency.
      </p>
      <p>
       Bidirectional BFS is a common optimization method for BFS, with the main implementation ideas as follows:
      </p>
      <ol>
       <li>
        Create two queues, q1 and q2, for âstart -&gt; endâ and âend -&gt; startâ search directions, respectively.
       </li>
       <li>
        Create two hash maps, m1 and m2, to record the visited nodes and their corresponding expansion times (steps).
       </li>
       <li>
        During each search, prioritize the queue with fewer elements for search expansion. If a node visited from the other direction is found during the expansion, it means the shortest path has been found.
       </li>
       <li>
        If one of the queues is empty, it means that the search in the current direction cannot continue, indicating that the start and end points are not connected, and there is no need to continue the search.
       </li>
      </ol>
      <ul class="uk-tab" data-uk-switcher="{connect:'#e184a58c-7cda-495a-9b04-1fec3cb45030'}">
       <li class="uk-active">
        <a href="solution-127.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-127.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-127.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-127.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-127.html">
         C#
        </a>
       </li>
       <li>
        <a href="solution-127.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="e184a58c-7cda-495a-9b04-1fec3cb45030">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">words</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">ladderLength</span><span class="o">(</span><span class="nc">String</span> <span class="n">beginWord</span><span class="o">,</span> <span class="nc">String</span> <span class="n">endWord</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">wordList</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">words</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;(</span><span class="n">wordList</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">words</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">endWord</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">q1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">q2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">m1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">m2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">q1</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">beginWord</span><span class="o">);</span>
        <span class="n">q2</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">endWord</span><span class="o">);</span>
        <span class="n">m1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">beginWord</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="n">m2</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">endWord</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">q1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">q2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">q1</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">q2</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">?</span> <span class="n">extend</span><span class="o">(</span><span class="n">m1</span><span class="o">,</span> <span class="n">m2</span><span class="o">,</span> <span class="n">q1</span><span class="o">)</span> <span class="o">:</span> <span class="n">extend</span><span class="o">(</span><span class="n">m2</span><span class="o">,</span> <span class="n">m1</span><span class="o">,</span> <span class="n">q2</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">extend</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">m1</span><span class="o">,</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">m2</span><span class="o">,</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">k</span> <span class="o">=</span> <span class="sc">'a'</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">chars</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
                    <span class="nc">String</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">chars</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">words</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="o">||</span> <span class="n">m1</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">t</span><span class="o">))</span> <span class="o">{</span>
                        <span class="k">continue</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">m2</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">t</span><span class="o">))</span> <span class="o">{</span>
                        <span class="k">return</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">m2</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
                    <span class="n">m1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">chars</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">ch</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">ladderLength</span><span class="p">(</span><span class="n">string</span> <span class="n">beginWord</span><span class="p">,</span> <span class="n">string</span> <span class="n">endWord</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">wordList</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span><span class="p">(</span><span class="n">wordList</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">wordList</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">words</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">endWord</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">q1</span><span class="p">{</span> <span class="p">{</span><span class="n">beginWord</span><span class="p">}</span> <span class="p">};</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">q2</span><span class="p">{</span> <span class="p">{</span><span class="n">endWord</span><span class="p">}</span> <span class="p">};</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m1</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m2</span><span class="p">;</span>
        <span class="n">m1</span><span class="p">[</span><span class="n">beginWord</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">m2</span><span class="p">[</span><span class="n">endWord</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q1</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">q2</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">q1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">q2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="n">extend</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">words</span><span class="p">)</span> <span class="o">:</span> <span class="n">extend</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">words</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">extend</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">m1</span><span class="p">,</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">m2</span><span class="p">,</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">q</span><span class="p">,</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="n">m1</span><span class="p">[</span><span class="n">s</span><span class="p">];</span>
            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">k</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">words</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">||</span> <span class="n">m1</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">m2</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="k">return</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">m2</span><span class="p">[</span><span class="n">s</span><span class="p">];</span>
                    <span class="n">m1</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-python highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># native BFS
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">ladderLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beginWord</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">endWord</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wordList</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">wordList</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">beginWord</span><span class="p">])</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1"># must convert to list, cannot directly update s[i]='a'
</span>                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
                    <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">26</span><span class="p">):</span>
                        <span class="c1"># will re-generate s itself
</span>                        <span class="c1"># but s not in words-set, s removed after added to words-set
</span>                        <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">endWord</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">ans</span>
                        <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                        <span class="n">words</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1"># equivalent to set t as visited
</span>                    <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span> <span class="c1"># restore
</span>        <span class="k">return</span> <span class="mi">0</span>


<span class="c1">#########
</span>
<span class="s">'''
åå BFS æ¯ BFS å¸¸è§çä¸ä¸ªä¼åæ¹æ³ï¼ä¸»è¦å®ç°æè·¯å¦ä¸ï¼

1. åå»ºä¸¤ä¸ªéå q1, q2 åå«ç¨äºâèµ·ç¹ -&gt; ç»ç¹âãâç»ç¹ -&gt; èµ·ç¹âä¸¤ä¸ªæ¹åçæç´¢ï¼
2. åå»ºä¸¤ä¸ªåå¸è¡¨ m1, m2 åå«è®°å½è®¿é®è¿çèç¹ä»¥åå¯¹åºçæ©å±æ¬¡æ°ï¼æ­¥æ°ï¼ï¼
3. æ¯æ¬¡æç´¢æ¶ï¼ä¼åéæ©åç´ æ°éè¾å°çéåè¿è¡æç´¢æ©å±ï¼å¦æå¨æ©å±è¿ç¨ä¸­ï¼æç´¢å°å¦ä¸ä¸ªæ¹åå·²ç»è®¿é®è¿çèç¹ï¼è¯´ææ¾å°äºæç­è·¯å¾ï¼
4. åªè¦å¶ä¸­ä¸ä¸ªéåä¸ºç©ºï¼è¯´æå½åæ¹åçæç´¢å·²ç»è¿è¡ä¸ä¸å»äºï¼è¯´æèµ·ç¹å°ç»ç¹ä¸è¿éï¼æ éç»§ç»­æç´¢ã
'''</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">ladderLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beginWord</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">endWord</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wordList</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span> <span class="c1"># so, every time, starting from start-word... and later if t in m1 will skip repeated part...
</span>                <span class="n">step</span> <span class="o">=</span> <span class="n">m1</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1"># s = "abc", list(s) ==&gt; ['a', 'b', 'c']
</span>                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
                    <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">26</span><span class="p">):</span>
                        <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">m1</span> <span class="ow">or</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">m2</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">m2</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
                        <span class="n">m1</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">wordList</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">endWord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">beginWord</span><span class="p">]),</span> <span class="n">deque</span><span class="p">([</span><span class="n">endWord</span><span class="p">])</span>
        <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span> <span class="o">=</span> <span class="p">{</span><span class="n">beginWord</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="n">endWord</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="k">while</span> <span class="n">q1</span> <span class="ow">and</span> <span class="n">q2</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">extend</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">q1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">q2</span><span class="p">)</span> <span class="k">else</span> <span class="n">extend</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">q2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="mi">0</span>

<span class="c1">#########
</span>
<span class="kn">import</span> <span class="nn">string</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">ladderLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beginWord</span><span class="p">,</span> <span class="n">endWord</span><span class="p">,</span> <span class="n">wordList</span><span class="p">):</span>
    <span class="s">"""
    :type beginWord: str
    :type endWord: str
    :type wordList: Set[str]
    :rtype: int
    """</span>

    <span class="k">def</span> <span class="nf">getNbrs</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">wordList</span><span class="p">):</span>
      <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">string</span><span class="p">.</span><span class="n">ascii_lowercase</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">)):</span>
          <span class="n">newWord</span> <span class="o">=</span> <span class="n">src</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">src</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
          <span class="k">if</span> <span class="n">newWord</span> <span class="o">==</span> <span class="n">src</span><span class="p">:</span>
            <span class="k">continue</span>
          <span class="k">if</span> <span class="n">newWord</span> <span class="ow">in</span> <span class="n">wordList</span> <span class="ow">or</span> <span class="n">newWord</span> <span class="o">==</span> <span class="n">dest</span><span class="p">:</span>
            <span class="c1"># about yield https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python
</span>            <span class="c1"># yield is a keyword that is used like return, except the function will return a generator.
</span>            <span class="k">yield</span> <span class="n">newWord</span>

    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">beginWord</span><span class="p">])</span>
    <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
      <span class="n">length</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)):</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">getNbrs</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">endWord</span><span class="p">,</span> <span class="n">wordList</span><span class="p">):</span>
          <span class="n">wordList</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">nbr</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">nbr</span> <span class="o">==</span> <span class="n">endWord</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span>
          <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">nbr</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="c1">###########
</span>
<span class="k">while</span> <span class="n">q1</span> <span class="ow">and</span> <span class="n">q2</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">q1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">q2</span><span class="p">):</span>
        <span class="c1"># Prioritize the queue with fewer elements for expansion
</span>        <span class="n">extend</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extend</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">q2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="c1"># New round of expansion
</span>    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">m1</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">m1</span><span class="p">:</span>
                <span class="c1"># Already visited before
</span>                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">m2</span><span class="p">:</span>
                <span class="c1"># The other direction has been searched, indicating that a shortest path has been found
</span>                <span class="k">return</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">m2</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
            <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">m1</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">ladderLength</span><span class="p">(</span><span class="n">beginWord</span> <span class="kt">string</span><span class="p">,</span> <span class="n">endWord</span> <span class="kt">string</span><span class="p">,</span> <span class="n">wordList</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">words</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">word</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">wordList</span> <span class="p">{</span>
		<span class="n">words</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="no">true</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="o">!</span><span class="n">words</span><span class="p">[</span><span class="n">endWord</span><span class="p">]</span> <span class="p">{</span>
		<span class="k">return</span> <span class="m">0</span>
	<span class="p">}</span>

	<span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="n">beginWord</span><span class="p">},</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="n">endWord</span><span class="p">}</span>
	<span class="n">m1</span><span class="p">,</span> <span class="n">m2</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="n">beginWord</span><span class="o">:</span> <span class="m">0</span><span class="p">},</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="n">endWord</span><span class="o">:</span> <span class="m">0</span><span class="p">}</span>
	<span class="n">extend</span> <span class="o">:=</span> <span class="k">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">q1</span><span class="p">);</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="p">{</span>
			<span class="n">s</span> <span class="o">:=</span> <span class="n">q1</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
			<span class="n">step</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">m1</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
			<span class="n">q1</span> <span class="o">=</span> <span class="n">q1</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">]</span>
			<span class="n">chars</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
				<span class="n">ch</span> <span class="o">:=</span> <span class="n">chars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
				<span class="k">for</span> <span class="n">k</span> <span class="o">:=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span> <span class="p">{</span>
					<span class="n">chars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kt">byte</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
					<span class="n">t</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>
					<span class="k">if</span> <span class="o">!</span><span class="n">words</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="p">{</span>
						<span class="k">continue</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">m1</span><span class="p">[</span><span class="n">t</span><span class="p">];</span> <span class="n">ok</span> <span class="p">{</span>
						<span class="k">continue</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="n">v</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">m2</span><span class="p">[</span><span class="n">t</span><span class="p">];</span> <span class="n">ok</span> <span class="p">{</span>
						<span class="k">return</span> <span class="n">step</span> <span class="o">+</span> <span class="m">1</span> <span class="o">+</span> <span class="n">v</span>
					<span class="p">}</span>
					<span class="n">q1</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
					<span class="n">m1</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span> <span class="o">+</span> <span class="m">1</span>
				<span class="p">}</span>
				<span class="n">chars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="m">1</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">q1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="n">q2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">q1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">q2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">m1</span><span class="p">,</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">m2</span><span class="p">,</span> <span class="n">m1</span>
			<span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">q2</span><span class="p">,</span> <span class="n">q1</span>
		<span class="p">}</span>
		<span class="n">t</span> <span class="o">:=</span> <span class="n">extend</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="o">-</span><span class="m">1</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="m">1</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="m">0</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Linq</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="nf">LadderLength</span><span class="p">(</span><span class="kt">string</span> <span class="n">beginWord</span><span class="p">,</span> <span class="kt">string</span> <span class="n">endWord</span><span class="p">,</span> <span class="n">IList</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">wordList</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">words</span> <span class="p">=</span> <span class="n">Enumerable</span><span class="p">.</span><span class="nf">Repeat</span><span class="p">(</span><span class="n">beginWord</span><span class="p">,</span> <span class="m">1</span><span class="p">).</span><span class="nf">Concat</span><span class="p">(</span><span class="n">wordList</span><span class="p">).</span><span class="nf">Select</span><span class="p">((</span><span class="n">word</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span> <span class="n">Word</span> <span class="p">=</span> <span class="n">word</span><span class="p">,</span> <span class="n">Index</span> <span class="p">=</span> <span class="n">i</span> <span class="p">}).</span><span class="nf">ToList</span><span class="p">();</span>
        <span class="kt">var</span> <span class="n">endWordIndex</span> <span class="p">=</span> <span class="n">words</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="n">w</span> <span class="p">=&gt;</span> <span class="n">w</span><span class="p">.</span><span class="n">Word</span> <span class="p">==</span> <span class="n">endWord</span><span class="p">)?.</span><span class="n">Index</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">endWordIndex</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">var</span> <span class="n">paths</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;[</span><span class="n">words</span><span class="p">.</span><span class="n">Count</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">paths</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">paths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">beginWord</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">hashMap</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Hashtable</span><span class="p">();</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">words</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">newWord</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Format</span><span class="p">(</span><span class="s">"{0}_{1}"</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">Word</span><span class="p">.</span><span class="nf">Substring</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">item</span><span class="p">.</span><span class="n">Word</span><span class="p">.</span><span class="nf">Substring</span><span class="p">(</span><span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">));</span>
                <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">similars</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(!</span><span class="n">hashMap</span><span class="p">.</span><span class="nf">ContainsKey</span><span class="p">(</span><span class="n">newWord</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="n">similars</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>
                    <span class="n">hashMap</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">newWord</span><span class="p">,</span> <span class="n">similars</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="n">similars</span> <span class="p">=</span> <span class="p">(</span><span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;)</span><span class="n">hashMap</span><span class="p">[</span><span class="n">newWord</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">similar</span> <span class="k">in</span> <span class="n">similars</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">paths</span><span class="p">[</span><span class="n">similar</span><span class="p">].</span><span class="nf">Add</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">Index</span><span class="p">);</span>
                    <span class="n">paths</span><span class="p">[</span><span class="n">item</span><span class="p">.</span><span class="n">Index</span><span class="p">].</span><span class="nf">Add</span><span class="p">(</span><span class="n">similar</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">similars</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">Index</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="kt">var</span> <span class="n">left</span> <span class="p">=</span> <span class="n">words</span><span class="p">.</span><span class="n">Count</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">lastRound</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">{</span> <span class="m">0</span> <span class="p">};</span>
        <span class="kt">var</span> <span class="n">visited</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">bool</span><span class="p">[</span><span class="n">words</span><span class="p">.</span><span class="n">Count</span><span class="p">];</span>
        <span class="n">visited</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span> <span class="n">left</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">;</span> <span class="p">++</span><span class="n">result</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">thisRound</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">index</span> <span class="k">in</span> <span class="n">lastRound</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">next</span> <span class="k">in</span> <span class="n">paths</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(!</span><span class="n">visited</span><span class="p">[</span><span class="n">next</span><span class="p">])</span>
                    <span class="p">{</span>
                        <span class="n">visited</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="p">==</span> <span class="n">endWordIndex</span><span class="p">)</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
                        <span class="n">thisRound</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">thisRound</span><span class="p">.</span><span class="n">Count</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
            <span class="n">lastRound</span> <span class="p">=</span> <span class="n">thisRound</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">function</span> <span class="nx">ladderLength</span><span class="p">(</span><span class="nx">beginWord</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">endWord</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">wordList</span><span class="p">:</span> <span class="kr">string</span><span class="p">[]):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">wordList</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">endWord</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kd">const</span> <span class="nx">replace</span> <span class="o">=</span> <span class="p">(</span><span class="nx">s</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">i</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">ch</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="o">+</span> <span class="nx">ch</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">length</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">beginWord</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">words</span><span class="p">:</span> <span class="nb">Record</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="kr">string</span><span class="p">[]</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kd">const</span> <span class="nx">g</span><span class="p">:</span> <span class="nb">Record</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="kr">string</span><span class="p">[]</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{};</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">w</span> <span class="k">of</span> <span class="p">[</span><span class="nx">beginWord</span><span class="p">,</span> <span class="p">...</span><span class="nx">wordList</span><span class="p">])</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">derivatives</span><span class="p">:</span> <span class="kr">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">nextW</span> <span class="o">=</span> <span class="nx">replace</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="dl">'</span><span class="s1">*</span><span class="dl">'</span><span class="p">);</span>
            <span class="nx">derivatives</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">nextW</span><span class="p">);</span>

            <span class="nx">g</span><span class="p">[</span><span class="nx">nextW</span><span class="p">]</span> <span class="o">??=</span> <span class="p">[];</span>
            <span class="nx">g</span><span class="p">[</span><span class="nx">nextW</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">w</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nx">words</span><span class="p">[</span><span class="nx">w</span><span class="p">]</span> <span class="o">=</span> <span class="nx">derivatives</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">let</span> <span class="nx">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">q</span> <span class="o">=</span> <span class="nx">words</span><span class="p">[</span><span class="nx">beginWord</span><span class="p">];</span>
    <span class="kd">const</span> <span class="nx">vis</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">([</span><span class="nx">beginWord</span><span class="p">]);</span>

    <span class="k">while</span> <span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">nextQ</span><span class="p">:</span> <span class="kr">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="nx">ans</span><span class="o">++</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">variant</span> <span class="k">of</span> <span class="nx">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">w</span> <span class="k">of</span> <span class="nx">g</span><span class="p">[</span><span class="nx">variant</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">w</span> <span class="o">===</span> <span class="nx">endWord</span><span class="p">)</span> <span class="k">return</span> <span class="nx">ans</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="nx">vis</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">w</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
                <span class="nx">vis</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">w</span><span class="p">);</span>

                <span class="nx">nextQ</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">words</span><span class="p">[</span><span class="nx">w</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nx">q</span> <span class="o">=</span> <span class="nx">nextQ</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-127.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
