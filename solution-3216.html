<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-3216.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-3216.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>3216 - Lexicographically Smallest String After a Swap</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 3216. Lexicographically Smallest String After a Swap Description Given a string s containing only digits, return the lexicographically smallest string that can be obtained after swapping adjacent digits in s with the same parity at most once. Digits have the same parity if both are...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-3216.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-3216.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-3216.html" rel="stylesheet"/>
   <link href="solution-3216.html" rel="stylesheet"/>
   <link href="solution-3216.html" rel="stylesheet"/>
   <link href="solution-3216.html" rel="stylesheet"/>
   <link href="solution-3216.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="3216 - Lexicographically Smallest String After a Swap" property="og:title"/>
   <meta content="Leetcode 3216. Lexicographically Smallest String After a Swap Description Given a string s containing only digits, return the lexicographically smallest string that can be obtained after swapping adjacent digits in s with the same parity at most once. Digits have the same parity if both are odd or both are even. For example, 5 and 9, as well as 2 and 4, have the same parity, while 6 and 9 do not. &amp;nbsp; Example 1: Input: s = &amp;quot;45320&amp;quot; Output: &amp;quot;43520&amp;quot; Explanation: s[1] == &amp;#39;5&amp;#39; and s[2] == &amp;#39;3&amp;#39; both have the same parity, and swapping them results in the lexicographically smallest string. Example 2: Input: s = &amp;quot;001&amp;quot; Output: &amp;quot;001&amp;quot; Explanation: There is no need to perform a swap because s is already the lexicographically smallest. &amp;nbsp; Constraints: 2 &amp;lt;= s.length &amp;lt;= 100 s consists only of digits. Solutions Solution 1: Greedy + Simulation We can traverse the string $\textit{s}$ from left to right. For each pair of adjacent digits, if they have the same parity and the previous digit is greater than the next digit, then we swap these two digits to make the lexicographical order of the string $\textit{s}$ smaller, and then return the swapped string. After the traversal, if no swappable pair of digits is found, it means the string $\textit{s}$ is already in its smallest lexicographical order, and we can return it directly. The time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the string $\textit{s}$. Java C++ Python Go TypeScript class Solution { public String getSmallestString(String s) { char[] cs = s.toCharArray(); int n = cs.length; for (int i = 1; i &amp;lt; n; ++i) { char a = cs[i - 1], b = cs[i]; if (a &amp;gt; b &amp;amp;&amp;amp; a % 2 == b % 2) { cs[i] = a; cs[i - 1] = b; return new String(cs); } } return s; } } class Solution { public: string getSmallestString(string s) { int n = s.length(); for (int i = 1; i &amp;lt; n; ++i) { char a = s[i - 1], b = s[i]; if (a &amp;gt; b &amp;amp;&amp;amp; a % 2 == b % 2) { s[i - 1] = b; s[i] = a; break; } } return s; } }; class Solution: def getSmallestString(self, s: str) -&amp;gt; str: for i, (a, b) in enumerate(pairwise(map(ord, s))): if (a + b) % 2 == 0 and a &amp;gt; b: return s[:i] + s[i + 1] + s[i] + s[i + 2 :] return s func getSmallestString(s string) string { cs := []byte(s) n := len(cs) for i := 1; i &amp;lt; n; i++ { a, b := cs[i-1], cs[i] if a &amp;gt; b &amp;amp;&amp;amp; a%2 == b%2 { cs[i-1], cs[i] = b, a return string(cs) } } return s } function getSmallestString(s: string): string { const n = s.length; const cs: string[] = s.split(''); for (let i = 1; i &amp;lt; n; ++i) { const a = cs[i - 1]; const..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2024-07-25T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2024-07-25-3216-Lexicographically-Smallest-String-After-a-Swap/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-3216.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="3216 - Lexicographically Smallest String After a Swap" property="twitter:title"/>
   <meta content="Leetcode 3216. Lexicographically Smallest String After a Swap Description Given a string s containing only digits, return the lexicographically smallest string that can be obtained after swapping adjacent digits in s with the same parity at most once. Digits have the same parity if both are odd or both are even. For example, 5 and 9, as well as 2 and 4, have the same parity, while 6 and 9 do not. &amp;nbsp; Example 1: Input: s = &amp;quot;45320&amp;quot; Output: &amp;quot;43520&amp;quot; Explanation: s[1] == &amp;#39;5&amp;#39; and s[2] == &amp;#39;3&amp;#39; both have the same parity, and swapping them results in the lexicographically smallest string. Example 2: Input: s = &amp;quot;001&amp;quot; Output: &amp;quot;001&amp;quot; Explanation: There is no need to perform a swap because s is already the lexicographically smallest. &amp;nbsp; Constraints: 2 &amp;lt;= s.length &amp;lt;= 100 s consists only of digits. Solutions Solution 1: Greedy + Simulation We can traverse the string $\textit{s}$ from left to right. For each pair of adjacent digits, if they have the same parity and the previous digit is greater than the next digit, then we swap these two digits to make the lexicographical order of the string $\textit{s}$ smaller, and then return the swapped string. After the traversal, if no swappable pair of digits is found, it means the string $\textit{s}$ is already in its smallest lexicographical order, and we can return it directly. The time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the string $\textit{s}$. Java C++ Python Go TypeScript class Solution { public String getSmallestString(String s) { char[] cs = s.toCharArray(); int n = cs.length; for (int i = 1; i &amp;lt; n; ++i) { char a = cs[i - 1], b = cs[i]; if (a &amp;gt; b &amp;amp;&amp;amp; a % 2 == b % 2) { cs[i] = a; cs[i - 1] = b; return new String(cs); } } return s; } } class Solution { public: string getSmallestString(string s) { int n = s.length(); for (int i = 1; i &amp;lt; n; ++i) { char a = s[i - 1], b = s[i]; if (a &amp;gt; b &amp;amp;&amp;amp; a % 2 == b % 2) { s[i - 1] = b; s[i] = a; break; } } return s; } }; class Solution: def getSmallestString(self, s: str) -&amp;gt; str: for i, (a, b) in enumerate(pairwise(map(ord, s))): if (a + b) % 2 == 0 and a &amp;gt; b: return s[:i] + s[i + 1] + s[i] + s[i + 2 :] return s func getSmallestString(s string) string { cs := []byte(s) n := len(cs) for i := 1; i &amp;lt; n; i++ { a, b := cs[i-1], cs[i] if a &amp;gt; b &amp;amp;&amp;amp; a%2 == b%2 { cs[i-1], cs[i] = b, a return string(cs) } } return s } function getSmallestString(s: string): string { const n = s.length; const cs: string[] = s.split(''); for (let i = 1; i &amp;lt; n; ++i) { const a = cs[i - 1]; const..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    3216 - Lexicographically Smallest String After a Swap | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="3216 - Lexicographically Smallest String After a Swap" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-3216.html" rel="canonical">
          <meta content="https://leetcode.ca/2024-07-25-3216-Lexicographically-Smallest-String-After-a-Swap/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2024-07-25T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"3216 - Lexicographically Smallest String After a Swap","dateModified":"2024-07-25T00:00:00-07:00","datePublished":"2024-07-25T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2024-07-25-3216-Lexicographically-Smallest-String-After-a-Swap/"},"url":"https://leetcode.ca/2024-07-25-3216-Lexicographically-Smallest-String-After-a-Swap/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <!-- problem:start -->
      <h1 id="3216-lexicographically-smallest-string-after-a-swap">
       <a href="solution-3216.html">
        3216. Lexicographically Smallest String After a Swap
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <!-- description:start -->
      <p>
       Given a string
       <code>
        s
       </code>
       containing only digits, return the
       <span data-keyword="lexicographically-smaller-string">
        lexicographically smallest string
       </span>
       that can be obtained after swapping
       <strong>
        adjacent
       </strong>
       digits in
       <code>
        s
       </code>
       with the same
       <strong>
        parity
       </strong>
       at most
       <strong>
        once
       </strong>
       .
      </p>
      <p>
       Digits have the same parity if both are odd or both are even. For example, 5 and 9, as well as 2 and 4, have the same parity, while 6 and 9 do not.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <div class="example-block">
       <p>
        <strong>
         Input:
        </strong>
        <span class="example-io">
         s = "45320"
        </span>
       </p>
       <p>
        <strong>
         Output:
        </strong>
        <span class="example-io">
         "43520"
        </span>
       </p>
       <p>
        <strong>
         Explanation:
        </strong>
       </p>
       <p>
        <code>
         s[1] == '5'
        </code>
        and
        <code>
         s[2] == '3'
        </code>
        both have the same parity, and swapping them results in the lexicographically smallest string.
       </p>
      </div>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <div class="example-block">
       <p>
        <strong>
         Input:
        </strong>
        <span class="example-io">
         s = "001"
        </span>
       </p>
       <p>
        <strong>
         Output:
        </strong>
        <span class="example-io">
         "001"
        </span>
       </p>
       <p>
        <strong>
         Explanation:
        </strong>
       </p>
       <p>
        There is no need to perform a swap because
        <code>
         s
        </code>
        is already the lexicographically smallest.
       </p>
      </div>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         2 &lt;= s.length &lt;= 100
        </code>
       </li>
       <li>
        <code>
         s
        </code>
        consists only of digits.
       </li>
      </ul>
      <!-- description:end -->
      <h2 id="solutions">
       Solutions
      </h2>
      <!-- solution:start -->
      <h3 id="solution-1-greedy--simulation">
       Solution 1: Greedy + Simulation
      </h3>
      <p>
       We can traverse the string $\textit{s}$ from left to right. For each pair of adjacent digits, if they have the same parity and the previous digit is greater than the next digit, then we swap these two digits to make the lexicographical order of the string $\textit{s}$ smaller, and then return the swapped string.
      </p>
      <p>
       After the traversal, if no swappable pair of digits is found, it means the string $\textit{s}$ is already in its smallest lexicographical order, and we can return it directly.
      </p>
      <p>
       The time complexity is $O(n)$, and the space complexity is $O(n)$, where $n$ is the length of the string $\textit{s}$.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#5543c321-c34a-475a-90d5-a3715628f2dd'}">
       <li class="uk-active">
        <a href="solution-3216.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-3216.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-3216.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-3216.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-3216.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="5543c321-c34a-475a-90d5-a3715628f2dd">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getSmallestString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">cs</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="n">cs</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span> <span class="n">b</span> <span class="o">=</span> <span class="n">cs</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">b</span> <span class="o">%</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">cs</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
                <span class="n">cs</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
                <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">cs</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">getSmallestString</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">b</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
                <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">getSmallestString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairwise</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">ord</span><span class="p">,</span> <span class="n">s</span><span class="p">))):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">s</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">func</span> <span class="n">getSmallestString</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="n">cs</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="m">1</span><span class="p">],</span> <span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">%</span><span class="m">2</span> <span class="o">==</span> <span class="n">b</span><span class="o">%</span><span class="m">2</span> <span class="p">{</span>
			<span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="m">1</span><span class="p">],</span> <span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
			<span class="k">return</span> <span class="kt">string</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">s</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">function</span> <span class="nx">getSmallestString</span><span class="p">(</span><span class="nx">s</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">cs</span><span class="p">:</span> <span class="kr">string</span><span class="p">[]</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">''</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">cs</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="kd">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">cs</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">a</span> <span class="o">&gt;</span> <span class="nx">b</span> <span class="o">&amp;&amp;</span> <span class="o">+</span><span class="nx">a</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="o">+</span><span class="nx">b</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">cs</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span>
            <span class="nx">cs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span>
            <span class="k">return</span> <span class="nx">cs</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">''</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-3216.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
