<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-1804.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-1804.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>1804 - Implement Trie II (Prefix Tree)</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 1804. Implement Trie II (Prefix Tree) Description A trie (pronounced as &amp;quot;try&amp;quot;) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker....">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-1804.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-1804.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-1804.html" rel="stylesheet"/>
   <link href="solution-1804.html" rel="stylesheet"/>
   <link href="solution-1804.html" rel="stylesheet"/>
   <link href="solution-1804.html" rel="stylesheet"/>
   <link href="solution-1804.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="1804 - Implement Trie II (Prefix Tree)" property="og:title"/>
   <meta content="Leetcode 1804. Implement Trie II (Prefix Tree) Description A trie (pronounced as &amp;quot;try&amp;quot;) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class: Trie() Initializes the trie object. void insert(String word) Inserts the string word into the trie. int countWordsEqualTo(String word) Returns the number of instances of the string word in the trie. int countWordsStartingWith(String prefix) Returns the number of strings in the trie that have the string prefix as a prefix. void erase(String word) Erases the string word from the trie. &amp;nbsp; Example 1: Input [&amp;quot;Trie&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;countWordsEqualTo&amp;quot;, &amp;quot;countWordsStartingWith&amp;quot;, &amp;quot;erase&amp;quot;, &amp;quot;countWordsEqualTo&amp;quot;, &amp;quot;countWordsStartingWith&amp;quot;, &amp;quot;erase&amp;quot;, &amp;quot;countWordsStartingWith&amp;quot;] [[], [&amp;quot;apple&amp;quot;], [&amp;quot;apple&amp;quot;], [&amp;quot;apple&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;apple&amp;quot;], [&amp;quot;apple&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;apple&amp;quot;], [&amp;quot;app&amp;quot;]] Output [null, null, null, 2, 2, null, 1, 1, null, 0] Explanation Trie trie = new Trie(); trie.insert(&amp;quot;apple&amp;quot;); // Inserts &amp;quot;apple&amp;quot;. trie.insert(&amp;quot;apple&amp;quot;); // Inserts another &amp;quot;apple&amp;quot;. trie.countWordsEqualTo(&amp;quot;apple&amp;quot;); // There are two instances of &amp;quot;apple&amp;quot; so return 2. trie.countWordsStartingWith(&amp;quot;app&amp;quot;); // &amp;quot;app&amp;quot; is a prefix of &amp;quot;apple&amp;quot; so return 2. trie.erase(&amp;quot;apple&amp;quot;); // Erases one &amp;quot;apple&amp;quot;. trie.countWordsEqualTo(&amp;quot;apple&amp;quot;); // Now there is only one instance of &amp;quot;apple&amp;quot; so return 1. trie.countWordsStartingWith(&amp;quot;app&amp;quot;); // return 1 trie.erase(&amp;quot;apple&amp;quot;); // Erases &amp;quot;apple&amp;quot;. Now the trie is empty. trie.countWordsStartingWith(&amp;quot;app&amp;quot;); // return 0 &amp;nbsp; Constraints: 1 &amp;lt;= word.length, prefix.length &amp;lt;= 2000 word and prefix consist only of lowercase English letters. At most 3 * 104 calls in total will be made to insert, countWordsEqualTo, countWordsStartingWith, and erase. It is guaranteed that for any function call to erase, the string word will exist in the trie. Solutions Solution 1: Implement Trie with Array Each node in the Trie includes three parts: An array of pointers children pointing to child nodes. For this problem, the array length is 26, which is the number of lowercase English letters. children[0] corresponds to the lowercase letter a, â¦, children[25] corresponds to the lowercase letter z. An int variable v, representing the number of strings ending with this node. An int variable pv, representing the number of strings with this node as the prefix node. 1. Insert String We start from the root of the Trie and insert the string. For the child node corresponding to the current character, there are two cases: The child node exists. Move to the child node along the pointer and continue to process the next character. The child node does not exist. Create a new child node, record it in the corresponding position of the children array, then move to the child node along the pointer, and increase the pv value of the child node by 1. Continue to search for the next character. Repeat the above steps until the last character of the string is processed, then increase the v value of the current node by 1. The time complexity is $O(n)$, where $n$ is the length of the string. 2. Search Prefix We start from the root of the Trie and..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2020-11-07T00:00:00-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2020-11-07-1804-Implement-Trie-II-(Prefix-Tree)/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-1804.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="1804 - Implement Trie II (Prefix Tree)" property="twitter:title"/>
   <meta content="Leetcode 1804. Implement Trie II (Prefix Tree) Description A trie (pronounced as &amp;quot;try&amp;quot;) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class: Trie() Initializes the trie object. void insert(String word) Inserts the string word into the trie. int countWordsEqualTo(String word) Returns the number of instances of the string word in the trie. int countWordsStartingWith(String prefix) Returns the number of strings in the trie that have the string prefix as a prefix. void erase(String word) Erases the string word from the trie. &amp;nbsp; Example 1: Input [&amp;quot;Trie&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;countWordsEqualTo&amp;quot;, &amp;quot;countWordsStartingWith&amp;quot;, &amp;quot;erase&amp;quot;, &amp;quot;countWordsEqualTo&amp;quot;, &amp;quot;countWordsStartingWith&amp;quot;, &amp;quot;erase&amp;quot;, &amp;quot;countWordsStartingWith&amp;quot;] [[], [&amp;quot;apple&amp;quot;], [&amp;quot;apple&amp;quot;], [&amp;quot;apple&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;apple&amp;quot;], [&amp;quot;apple&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;apple&amp;quot;], [&amp;quot;app&amp;quot;]] Output [null, null, null, 2, 2, null, 1, 1, null, 0] Explanation Trie trie = new Trie(); trie.insert(&amp;quot;apple&amp;quot;); // Inserts &amp;quot;apple&amp;quot;. trie.insert(&amp;quot;apple&amp;quot;); // Inserts another &amp;quot;apple&amp;quot;. trie.countWordsEqualTo(&amp;quot;apple&amp;quot;); // There are two instances of &amp;quot;apple&amp;quot; so return 2. trie.countWordsStartingWith(&amp;quot;app&amp;quot;); // &amp;quot;app&amp;quot; is a prefix of &amp;quot;apple&amp;quot; so return 2. trie.erase(&amp;quot;apple&amp;quot;); // Erases one &amp;quot;apple&amp;quot;. trie.countWordsEqualTo(&amp;quot;apple&amp;quot;); // Now there is only one instance of &amp;quot;apple&amp;quot; so return 1. trie.countWordsStartingWith(&amp;quot;app&amp;quot;); // return 1 trie.erase(&amp;quot;apple&amp;quot;); // Erases &amp;quot;apple&amp;quot;. Now the trie is empty. trie.countWordsStartingWith(&amp;quot;app&amp;quot;); // return 0 &amp;nbsp; Constraints: 1 &amp;lt;= word.length, prefix.length &amp;lt;= 2000 word and prefix consist only of lowercase English letters. At most 3 * 104 calls in total will be made to insert, countWordsEqualTo, countWordsStartingWith, and erase. It is guaranteed that for any function call to erase, the string word will exist in the trie. Solutions Solution 1: Implement Trie with Array Each node in the Trie includes three parts: An array of pointers children pointing to child nodes. For this problem, the array length is 26, which is the number of lowercase English letters. children[0] corresponds to the lowercase letter a, â¦, children[25] corresponds to the lowercase letter z. An int variable v, representing the number of strings ending with this node. An int variable pv, representing the number of strings with this node as the prefix node. 1. Insert String We start from the root of the Trie and insert the string. For the child node corresponding to the current character, there are two cases: The child node exists. Move to the child node along the pointer and continue to process the next character. The child node does not exist. Create a new child node, record it in the corresponding position of the children array, then move to the child node along the pointer, and increase the pv value of the child node by 1. Continue to search for the next character. Repeat the above steps until the last character of the string is processed, then increase the v value of the current node by 1. The time complexity is $O(n)$, where $n$ is the length of the string. 2. Search Prefix We start from the root of the Trie and..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    1804 - Implement Trie II (Prefix Tree) | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="1804 - Implement Trie II (Prefix Tree)" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-1804.html" rel="canonical">
          <meta content="https://leetcode.ca/2020-11-07-1804-Implement-Trie-II-(Prefix-Tree)/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2020-11-07T00:00:00-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"1804 - Implement Trie II (Prefix Tree)","dateModified":"2020-11-07T00:00:00-08:00","datePublished":"2020-11-07T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2020-11-07-1804-Implement-Trie-II-(Prefix-Tree)/"},"url":"https://leetcode.ca/2020-11-07-1804-Implement-Trie-II-(Prefix-Tree)/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="1804-implement-trie-ii-prefix-tree">
       <a href="solution-1804.html">
        1804. Implement Trie II (Prefix Tree)
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       A
       <a href="solution-1804.html" target="_blank">
        <strong>
         trie
        </strong>
       </a>
       (pronounced as "try") or
       <strong>
        prefix tree
       </strong>
       is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.
      </p>
      <p>
       Implement the Trie class:
      </p>
      <ul>
       <li>
        <code>
         Trie()
        </code>
        Initializes the trie object.
       </li>
       <li>
        <code>
         void insert(String word)
        </code>
        Inserts the string
        <code>
         word
        </code>
        into the trie.
       </li>
       <li>
        <code>
         int countWordsEqualTo(String word)
        </code>
        Returns the number of instances of the string
        <code>
         word
        </code>
        in the trie.
       </li>
       <li>
        <code>
         int countWordsStartingWith(String prefix)
        </code>
        Returns the number of strings in the trie that have the string
        <code>
         prefix
        </code>
        as a prefix.
       </li>
       <li>
        <code>
         void erase(String word)
        </code>
        Erases the string
        <code>
         word
        </code>
        from the trie.
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input</strong>
["Trie", "insert", "insert", "countWordsEqualTo", "countWordsStartingWith", "erase", "countWordsEqualTo", "countWordsStartingWith", "erase", "countWordsStartingWith"]
[[], ["apple"], ["apple"], ["apple"], ["app"], ["apple"], ["apple"], ["app"], ["apple"], ["app"]]
<strong>Output</strong>
[null, null, null, 2, 2, null, 1, 1, null, 0]

<strong>Explanation</strong>
Trie trie = new Trie();
trie.insert("apple");               // Inserts "apple".
trie.insert("apple");               // Inserts another "apple".
trie.countWordsEqualTo("apple");    // There are two instances of "apple" so return 2.
trie.countWordsStartingWith("app"); // "app" is a prefix of "apple" so return 2.
trie.erase("apple");                // Erases one "apple".
trie.countWordsEqualTo("apple");    // Now there is only one instance of "apple" so return 1.
trie.countWordsStartingWith("app"); // return 1
trie.erase("apple");                // Erases "apple". Now the trie is empty.
trie.countWordsStartingWith("app"); // return 0
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= word.length, prefix.length &lt;= 2000
        </code>
       </li>
       <li>
        <code>
         word
        </code>
        and
        <code>
         prefix
        </code>
        consist only of lowercase English letters.
       </li>
       <li>
        At most
        <code>
         3 * 10
         <sup>
          4
         </sup>
        </code>
        calls
        <strong>
         in total
        </strong>
        will be made to
        <code>
         insert
        </code>
        ,
        <code>
         countWordsEqualTo
        </code>
        ,
        <code>
         countWordsStartingWith
        </code>
        , and
        <code>
         erase
        </code>
        .
       </li>
       <li>
        It is guaranteed that for any function call to
        <code>
         erase
        </code>
        , the string
        <code>
         word
        </code>
        will exist in the trie.
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       <strong>
        Solution 1: Implement Trie with Array
       </strong>
      </p>
      <p>
       Each node in the Trie includes three parts:
      </p>
      <ol>
       <li>
        An array of pointers
        <code class="language-plaintext highlighter-rouge">
         children
        </code>
        pointing to child nodes. For this problem, the array length is 26, which is the number of lowercase English letters.
        <code class="language-plaintext highlighter-rouge">
         children[0]
        </code>
        corresponds to the lowercase letter a, â¦,
        <code class="language-plaintext highlighter-rouge">
         children[25]
        </code>
        corresponds to the lowercase letter z.
       </li>
       <li>
        An int variable
        <code class="language-plaintext highlighter-rouge">
         v
        </code>
        , representing the number of strings ending with this node.
       </li>
       <li>
        An int variable
        <code class="language-plaintext highlighter-rouge">
         pv
        </code>
        , representing the number of strings with this node as the prefix node.
       </li>
      </ol>
      <h3 id="1-insert-string">
       1. Insert String
      </h3>
      <p>
       We start from the root of the Trie and insert the string. For the child node corresponding to the current character, there are two cases:
      </p>
      <ul>
       <li>
        The child node exists. Move to the child node along the pointer and continue to process the next character.
       </li>
       <li>
        The child node does not exist. Create a new child node, record it in the corresponding position of the
        <code class="language-plaintext highlighter-rouge">
         children
        </code>
        array, then move to the child node along the pointer, and increase the
        <code class="language-plaintext highlighter-rouge">
         pv
        </code>
        value of the child node by 1. Continue to search for the next character.
       </li>
      </ul>
      <p>
       Repeat the above steps until the last character of the string is processed, then increase the
       <code class="language-plaintext highlighter-rouge">
        v
       </code>
       value of the current node by 1.
      </p>
      <p>
       The time complexity is $O(n)$, where $n$ is the length of the string.
      </p>
      <h3 id="2-search-prefix">
       2. Search Prefix
      </h3>
      <p>
       We start from the root of the Trie and search for the prefix. For the child node corresponding to the current character, there are two cases:
      </p>
      <ul>
       <li>
        The child node exists. Move to the child node along the pointer and continue to search for the next character.
       </li>
       <li>
        The child node does not exist. This means that the Trie does not contain this prefix, return a null pointer.
       </li>
      </ul>
      <p>
       Repeat the above steps until a null pointer is returned or the last character of the prefix is searched.
      </p>
      <p>
       The time complexity is $O(n)$, where $n$ is the length of the string.
      </p>
      <h3 id="3-remove-string">
       3. Remove String
      </h3>
      <p>
       We start from the root node of the Trie, and sequentially reduce the
       <code class="language-plaintext highlighter-rouge">
        pv
       </code>
       value of the corresponding child node by 1, until the last character of the string is searched. Then reduce the
       <code class="language-plaintext highlighter-rouge">
        v
       </code>
       value of the current node by 1.
      </p>
      <p>
       The time complexity is $O(n)$, where $n$ is the length of the string.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#c232bcba-4d3c-4846-bc02-c98526447d8c'}">
       <li class="uk-active">
        <a href="solution-1804.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-1804.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-1804.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-1804.html">
         Go
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="c232bcba-4d3c-4846-bc02-c98526447d8c">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">Trie</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Trie</span><span class="o">[]</span> <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Trie</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">v</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">pv</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Trie</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">c</span> <span class="o">-=</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Trie</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">];</span>
            <span class="o">++</span><span class="n">node</span><span class="o">.</span><span class="na">pv</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="o">++</span><span class="n">node</span><span class="o">.</span><span class="na">v</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countWordsEqualTo</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="n">search</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">node</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">node</span><span class="o">.</span><span class="na">v</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countWordsStartingWith</span><span class="o">(</span><span class="nc">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="n">search</span><span class="o">(</span><span class="n">prefix</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">node</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">node</span><span class="o">.</span><span class="na">pv</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">erase</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">c</span> <span class="o">-=</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">];</span>
            <span class="o">--</span><span class="n">node</span><span class="o">.</span><span class="na">pv</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="o">--</span><span class="n">node</span><span class="o">.</span><span class="na">v</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Trie</span> <span class="nf">search</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Trie</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">c</span> <span class="o">-=</span> <span class="sc">'a'</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * int param_2 = obj.countWordsEqualTo(word);
 * int param_3 = obj.countWordsStartingWith(prefix);
 * obj.erase(word);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Trie</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Trie</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">children</span><span class="p">(</span><span class="mi">26</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">v</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">pv</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">string</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Trie</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">c</span> <span class="o">-=</span> <span class="sc">'a'</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Trie</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
            <span class="o">++</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">++</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">countWordsEqualTo</span><span class="p">(</span><span class="n">string</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Trie</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">search</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">node</span> <span class="o">?</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">countWordsStartingWith</span><span class="p">(</span><span class="n">string</span> <span class="n">prefix</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Trie</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">search</span><span class="p">(</span><span class="n">prefix</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">node</span> <span class="o">?</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">pv</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">erase</span><span class="p">(</span><span class="n">string</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Trie</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">c</span> <span class="o">-=</span> <span class="sc">'a'</span><span class="p">;</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
            <span class="o">--</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">--</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Trie</span><span class="o">*&gt;</span> <span class="n">children</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">pv</span><span class="p">;</span>

    <span class="n">Trie</span><span class="o">*</span> <span class="n">search</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Trie</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">c</span> <span class="o">-=</span> <span class="sc">'a'</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj-&gt;insert(word);
 * int param_2 = obj-&gt;countWordsEqualTo(word);
 * int param_3 = obj-&gt;countWordsStartingWith(prefix);
 * obj-&gt;erase(word);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">pv</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">node</span><span class="p">.</span><span class="n">pv</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">node</span><span class="p">.</span><span class="n">v</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">countWordsEqualTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">node</span><span class="p">.</span><span class="n">v</span>

    <span class="k">def</span> <span class="nf">countWordsStartingWith</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">node</span><span class="p">.</span><span class="n">pv</span>

    <span class="k">def</span> <span class="nf">erase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">node</span><span class="p">.</span><span class="n">pv</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">node</span><span class="p">.</span><span class="n">v</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">node</span>


<span class="c1"># Your Trie object will be instantiated and called as such:
# obj = Trie()
# obj.insert(word)
# param_2 = obj.countWordsEqualTo(word)
# param_3 = obj.countWordsStartingWith(prefix)
# obj.erase(word)
</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">type</span> <span class="n">Trie</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">children</span> <span class="p">[</span><span class="m">26</span><span class="p">]</span><span class="o">*</span><span class="n">Trie</span>
	<span class="n">v</span>        <span class="kt">int</span>
	<span class="n">pv</span>       <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Constructor</span><span class="p">()</span> <span class="p">(</span><span class="n">_</span> <span class="n">Trie</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Trie</span><span class="p">)</span> <span class="n">Insert</span><span class="p">(</span><span class="n">word</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">this</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">word</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">-=</span> <span class="sc">'a'</span>
		<span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Trie</span><span class="p">{}</span>
		<span class="p">}</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
		<span class="n">node</span><span class="o">.</span><span class="n">pv</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="n">node</span><span class="o">.</span><span class="n">v</span><span class="o">++</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Trie</span><span class="p">)</span> <span class="n">CountWordsEqualTo</span><span class="p">(</span><span class="n">word</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">this</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="m">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">v</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Trie</span><span class="p">)</span> <span class="n">CountWordsStartingWith</span><span class="p">(</span><span class="n">prefix</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">this</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="m">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">pv</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Trie</span><span class="p">)</span> <span class="n">Erase</span><span class="p">(</span><span class="n">word</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">this</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">word</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">-=</span> <span class="sc">'a'</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
		<span class="n">node</span><span class="o">.</span><span class="n">pv</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="n">node</span><span class="o">.</span><span class="n">v</span><span class="o">--</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">Trie</span><span class="p">)</span> <span class="n">search</span><span class="p">(</span><span class="n">word</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="n">Trie</span> <span class="p">{</span>
	<span class="n">node</span> <span class="o">:=</span> <span class="n">this</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">word</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">-=</span> <span class="sc">'a'</span>
		<span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="no">nil</span>
		<span class="p">}</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">node</span>
<span class="p">}</span>

<span class="c">/**
 * Your Trie object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Insert(word);
 * param_2 := obj.CountWordsEqualTo(word);
 * param_3 := obj.CountWordsStartingWith(prefix);
 * obj.Erase(word);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-1804.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
