<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-24.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-24.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>24 - Swap Nodes in Pairs</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 24. Swap Nodes in Pairs Description Given a&amp;nbsp;linked list, swap every two adjacent nodes and return its head. You must solve the problem without&amp;nbsp;modifying the values in the list&amp;#39;s nodes (i.e., only nodes themselves may be changed.) &amp;nbsp; Example 1: Input: head = [1,2,3,4] Output:...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-24.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-24.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-24.html" rel="stylesheet"/>
   <link href="solution-24.html" rel="stylesheet"/>
   <link href="solution-24.html" rel="stylesheet"/>
   <link href="solution-24.html" rel="stylesheet"/>
   <link href="solution-24.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="24 - Swap Nodes in Pairs" property="og:title"/>
   <meta content="Leetcode 24. Swap Nodes in Pairs Description Given a&amp;nbsp;linked list, swap every two adjacent nodes and return its head. You must solve the problem without&amp;nbsp;modifying the values in the list&amp;#39;s nodes (i.e., only nodes themselves may be changed.) &amp;nbsp; Example 1: Input: head = [1,2,3,4] Output: [2,1,4,3] Example 2: Input: head = [] Output: [] Example 3: Input: head = [1] Output: [1] &amp;nbsp; Constraints: The number of nodes in the&amp;nbsp;list&amp;nbsp;is in the range [0, 100]. 0 &amp;lt;= Node.val &amp;lt;= 100 Solutions Solution 1: Recursion We can implement swapping two nodes in the linked list through recursion. The termination condition of recursion is that there are no nodes in the linked list, or there is only one node in the linked list. At this time, swapping cannot be performed, so we directly return this node. Otherwise, we recursively swap the linked list $head.next.next$, and let the swapped head node be $t$. Then we let $p$ be the next node of $head$, and let $p$ point to $head$, and $head$ point to $t$, finally return $p$. The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the linked list. Solution 2: Iteration We set a dummy head node $dummy$, initially pointing to $head$, and then set two pointers $pre$ and $cur$, initially $pre$ points to $dummy$, and $cur$ points to $head$. Next, we traverse the linked list. Each time we need to swap the two nodes after $pre$, so we first judge whether $cur$ and $cur.next$ are empty. If they are not empty, we perform the swap, otherwise we terminate the loop. The time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the linked list. Java C++ Python Go TypeScript Javascript Ruby RenderScript Php /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode pre = dummy; ListNode cur = head; while (cur != null &amp;amp;&amp;amp; cur.next != null) { ListNode t = cur.next; cur.next = t.next; t.next = cur; pre.next = t; pre = cur; cur = cur.next; } return dummy.next; } } /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummy = new ListNode(0, head); ListNode* pre = dummy; ListNode* cur = head; while (cur &amp;amp;&amp;amp; cur-&amp;gt;next) { ListNode* t = cur-&amp;gt;next; cur-&amp;gt;next = t-&amp;gt;next; t-&amp;gt;next = cur; pre-&amp;gt;next = t; pre = cur; cur = cur-&amp;gt;next; } return dummy-&amp;gt;next; } }; # Definition for singly-linked list. # class ListNode:..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2015-12-24T00:00:00-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2015-12-24-24-Swap-Nodes-in-Pairs/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-24.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="24 - Swap Nodes in Pairs" property="twitter:title"/>
   <meta content="Leetcode 24. Swap Nodes in Pairs Description Given a&amp;nbsp;linked list, swap every two adjacent nodes and return its head. You must solve the problem without&amp;nbsp;modifying the values in the list&amp;#39;s nodes (i.e., only nodes themselves may be changed.) &amp;nbsp; Example 1: Input: head = [1,2,3,4] Output: [2,1,4,3] Example 2: Input: head = [] Output: [] Example 3: Input: head = [1] Output: [1] &amp;nbsp; Constraints: The number of nodes in the&amp;nbsp;list&amp;nbsp;is in the range [0, 100]. 0 &amp;lt;= Node.val &amp;lt;= 100 Solutions Solution 1: Recursion We can implement swapping two nodes in the linked list through recursion. The termination condition of recursion is that there are no nodes in the linked list, or there is only one node in the linked list. At this time, swapping cannot be performed, so we directly return this node. Otherwise, we recursively swap the linked list $head.next.next$, and let the swapped head node be $t$. Then we let $p$ be the next node of $head$, and let $p$ point to $head$, and $head$ point to $t$, finally return $p$. The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the linked list. Solution 2: Iteration We set a dummy head node $dummy$, initially pointing to $head$, and then set two pointers $pre$ and $cur$, initially $pre$ points to $dummy$, and $cur$ points to $head$. Next, we traverse the linked list. Each time we need to swap the two nodes after $pre$, so we first judge whether $cur$ and $cur.next$ are empty. If they are not empty, we perform the swap, otherwise we terminate the loop. The time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the linked list. Java C++ Python Go TypeScript Javascript Ruby RenderScript Php /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); ListNode pre = dummy; ListNode cur = head; while (cur != null &amp;amp;&amp;amp; cur.next != null) { ListNode t = cur.next; cur.next = t.next; t.next = cur; pre.next = t; pre = cur; cur = cur.next; } return dummy.next; } } /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummy = new ListNode(0, head); ListNode* pre = dummy; ListNode* cur = head; while (cur &amp;amp;&amp;amp; cur-&amp;gt;next) { ListNode* t = cur-&amp;gt;next; cur-&amp;gt;next = t-&amp;gt;next; t-&amp;gt;next = cur; pre-&amp;gt;next = t; pre = cur; cur = cur-&amp;gt;next; } return dummy-&amp;gt;next; } }; # Definition for singly-linked list. # class ListNode:..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    24 - Swap Nodes in Pairs | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="24 - Swap Nodes in Pairs" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-24.html" rel="canonical">
          <meta content="https://leetcode.ca/2015-12-24-24-Swap-Nodes-in-Pairs/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2015-12-24T00:00:00-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"24 - Swap Nodes in Pairs","dateModified":"2015-12-24T00:00:00-08:00","datePublished":"2015-12-24T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2015-12-24-24-Swap-Nodes-in-Pairs/"},"url":"https://leetcode.ca/2015-12-24-24-Swap-Nodes-in-Pairs/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="24-swap-nodes-in-pairs">
       <a href="solution-24.html">
        24. Swap Nodes in Pairs
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0000-0099/0024.Swap%20Nodes%20in%20Pairs/images/swap_ex1.jpg" style="width: 422px; height: 222px;"/>
      </p>
      <pre>
<strong>Input:</strong> head = [1,2,3,4]
<strong>Output:</strong> [2,1,4,3]
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> head = []
<strong>Output:</strong> []
</pre>
      <p>
       <strong class="example">
        Example 3:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> head = [1]
<strong>Output:</strong> [1]
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the list is in the range
        <code>
         [0, 100]
        </code>
        .
       </li>
       <li>
        <code>
         0 &lt;= Node.val &lt;= 100
        </code>
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       <strong>
        Solution 1: Recursion
       </strong>
      </p>
      <p>
       We can implement swapping two nodes in the linked list through recursion.
      </p>
      <p>
       The termination condition of recursion is that there are no nodes in the linked list, or there is only one node in the linked list. At this time, swapping cannot be performed, so we directly return this node.
      </p>
      <p>
       Otherwise, we recursively swap the linked list $head.next.next$, and let the swapped head node be $t$. Then we let $p$ be the next node of $head$, and let $p$ point to $head$, and $head$ point to $t$, finally return $p$.
      </p>
      <p>
       The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the linked list.
      </p>
      <p>
       <strong>
        Solution 2: Iteration
       </strong>
      </p>
      <p>
       We set a dummy head node $dummy$, initially pointing to $head$, and then set two pointers $pre$ and $cur$, initially $pre$ points to $dummy$, and $cur$ points to $head$.
      </p>
      <p>
       Next, we traverse the linked list. Each time we need to swap the two nodes after $pre$, so we first judge whether $cur$ and $cur.next$ are empty. If they are not empty, we perform the swap, otherwise we terminate the loop.
      </p>
      <p>
       The time complexity is $O(n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the linked list.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#1bca2c9a-25db-458e-bebf-793bbb21aaa4'}">
       <li class="uk-active">
        <a href="solution-24.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-24.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-24.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-24.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-24.html">
         TypeScript
        </a>
       </li>
       <li>
        <a href="solution-24.html">
         Javascript
        </a>
       </li>
       <li>
        <a href="solution-24.html">
         Ruby
        </a>
       </li>
       <li>
        <a href="solution-24.html">
         RenderScript
        </a>
       </li>
       <li>
        <a href="solution-24.html">
         Php
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="1bca2c9a-25db-458e-bebf-793bbb21aaa4">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">swapPairs</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">head</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">ListNode</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">t</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
            <span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">swapPairs</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">;</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ListNode</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
            <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">swapPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="nb">next</span><span class="o">=</span><span class="n">head</span><span class="p">)</span>
        <span class="n">pre</span><span class="p">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">cur</span> <span class="ow">and</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">t</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">cur</span>
            <span class="n">pre</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">t</span>
            <span class="n">pre</span><span class="p">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">,</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */</span>
<span class="k">func</span> <span class="n">swapPairs</span><span class="p">(</span><span class="n">head</span> <span class="o">*</span><span class="n">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="n">ListNode</span> <span class="p">{</span>
	<span class="n">dummy</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">ListNode</span><span class="p">{</span><span class="n">Next</span><span class="o">:</span> <span class="n">head</span><span class="p">}</span>
	<span class="n">pre</span><span class="p">,</span> <span class="n">cur</span> <span class="o">:=</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">head</span>
	<span class="k">for</span> <span class="n">cur</span> <span class="o">!=</span> <span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">.</span><span class="n">Next</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">t</span> <span class="o">:=</span> <span class="n">cur</span><span class="o">.</span><span class="n">Next</span>
		<span class="n">cur</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">Next</span>
		<span class="n">t</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="n">cur</span>
		<span class="n">pre</span><span class="o">.</span><span class="n">Next</span> <span class="o">=</span> <span class="n">t</span>
		<span class="n">pre</span><span class="p">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">,</span> <span class="n">cur</span><span class="o">.</span><span class="n">Next</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="n">Next</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */</span>

<span class="kd">function</span> <span class="nx">swapPairs</span><span class="p">(</span><span class="nx">head</span><span class="p">:</span> <span class="nx">ListNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="nx">ListNode</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">head</span><span class="p">);</span>
    <span class="kd">let</span> <span class="p">[</span><span class="nx">pre</span><span class="p">,</span> <span class="nx">cur</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">dummy</span><span class="p">,</span> <span class="nx">head</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">cur</span> <span class="o">&amp;&amp;</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
        <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">;</span>
        <span class="nx">pre</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">t</span><span class="p">;</span>
        <span class="p">[</span><span class="nx">pre</span><span class="p">,</span> <span class="nx">cur</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">cur</span><span class="p">,</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">dummy</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-js highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */</span>
<span class="cm">/**
 * @param {ListNode} head
 * @return {ListNode}
 */</span>
<span class="kd">var</span> <span class="nx">swapPairs</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">head</span><span class="p">);</span>
    <span class="kd">let</span> <span class="p">[</span><span class="nx">pre</span><span class="p">,</span> <span class="nx">cur</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">dummy</span><span class="p">,</span> <span class="nx">head</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">cur</span> <span class="o">&amp;&amp;</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
        <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">;</span>
        <span class="nx">pre</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">t</span><span class="p">;</span>
        <span class="p">[</span><span class="nx">pre</span><span class="p">,</span> <span class="nx">cur</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">cur</span><span class="p">,</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">dummy</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
<span class="p">};</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-rb highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode</span>
<span class="c1">#     attr_accessor :val, :next</span>
<span class="c1">#     def initialize(val = 0, _next = nil)</span>
<span class="c1">#         @val = val</span>
<span class="c1">#         @next = _next</span>
<span class="c1">#     end</span>
<span class="c1"># end</span>
<span class="c1"># @param {ListNode} head</span>
<span class="c1"># @return {ListNode}</span>
<span class="k">def</span> <span class="nf">swap_pairs</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
  <span class="n">dummy</span> <span class="o">=</span> <span class="no">ListNode</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span>
  <span class="n">pre</span> <span class="o">=</span> <span class="n">dummy</span>
  <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span>
  <span class="k">while</span> <span class="o">!</span><span class="n">cur</span><span class="p">.</span><span class="nf">nil?</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cur</span><span class="p">.</span><span class="nf">next</span><span class="p">.</span><span class="nf">nil?</span>
      <span class="n">t</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nf">next</span>
      <span class="n">cur</span><span class="p">.</span><span class="nf">next</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">next</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">next</span> <span class="o">=</span> <span class="n">cur</span>
      <span class="n">pre</span><span class="p">.</span><span class="nf">next</span> <span class="o">=</span> <span class="n">t</span>
      <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span>
      <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nf">next</span>
  <span class="k">end</span>
  <span class="n">dummy</span><span class="p">.</span><span class="nf">next</span>
<span class="k">end</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-rs highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1">// Definition for singly-linked list.</span>
<span class="c1">// #[derive(PartialEq, Eq, Clone, Debug)]</span>
<span class="c1">// pub struct ListNode {</span>
<span class="c1">//   pub val: i32,</span>
<span class="c1">//   pub next: Option&lt;Box&lt;ListNode&gt;&gt;</span>
<span class="c1">// }</span>
<span class="c1">//</span>
<span class="c1">// impl ListNode {</span>
<span class="c1">//   #[inline]</span>
<span class="c1">//   fn new(val: i32) -&gt; Self {</span>
<span class="c1">//     ListNode {</span>
<span class="c1">//       next: None,</span>
<span class="c1">//       val</span>
<span class="c1">//     }</span>
<span class="c1">//   }</span>
<span class="c1">// }</span>
<span class="k">impl</span> <span class="n">Solution</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">swap_pairs</span><span class="p">(</span><span class="n">head</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">dummy</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ListNode</span> <span class="p">{</span> <span class="n">val</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">next</span><span class="p">:</span> <span class="n">head</span> <span class="p">}));</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">dummy</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">while</span> <span class="n">cur</span><span class="py">.next</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="py">.next</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.next</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">cur</span><span class="py">.next</span> <span class="o">=</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">b</span> <span class="o">=</span> <span class="n">cur</span><span class="py">.next</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.next</span><span class="nf">.take</span><span class="p">();</span>
                <span class="n">cur</span><span class="py">.next</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.next</span> <span class="o">=</span> <span class="n">b</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.next</span><span class="nf">.take</span><span class="p">();</span>
                <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">cur</span><span class="py">.next</span><span class="nf">.take</span><span class="p">();</span>
                <span class="n">b</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.next</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
                <span class="n">b</span>
            <span class="p">};</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="py">.next</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.next</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">dummy</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.next</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-php highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode {</span>
<span class="c1">#    public $val;</span>
<span class="c1">#    public $next;</span>
<span class="c1">#    public function __construct($val = 0, $next = null)</span>
<span class="c1">#    {</span>
<span class="c1">#        $this-&gt;val = $val;</span>
<span class="c1">#        $this-&gt;next = $next;</span>
<span class="c1">#    }</span>
<span class="c1"># }</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="cd">/**
     * @param ListNode $head
     * @return ListNode
     */</span>

    <span class="k">function</span> <span class="n">swapPairs</span><span class="p">(</span><span class="nv">$head</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="nv">$dummy</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nv">$head</span><span class="p">;</span>
        <span class="nv">$prev</span> <span class="o">=</span> <span class="nv">$dummy</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="nv">$head</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nv">$head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="nv">$first</span> <span class="o">=</span> <span class="nv">$head</span><span class="p">;</span>
            <span class="nv">$second</span> <span class="o">=</span> <span class="nv">$head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

            <span class="nv">$first</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nv">$second</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="nv">$second</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nv">$first</span><span class="p">;</span>
            <span class="nv">$prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nv">$second</span><span class="p">;</span>

            <span class="nv">$prev</span> <span class="o">=</span> <span class="nv">$first</span><span class="p">;</span>
            <span class="nv">$head</span> <span class="o">=</span> <span class="nv">$first</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nv">$dummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-24.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
