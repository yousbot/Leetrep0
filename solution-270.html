<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-270.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-270.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>270 - Closest Binary Search Tree Value</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 270. Closest Binary Search Tree Value Description Given the root of a binary search tree and a target value, return the value in the BST that is closest to the target. If there are multiple answers, print the smallest. &amp;nbsp; Example 1: Input: root =...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-270.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-270.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-270.html" rel="stylesheet"/>
   <link href="solution-270.html" rel="stylesheet"/>
   <link href="solution-270.html" rel="stylesheet"/>
   <link href="solution-270.html" rel="stylesheet"/>
   <link href="solution-270.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="270 - Closest Binary Search Tree Value" property="og:title"/>
   <meta content='Leetcode 270. Closest Binary Search Tree Value Description Given the root of a binary search tree and a target value, return the value in the BST that is closest to the target. If there are multiple answers, print the smallest. &amp;nbsp; Example 1: Input: root = [4,2,5,1,3], target = 3.714286 Output: 4 Example 2: Input: root = [1], target = 4.428571 Output: 1 &amp;nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. 0 &amp;lt;= Node.val &amp;lt;= 109 -109 &amp;lt;= target &amp;lt;= 109 Solutions Binary search. Use the characteristics of the binary search tree (left&amp;lt;root&amp;lt;right) to quickly locate, because the root node is an intermediate value, When we traverse down, we compare according to the relationship between the target value and the value of the root node. If the target value is less than the node value, we should find a smaller value, so we go to the left subtree to find, otherwise we go to the right subtree to find. Java C++ Python Go Javascript TypeScript /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int closestValue(TreeNode root, double target) { int ans = root.val; double mi = Double.MAX_VALUE; while (root != null) { double t = Math.abs(root.val - target); if (t &amp;lt; mi || (t == mi &amp;amp;&amp;amp; root.val &amp;lt; ans)) { mi = t; ans = root.val; } if (root.val &amp;gt; target) { root = root.left; } else { root = root.right; } } return ans; } } /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int closestValue(TreeNode* root, double target) { int ans = root-&amp;gt;val; double mi = INT_MAX; while (root) { double t = abs(root-&amp;gt;val - target); if (t &amp;lt; mi || (t == mi &amp;amp;&amp;amp; root-&amp;gt;val &amp;lt; ans)) { mi = t; ans = root-&amp;gt;val; } if (root-&amp;gt;val &amp;gt; target) { root = root-&amp;gt;left; } else { root = root-&amp;gt;right; } } return ans; } }; # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def closestValue(self, p, target): """ :type root: TreeNode :type target: float :rtype: int """ ans = p.val while p: if abs(target - p.val) &amp;lt; abs(ans - target): ans = p.val if target &amp;lt; p.val: p = p.left else: p = p.right return ans ############ # Definition for a binary tree node....' property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-08-26T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-08-26-270-Closest-Binary-Search-Tree-Value/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-270.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="270 - Closest Binary Search Tree Value" property="twitter:title"/>
   <meta content='Leetcode 270. Closest Binary Search Tree Value Description Given the root of a binary search tree and a target value, return the value in the BST that is closest to the target. If there are multiple answers, print the smallest. &amp;nbsp; Example 1: Input: root = [4,2,5,1,3], target = 3.714286 Output: 4 Example 2: Input: root = [1], target = 4.428571 Output: 1 &amp;nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. 0 &amp;lt;= Node.val &amp;lt;= 109 -109 &amp;lt;= target &amp;lt;= 109 Solutions Binary search. Use the characteristics of the binary search tree (left&amp;lt;root&amp;lt;right) to quickly locate, because the root node is an intermediate value, When we traverse down, we compare according to the relationship between the target value and the value of the root node. If the target value is less than the node value, we should find a smaller value, so we go to the left subtree to find, otherwise we go to the right subtree to find. Java C++ Python Go Javascript TypeScript /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int closestValue(TreeNode root, double target) { int ans = root.val; double mi = Double.MAX_VALUE; while (root != null) { double t = Math.abs(root.val - target); if (t &amp;lt; mi || (t == mi &amp;amp;&amp;amp; root.val &amp;lt; ans)) { mi = t; ans = root.val; } if (root.val &amp;gt; target) { root = root.left; } else { root = root.right; } } return ans; } } /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int closestValue(TreeNode* root, double target) { int ans = root-&amp;gt;val; double mi = INT_MAX; while (root) { double t = abs(root-&amp;gt;val - target); if (t &amp;lt; mi || (t == mi &amp;amp;&amp;amp; root-&amp;gt;val &amp;lt; ans)) { mi = t; ans = root-&amp;gt;val; } if (root-&amp;gt;val &amp;gt; target) { root = root-&amp;gt;left; } else { root = root-&amp;gt;right; } } return ans; } }; # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def closestValue(self, p, target): """ :type root: TreeNode :type target: float :rtype: int """ ans = p.val while p: if abs(target - p.val) &amp;lt; abs(ans - target): ans = p.val if target &amp;lt; p.val: p = p.left else: p = p.right return ans ############ # Definition for a binary tree node....' property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    270 - Closest Binary Search Tree Value | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="270 - Closest Binary Search Tree Value" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-270.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-08-26-270-Closest-Binary-Search-Tree-Value/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-08-26T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"270 - Closest Binary Search Tree Value","dateModified":"2016-08-26T00:00:00-07:00","datePublished":"2016-08-26T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-08-26-270-Closest-Binary-Search-Tree-Value/"},"url":"https://leetcode.ca/2016-08-26-270-Closest-Binary-Search-Tree-Value/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="270-closest-binary-search-tree-value">
       <a href="solution-270.html">
        270. Closest Binary Search Tree Value
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given the
       <code>
        root
       </code>
       of a binary search tree and a
       <code>
        target
       </code>
       value, return
       <em>
        the value in the BST that is closest to the
       </em>
       <code>
        target
       </code>
       . If there are multiple answers, print the smallest.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0270.Closest%20Binary%20Search%20Tree%20Value/images/closest1-1-tree.jpg" style="width: 292px; height: 302px;"/>
      </p>
      <pre>
<strong>Input:</strong> root = [4,2,5,1,3], target = 3.714286
<strong>Output:</strong> 4
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> root = [1], target = 4.428571
<strong>Output:</strong> 1
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the tree is in the range
        <code>
         [1, 10
         <sup>
          4
         </sup>
         ]
        </code>
        .
       </li>
       <li>
        <code>
         0 &lt;= Node.val &lt;= 10
         <sup>
          9
         </sup>
        </code>
       </li>
       <li>
        <code>
         -10
         <sup>
          9
         </sup>
         &lt;= target &lt;= 10
         <sup>
          9
         </sup>
        </code>
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       Binary search.
      </p>
      <p>
       Use the characteristics of the binary search tree (
       <code class="language-plaintext highlighter-rouge">
        left&lt;root&lt;right
       </code>
       ) to quickly locate, because the root node is an intermediate value,
      </p>
      <p>
       When we traverse down, we compare according to the relationship between the target value and the value of the root node.
      </p>
      <p>
       If the target value is less than the node value, we should find a smaller value, so we go to the left subtree to find, otherwise we go to the right subtree to find.
      </p>
      <ul class="uk-tab" data-uk-switcher="{connect:'#8da369d9-c0a8-4cb6-a28e-227a67fa38ba'}">
       <li class="uk-active">
        <a href="solution-270.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-270.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-270.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-270.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-270.html">
         Javascript
        </a>
       </li>
       <li>
        <a href="solution-270.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="8da369d9-c0a8-4cb6-a28e-227a67fa38ba">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">closestValue</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">double</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="kt">double</span> <span class="n">mi</span> <span class="o">=</span> <span class="nc">Double</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">double</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">-</span> <span class="n">target</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">mi</span> <span class="o">||</span> <span class="o">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">mi</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">ans</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">mi</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">closestValue</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">double</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">mi</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">double</span> <span class="n">t</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">-</span> <span class="n">target</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">mi</span> <span class="o">||</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">mi</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">ans</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">mi</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">closestValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="s">"""
    :type root: TreeNode
    :type target: float
    :rtype: int
    """</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span>
    <span class="k">while</span> <span class="n">p</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ans</span> <span class="o">-</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span>
      <span class="k">if</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">left</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">right</span>
    <span class="k">return</span> <span class="n">ans</span>


<span class="c1">############
</span>
<span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">closestValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">ans</span><span class="p">,</span> <span class="n">mi</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">inf</span>
        <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">-</span> <span class="n">target</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">mi</span><span class="p">:</span>
                <span class="n">mi</span> <span class="o">=</span> <span class="n">t</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span>
        <span class="k">return</span> <span class="n">ans</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */</span>
<span class="k">func</span> <span class="n">closestValue</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">,</span> <span class="n">target</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">ans</span> <span class="o">:=</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span>
	<span class="n">mi</span> <span class="o">:=</span> <span class="n">math</span><span class="o">.</span><span class="n">MaxFloat64</span>
	<span class="k">for</span> <span class="n">root</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">t</span> <span class="o">:=</span> <span class="n">math</span><span class="o">.</span><span class="n">Abs</span><span class="p">(</span><span class="kt">float64</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="p">)</span> <span class="o">-</span> <span class="n">target</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">mi</span> <span class="o">||</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">mi</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span> <span class="o">&lt;</span> <span class="n">ans</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mi</span> <span class="o">=</span> <span class="n">t</span>
			<span class="n">ans</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="kt">float64</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="p">{</span>
			<span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">Left</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">Right</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ans</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-js highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="cm">/**
 * @param {TreeNode} root
 * @param {number} target
 * @return {number}
 */</span>
<span class="kd">var</span> <span class="nx">closestValue</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">ans</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">val</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">mi</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">.</span><span class="nx">MAX_VALUE</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">t</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">val</span> <span class="o">-</span> <span class="nx">target</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">t</span> <span class="o">&lt;</span> <span class="nx">mi</span> <span class="o">||</span> <span class="p">(</span><span class="nx">t</span> <span class="o">===</span> <span class="nx">mi</span> <span class="o">&amp;&amp;</span> <span class="nx">root</span><span class="p">.</span><span class="nx">val</span> <span class="o">&lt;</span> <span class="nx">ans</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">mi</span> <span class="o">=</span> <span class="nx">t</span><span class="p">;</span>
            <span class="nx">ans</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">val</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">val</span> <span class="o">&gt;</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">root</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">root</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">ans</span><span class="p">;</span>
<span class="p">};</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>

<span class="kd">function</span> <span class="nx">closestValue</span><span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">target</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">diff</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">.</span><span class="nx">POSITIVE_INFINITY</span><span class="p">;</span>

    <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">node</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="k">void</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">const</span> <span class="nx">nxt</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">target</span> <span class="o">-</span> <span class="nx">node</span><span class="p">.</span><span class="nx">val</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">nxt</span> <span class="o">&lt;</span> <span class="nx">diff</span> <span class="o">||</span> <span class="p">(</span><span class="nx">nxt</span> <span class="o">===</span> <span class="nx">diff</span> <span class="o">&amp;&amp;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">val</span> <span class="o">&lt;</span> <span class="nx">ans</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">diff</span> <span class="o">=</span> <span class="nx">nxt</span><span class="p">;</span>
            <span class="nx">ans</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">val</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nx">node</span> <span class="o">=</span> <span class="nx">target</span> <span class="o">&lt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">val</span> <span class="p">?</span> <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="p">:</span> <span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">;</span>
        <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">ans</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-270.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
