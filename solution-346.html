<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-346.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-346.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>346 - Moving Average from Data Stream</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 346. Moving Average from Data Stream Description Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window. Implement the&amp;nbsp;MovingAverage class: MovingAverage(int size) Initializes&amp;nbsp;the object with the size of the window size. double next(int val) Returns...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-346.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-346.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-346.html" rel="stylesheet"/>
   <link href="solution-346.html" rel="stylesheet"/>
   <link href="solution-346.html" rel="stylesheet"/>
   <link href="solution-346.html" rel="stylesheet"/>
   <link href="solution-346.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="346 - Moving Average from Data Stream" property="og:title"/>
   <meta content="Leetcode 346. Moving Average from Data Stream Description Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window. Implement the&amp;nbsp;MovingAverage class: MovingAverage(int size) Initializes&amp;nbsp;the object with the size of the window size. double next(int val) Returns the moving average of the last size values of the stream. &amp;nbsp; Example 1: Input [&amp;quot;MovingAverage&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;next&amp;quot;] [[3], [1], [10], [3], [5]] Output [null, 1.0, 5.5, 4.66667, 6.0] Explanation MovingAverage movingAverage = new MovingAverage(3); movingAverage.next(1); // return 1.0 = 1 / 1 movingAverage.next(10); // return 5.5 = (1 + 10) / 2 movingAverage.next(3); // return 4.66667 = (1 + 10 + 3) / 3 movingAverage.next(5); // return 6.0 = (10 + 3 + 5) / 3 &amp;nbsp; Constraints: 1 &amp;lt;= size &amp;lt;= 1000 -105 &amp;lt;= val &amp;lt;= 105 At most 104 calls will be made to next. Solutions This solution implements a moving average data structure that supports a method next(val) where val is an integer representing the next number in the data stream. Class Initialization: __init__(self, size: int) self.arr: Initializes an array of length size filled with zeros. This array serves as a circular buffer to hold the last N values inserted, where N is the specified size. self.s: Initializes the sum of numbers currently in the circular buffer to 0. This sum is used to efficiently compute the moving average. self.cnt: A counter to keep track of the total number of values that have been inserted so far. It helps in managing the circular nature of self.arr and calculating the average correctly during the initial phase when the buffer is not yet full. Method: next(self, val: int) -&amp;gt; float Circular Array Indexing: idx = self.cnt % len(self.arr) calculates the index at which the new value should be inserted. This calculation ensures that the array is used as a circular buffer, overwriting the oldest data points with new ones once the buffer size (size) is exceeded. Updating Sum: The new value val is added to self.s, and the value being overwritten in self.arr is subtracted from self.s. This keeps self.s as the sum of all numbers currently in the buffer. Inserting New Value: The new value val is stored in the array at the calculated index idx. Incrementing Counter: The counter self.cnt is incremented by 1 to reflect the insertion of a new data point. Calculating and Returning Moving Average: The method returns the moving average of the last N values. It divides self.s by min(self.cnt, len(self.arr)) to ensure the correct average is calculated: During the initial phase (when fewer than N values have been inserted), it divides by self.cnt to average only the values that have been inserted. Once the buffer is full (self.cnt &amp;gt;= N), it divides by len(self.arr) (N) to calculate the average of the last N values. Java C++ Python Go class MovingAverage { private int[] arr; private int s; private int cnt; public MovingAverage(int size) { arr = new int[size]; }..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2016-11-10T00:00:00-08:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2016-11-10-346-Moving-Average-from-Data-Stream/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-346.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="346 - Moving Average from Data Stream" property="twitter:title"/>
   <meta content="Leetcode 346. Moving Average from Data Stream Description Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window. Implement the&amp;nbsp;MovingAverage class: MovingAverage(int size) Initializes&amp;nbsp;the object with the size of the window size. double next(int val) Returns the moving average of the last size values of the stream. &amp;nbsp; Example 1: Input [&amp;quot;MovingAverage&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;next&amp;quot;] [[3], [1], [10], [3], [5]] Output [null, 1.0, 5.5, 4.66667, 6.0] Explanation MovingAverage movingAverage = new MovingAverage(3); movingAverage.next(1); // return 1.0 = 1 / 1 movingAverage.next(10); // return 5.5 = (1 + 10) / 2 movingAverage.next(3); // return 4.66667 = (1 + 10 + 3) / 3 movingAverage.next(5); // return 6.0 = (10 + 3 + 5) / 3 &amp;nbsp; Constraints: 1 &amp;lt;= size &amp;lt;= 1000 -105 &amp;lt;= val &amp;lt;= 105 At most 104 calls will be made to next. Solutions This solution implements a moving average data structure that supports a method next(val) where val is an integer representing the next number in the data stream. Class Initialization: __init__(self, size: int) self.arr: Initializes an array of length size filled with zeros. This array serves as a circular buffer to hold the last N values inserted, where N is the specified size. self.s: Initializes the sum of numbers currently in the circular buffer to 0. This sum is used to efficiently compute the moving average. self.cnt: A counter to keep track of the total number of values that have been inserted so far. It helps in managing the circular nature of self.arr and calculating the average correctly during the initial phase when the buffer is not yet full. Method: next(self, val: int) -&amp;gt; float Circular Array Indexing: idx = self.cnt % len(self.arr) calculates the index at which the new value should be inserted. This calculation ensures that the array is used as a circular buffer, overwriting the oldest data points with new ones once the buffer size (size) is exceeded. Updating Sum: The new value val is added to self.s, and the value being overwritten in self.arr is subtracted from self.s. This keeps self.s as the sum of all numbers currently in the buffer. Inserting New Value: The new value val is stored in the array at the calculated index idx. Incrementing Counter: The counter self.cnt is incremented by 1 to reflect the insertion of a new data point. Calculating and Returning Moving Average: The method returns the moving average of the last N values. It divides self.s by min(self.cnt, len(self.arr)) to ensure the correct average is calculated: During the initial phase (when fewer than N values have been inserted), it divides by self.cnt to average only the values that have been inserted. Once the buffer is full (self.cnt &amp;gt;= N), it divides by len(self.arr) (N) to calculate the average of the last N values. Java C++ Python Go class MovingAverage { private int[] arr; private int s; private int cnt; public MovingAverage(int size) { arr = new int[size]; }..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    346 - Moving Average from Data Stream | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="346 - Moving Average from Data Stream" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-346.html" rel="canonical">
          <meta content="https://leetcode.ca/2016-11-10-346-Moving-Average-from-Data-Stream/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2016-11-10T00:00:00-08:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"346 - Moving Average from Data Stream","dateModified":"2016-11-10T00:00:00-08:00","datePublished":"2016-11-10T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2016-11-10-346-Moving-Average-from-Data-Stream/"},"url":"https://leetcode.ca/2016-11-10-346-Moving-Average-from-Data-Stream/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="346-moving-average-from-data-stream">
       <a href="solution-346.html">
        346. Moving Average from Data Stream
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.
      </p>
      <p>
       Implement the
       <code>
        MovingAverage
       </code>
       class:
      </p>
      <ul>
       <li>
        <code>
         MovingAverage(int size)
        </code>
        Initializes the object with the size of the window
        <code>
         size
        </code>
        .
       </li>
       <li>
        <code>
         double next(int val)
        </code>
        Returns the moving average of the last
        <code>
         size
        </code>
        values of the stream.
       </li>
      </ul>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <pre>
<strong>Input</strong>
["MovingAverage", "next", "next", "next", "next"]
[[3], [1], [10], [3], [5]]
<strong>Output</strong>
[null, 1.0, 5.5, 4.66667, 6.0]

<strong>Explanation</strong>
MovingAverage movingAverage = new MovingAverage(3);
movingAverage.next(1); // return 1.0 = 1 / 1
movingAverage.next(10); // return 5.5 = (1 + 10) / 2
movingAverage.next(3); // return 4.66667 = (1 + 10 + 3) / 3
movingAverage.next(5); // return 6.0 = (10 + 3 + 5) / 3
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        <code>
         1 &lt;= size &lt;= 1000
        </code>
       </li>
       <li>
        <code>
         -10
         <sup>
          5
         </sup>
         &lt;= val &lt;= 10
         <sup>
          5
         </sup>
        </code>
       </li>
       <li>
        At most
        <code>
         10
         <sup>
          4
         </sup>
        </code>
        calls will be made to
        <code>
         next
        </code>
        .
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <p>
       This solution implements a moving average data structure that supports a method
       <code class="language-plaintext highlighter-rouge">
        next(val)
       </code>
       where
       <code class="language-plaintext highlighter-rouge">
        val
       </code>
       is an integer representing the next number in the data stream.
      </p>
      <h3 id="class-initialization-__init__self-size-int">
       Class Initialization:
       <code class="language-plaintext highlighter-rouge">
        __init__(self, size: int)
       </code>
      </h3>
      <ul>
       <li>
        <code class="language-plaintext highlighter-rouge">
         self.arr
        </code>
        : Initializes an array of length
        <code class="language-plaintext highlighter-rouge">
         size
        </code>
        filled with zeros. This array serves as a circular buffer to hold the last
        <code class="language-plaintext highlighter-rouge">
         N
        </code>
        values inserted, where
        <code class="language-plaintext highlighter-rouge">
         N
        </code>
        is the specified
        <code class="language-plaintext highlighter-rouge">
         size
        </code>
        .
       </li>
       <li>
        <code class="language-plaintext highlighter-rouge">
         self.s
        </code>
        : Initializes the sum of numbers currently in the circular buffer to
        <code class="language-plaintext highlighter-rouge">
         0
        </code>
        . This sum is used to efficiently compute the moving average.
       </li>
       <li>
        <code class="language-plaintext highlighter-rouge">
         self.cnt
        </code>
        : A counter to keep track of the total number of values that have been inserted so far. It helps in managing the circular nature of
        <code class="language-plaintext highlighter-rouge">
         self.arr
        </code>
        and calculating the average correctly during the initial phase when the buffer is not yet full.
       </li>
      </ul>
      <h3 id="method-nextself-val-int---float">
       Method:
       <code class="language-plaintext highlighter-rouge">
        next(self, val: int) -&gt; float
       </code>
      </h3>
      <ul>
       <li>
        <strong>
         Circular Array Indexing
        </strong>
        :
        <code class="language-plaintext highlighter-rouge">
         idx = self.cnt % len(self.arr)
        </code>
        calculates the index at which the new value should be inserted. This calculation ensures that the array is used as a circular buffer, overwriting the oldest data points with new ones once the buffer size (
        <code class="language-plaintext highlighter-rouge">
         size
        </code>
        ) is exceeded.
       </li>
       <li>
        <strong>
         Updating Sum
        </strong>
        : The new value
        <code class="language-plaintext highlighter-rouge">
         val
        </code>
        is added to
        <code class="language-plaintext highlighter-rouge">
         self.s
        </code>
        , and the value being overwritten in
        <code class="language-plaintext highlighter-rouge">
         self.arr
        </code>
        is subtracted from
        <code class="language-plaintext highlighter-rouge">
         self.s
        </code>
        . This keeps
        <code class="language-plaintext highlighter-rouge">
         self.s
        </code>
        as the sum of all numbers currently in the buffer.
       </li>
       <li>
        <strong>
         Inserting New Value
        </strong>
        : The new value
        <code class="language-plaintext highlighter-rouge">
         val
        </code>
        is stored in the array at the calculated index
        <code class="language-plaintext highlighter-rouge">
         idx
        </code>
        .
       </li>
       <li>
        <strong>
         Incrementing Counter
        </strong>
        : The counter
        <code class="language-plaintext highlighter-rouge">
         self.cnt
        </code>
        is incremented by
        <code class="language-plaintext highlighter-rouge">
         1
        </code>
        to reflect the insertion of a new data point.
       </li>
       <li>
        <strong>
         Calculating and Returning Moving Average
        </strong>
        : The method returns the moving average of the last
        <code class="language-plaintext highlighter-rouge">
         N
        </code>
        values. It divides
        <code class="language-plaintext highlighter-rouge">
         self.s
        </code>
        by
        <code class="language-plaintext highlighter-rouge">
         min(self.cnt, len(self.arr))
        </code>
        to ensure the correct average is calculated:
        <ul>
         <li>
          During the initial phase (when fewer than
          <code class="language-plaintext highlighter-rouge">
           N
          </code>
          values have been inserted), it divides by
          <code class="language-plaintext highlighter-rouge">
           self.cnt
          </code>
          to average only the values that have been inserted.
         </li>
         <li>
          Once the buffer is full (
          <code class="language-plaintext highlighter-rouge">
           self.cnt &gt;= N
          </code>
          ), it divides by
          <code class="language-plaintext highlighter-rouge">
           len(self.arr)
          </code>
          (
          <code class="language-plaintext highlighter-rouge">
           N
          </code>
          ) to calculate the average of the last
          <code class="language-plaintext highlighter-rouge">
           N
          </code>
          values.
         </li>
        </ul>
       </li>
      </ul>
      <ul class="uk-tab" data-uk-switcher="{connect:'#68782dd0-318d-499e-b0b0-7974b950e923'}">
       <li class="uk-active">
        <a href="solution-346.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-346.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-346.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-346.html">
         Go
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="68782dd0-318d-499e-b0b0-7974b950e923">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="kd">class</span> <span class="nc">MovingAverage</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">s</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">cnt</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MovingAverage</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">next</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">%</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">val</span> <span class="o">-</span> <span class="n">arr</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
        <span class="o">++</span><span class="n">cnt</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">cnt</span><span class="o">,</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Your MovingAverage object will be instantiated and called as such:
 * MovingAverage obj = new MovingAverage(size);
 * double param_1 = obj.next(val);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">MovingAverage</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MovingAverage</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">arr</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">double</span> <span class="n">next</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">%</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">val</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
        <span class="o">++</span><span class="n">cnt</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="n">s</span> <span class="o">/</span> <span class="n">min</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**
 * Your MovingAverage object will be instantiated and called as such:
 * MovingAverage* obj = new MovingAverage(size);
 * double param_1 = obj-&gt;next(val);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">class</span> <span class="nc">MovingAverage</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">size</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">cnt</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">arr</span><span class="p">)</span> <span class="c1"># circular array
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">s</span> <span class="o">+=</span> <span class="n">val</span> <span class="o">-</span> <span class="bp">self</span><span class="p">.</span><span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">s</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">cnt</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">arr</span><span class="p">))</span>


<span class="c1"># Your MovingAverage object will be instantiated and called as such:
# obj = MovingAverage(size)
# param_1 = obj.next(val)
</span>
<span class="c1">############
</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="c1"># with no sum variable, calculate on the fly
</span><span class="k">class</span> <span class="nc">MovingAverage</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">avg</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">size</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">avg</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">avg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="n">minus</span> <span class="o">=</span> <span class="n">head</span> <span class="o">/</span> <span class="bp">self</span><span class="p">.</span><span class="n">size</span>
            <span class="n">add</span> <span class="o">=</span> <span class="n">val</span> <span class="o">/</span> <span class="bp">self</span><span class="p">.</span><span class="n">size</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">avg</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">avg</span> <span class="o">+</span> <span class="n">add</span> <span class="o">-</span> <span class="n">minus</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">avg</span>

<span class="c1">############
</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">MovingAverage</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
    <span class="s">"""
    Initialize your data structure here.
    :type size: int
    """</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">windowSize</span> <span class="o">=</span> <span class="n">size</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">windowSum</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([])</span>

  <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="s">"""
    :type val: int
    :rtype: float
    """</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">windowSum</span> <span class="o">+=</span> <span class="n">val</span>
    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">data</span>

    <span class="n">leftTop</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="p">.</span><span class="n">windowSize</span><span class="p">:</span>
      <span class="n">leftTop</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
    <span class="n">data</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="bp">self</span><span class="p">.</span><span class="n">windowSum</span> <span class="o">-=</span> <span class="n">leftTop</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">windowSize</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">windowSum</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">windowSum</span> <span class="o">/</span> <span class="bp">self</span><span class="p">.</span><span class="n">windowSize</span>

<span class="c1"># Your MovingAverage object will be instantiated and called as such:
# obj = MovingAverage(size)
# param_1 = obj.next(val)
</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="k">type</span> <span class="n">MovingAverage</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">arr</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="n">cnt</span> <span class="kt">int</span>
	<span class="n">s</span>   <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Constructor</span><span class="p">(</span><span class="n">size</span> <span class="kt">int</span><span class="p">)</span> <span class="n">MovingAverage</span> <span class="p">{</span>
	<span class="n">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">MovingAverage</span><span class="p">{</span><span class="n">arr</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">MovingAverage</span><span class="p">)</span> <span class="n">Next</span><span class="p">(</span><span class="n">val</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="n">idx</span> <span class="o">:=</span> <span class="n">this</span><span class="o">.</span><span class="n">cnt</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">arr</span><span class="p">)</span>
	<span class="n">this</span><span class="o">.</span><span class="n">s</span> <span class="o">+=</span> <span class="n">val</span> <span class="o">-</span> <span class="n">this</span><span class="o">.</span><span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
	<span class="n">this</span><span class="o">.</span><span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
	<span class="n">this</span><span class="o">.</span><span class="n">cnt</span><span class="o">++</span>
	<span class="k">return</span> <span class="kt">float64</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="kt">float64</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">cnt</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">arr</span><span class="p">)))</span>
<span class="p">}</span>

<span class="c">/**
 * Your MovingAverage object will be instantiated and called as such:
 * obj := Constructor(size);
 * param_1 := obj.Next(val);
 */</span>
</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-346.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
