<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
  <link href="solution-2313.html" rel="shortcut icon" type="image/png"/>
  <link href="solution-2313.html" rel="stylesheet">
   <script src="assets_js_uikit.min.js" type="text/javascript">
   </script>
   <script src="assets_js_uikit-icons.min.js" type="text/javascript">
   </script>
   <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        packages: {'[+]': ['ams']}  // Include the 'ams' package
      },
      svg: {
        fontCache: 'global'
      }
    };
   </script>
   <script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
   </script>
   <!-- below block is overlapping with SEO plugin generated title and description   -->
   <!-- 
  <title>2313 - Minimum Flips in Binary Tree to Get Result</title>

  
  <meta name="author" content="Leetcode">
  

  
  <meta name="description" content="Leetcode 2313. Minimum Flips in Binary Tree to Get Result Description You are given the root of a binary tree with the following properties: Leaf nodes have either the value 0 or 1, representing false and true respectively. Non-leaf nodes have either the value 2, 3,...">
   -->
   <meta content="LeetCode, Solution, Company Tag, Unlock Prime, Java, C++, Interview, Job, Algorithm, SQL, Canada" name="keywords"/>
   <link href="solution-2313.html" rel="alternate" title="Leetcode" type="application/rss+xml"/>
   <!-- Global site tag (gtag.js) - Google Analytics -->
   <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K108N8L891">
   </script>
   <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K108N8L891');
   </script>
   <!-- End Google Analytics -->
   <script async="" data-ad-client="ca-pub-6766885420008650" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
   </script>
   <link crossorigin="anonymous" href="solution-2313.html" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" rel="stylesheet"/>
   <link href="solution-2313.html" rel="stylesheet"/>
   <link href="solution-2313.html" rel="stylesheet"/>
   <link href="solution-2313.html" rel="stylesheet"/>
   <link href="solution-2313.html" rel="stylesheet"/>
   <link href="solution-2313.html" rel="stylesheet"/>
   <meta content="Leetcode" property="og:site_name"/>
   <meta content="2313 - Minimum Flips in Binary Tree to Get Result" property="og:title"/>
   <meta content="Leetcode 2313. Minimum Flips in Binary Tree to Get Result Description You are given the root of a binary tree with the following properties: Leaf nodes have either the value 0 or 1, representing false and true respectively. Non-leaf nodes have either the value 2, 3, 4, or 5, representing the boolean operations OR, AND, XOR, and NOT, respectively. You are also given a boolean result, which is the desired result of the evaluation of the root node. The evaluation of a node is as follows: If the node is a leaf node, the evaluation is the value of the node, i.e. true or false. Otherwise, evaluate the node&amp;#39;s children and apply the boolean operation of its value with the children&amp;#39;s evaluations. In one operation, you can flip a leaf node, which causes a false node to become true, and a true node to become false. Return the minimum number of operations that need to be performed such that the evaluation of root yields result. It can be shown that there is always a way to achieve result. A leaf node is a node that has zero children. Note: NOT nodes have either a left child or a right child, but other non-leaf nodes have both a left child and a right child. &amp;nbsp; Example 1: Input: root = [3,5,4,2,null,1,1,1,0], result = true Output: 2 Explanation: It can be shown that a minimum of 2 nodes have to be flipped to make the root of the tree evaluate to true. One way to achieve this is shown in the diagram above. Example 2: Input: root = [0], result = false Output: 0 Explanation: The root of the tree already evaluates to false, so 0 nodes have to be flipped. &amp;nbsp; Constraints: The number of nodes in the tree is in the range [1, 105]. 0 &amp;lt;= Node.val &amp;lt;= 5 OR, AND, and XOR nodes have 2 children. NOT nodes have 1 child. Leaf nodes have a value of 0 or 1. Non-leaf nodes have a value of 2, 3, 4, or 5. Solutions Java C++ Python Go TypeScript /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int minimumFlips(TreeNode root, boolean result) { return dfs(root)[result ? 1 : 0]; } private int[] dfs(TreeNode root) { if (root == null) { return new int[] {1 &amp;lt;&amp;lt; 30, 1 &amp;lt;&amp;lt; 30}; } int x = root.val; if (x &amp;lt; 2) { return new int[] {x, x ^ 1}; } var l = dfs(root.left); var r = dfs(root.right); int a = 0, b = 0; if (x == 2) { a = l[0] + r[0]; b = Math.min(l[0] + r[1], Math.min(l[1] + r[0], l[1] + r[1]));..." property="og:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" property="og:image"/>
   <!-- remove canonical below to use SEO plugin -->
   <meta content="article" property="og:type"/>
   <meta content="Leetcode" property="og:article:author"/>
   <meta content="2022-03-31T00:00:00-07:00" property="og:article:published_time"/>
   <meta content="https://leetcode.ca/2022-03-31-2313-Minimum-Flips-in-Binary-Tree-to-Get-Result/" property="og:url"/>
   <!-- <link rel="canonical" href="solution-2313.html"> -->
   <meta content="summary" name="twitter:card"/>
   <meta content="@" name="twitter:site"/>
   <meta content="@" name="twitter:creator"/>
   <meta content="2313 - Minimum Flips in Binary Tree to Get Result" property="twitter:title"/>
   <meta content="Leetcode 2313. Minimum Flips in Binary Tree to Get Result Description You are given the root of a binary tree with the following properties: Leaf nodes have either the value 0 or 1, representing false and true respectively. Non-leaf nodes have either the value 2, 3, 4, or 5, representing the boolean operations OR, AND, XOR, and NOT, respectively. You are also given a boolean result, which is the desired result of the evaluation of the root node. The evaluation of a node is as follows: If the node is a leaf node, the evaluation is the value of the node, i.e. true or false. Otherwise, evaluate the node&amp;#39;s children and apply the boolean operation of its value with the children&amp;#39;s evaluations. In one operation, you can flip a leaf node, which causes a false node to become true, and a true node to become false. Return the minimum number of operations that need to be performed such that the evaluation of root yields result. It can be shown that there is always a way to achieve result. A leaf node is a node that has zero children. Note: NOT nodes have either a left child or a right child, but other non-leaf nodes have both a left child and a right child. &amp;nbsp; Example 1: Input: root = [3,5,4,2,null,1,1,1,0], result = true Output: 2 Explanation: It can be shown that a minimum of 2 nodes have to be flipped to make the root of the tree evaluate to true. One way to achieve this is shown in the diagram above. Example 2: Input: root = [0], result = false Output: 0 Explanation: The root of the tree already evaluates to false, so 0 nodes have to be flipped. &amp;nbsp; Constraints: The number of nodes in the tree is in the range [1, 105]. 0 &amp;lt;= Node.val &amp;lt;= 5 OR, AND, and XOR nodes have 2 children. NOT nodes have 1 child. Leaf nodes have a value of 0 or 1. Non-leaf nodes have a value of 2, 3, 4, or 5. Solutions Java C++ Python Go TypeScript /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int minimumFlips(TreeNode root, boolean result) { return dfs(root)[result ? 1 : 0]; } private int[] dfs(TreeNode root) { if (root == null) { return new int[] {1 &amp;lt;&amp;lt; 30, 1 &amp;lt;&amp;lt; 30}; } int x = root.val; if (x &amp;lt; 2) { return new int[] {x, x ^ 1}; } var l = dfs(root.left); var r = dfs(root.right); int a = 0, b = 0; if (x == 2) { a = l[0] + r[0]; b = Math.min(l[0] + r[1], Math.min(l[1] + r[0], l[1] + r[1]));..." property="twitter:description"/>
   <meta content="https://leetcode.ca/assets/img/avatar-icon.jpg" name="twitter:image"/>
   <!-- Begin Jekyll SEO tag v2.6.1 -->
   <title>
    2313 - Minimum Flips in Binary Tree to Get Result | Leetcode
   </title>
   <meta content="Jekyll v3.10.0" name="generator">
    <meta content="2313 - Minimum Flips in Binary Tree to Get Result" property="og:title">
     <meta content="Leetcode" name="author">
      <meta content="en_US" property="og:locale">
       <meta content="Leetcode" name="description">
        <meta content="Leetcode" property="og:description">
         <link href="solution-2313.html" rel="canonical">
          <meta content="https://leetcode.ca/2022-03-31-2313-Minimum-Flips-in-Binary-Tree-to-Get-Result/" property="og:url">
           <meta content="Leetcode" property="og:site_name">
            <meta content="article" property="og:type">
             <meta content="2022-03-31T00:00:00-07:00" property="article:published_time">
              <script type="application/ld+json">
               {"description":"Leetcode","headline":"2313 - Minimum Flips in Binary Tree to Get Result","dateModified":"2022-03-31T00:00:00-07:00","datePublished":"2022-03-31T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leetcode.ca/2022-03-31-2313-Minimum-Flips-in-Binary-Tree-to-Get-Result/"},"url":"https://leetcode.ca/2022-03-31-2313-Minimum-Flips-in-Binary-Tree-to-Get-Result/","author":{"@type":"Person","name":"Leetcode"},"@type":"BlogPosting","@context":"https://schema.org"}
              </script>
              <!-- End Jekyll SEO tag -->
             </meta>
            </meta>
           </meta>
          </meta>
         </link>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </link>
 </head>
 <body>
  
  <!-- TODO this file has become a mess, refactor it -->
  
  <div class="container-md">
   <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
     <article class="blog-post" role="main">
      
      <script src="https://apis.google.com/js/platform.js">
      </script>
      <div class="g-ytsubscribe" data-channelid="UCslk3mmaMJy1enit3L9vWig" data-count="hidden" data-layout="full">
      </div>
      <h1 id="2313-minimum-flips-in-binary-tree-to-get-result">
       <a href="solution-2313.html">
        2313. Minimum Flips in Binary Tree to Get Result
       </a>
      </h1>
      <h2 id="description">
       Description
      </h2>
      <p>
       You are given the
       <code>
        root
       </code>
       of a
       <strong>
        binary tree
       </strong>
       with the following properties:
      </p>
      <ul>
       <li>
        <strong>
         Leaf nodes
        </strong>
        have either the value
        <code>
         0
        </code>
        or
        <code>
         1
        </code>
        , representing
        <code>
         false
        </code>
        and
        <code>
         true
        </code>
        respectively.
       </li>
       <li>
        <strong>
         Non-leaf nodes
        </strong>
        have either the value
        <code>
         2
        </code>
        ,
        <code>
         3
        </code>
        ,
        <code>
         4
        </code>
        , or
        <code>
         5
        </code>
        , representing the boolean operations
        <code>
         OR
        </code>
        ,
        <code>
         AND
        </code>
        ,
        <code>
         XOR
        </code>
        , and
        <code>
         NOT
        </code>
        , respectively.
       </li>
      </ul>
      <p>
       You are also given a boolean
       <code>
        result
       </code>
       , which is the desired result of the
       <strong>
        evaluation
       </strong>
       of the
       <code>
        root
       </code>
       node.
      </p>
      <p>
       The evaluation of a node is as follows:
      </p>
      <ul>
       <li>
        If the node is a leaf node, the evaluation is the
        <strong>
         value
        </strong>
        of the node, i.e.
        <code>
         true
        </code>
        or
        <code>
         false
        </code>
        .
       </li>
       <li>
        Otherwise,
        <strong>
         evaluate
        </strong>
        the node's children and
        <strong>
         apply
        </strong>
        the boolean operation of its value with the children's evaluations.
       </li>
      </ul>
      <p>
       In one operation, you can
       <strong>
        flip
       </strong>
       a leaf node, which causes a
       <code>
        false
       </code>
       node to become
       <code>
        true
       </code>
       , and a
       <code>
        true
       </code>
       node to become
       <code>
        false
       </code>
       .
      </p>
      <p>
       Return
       <em>
        the minimum number of operations that need to be performed such that the evaluation of
       </em>
       <code>
        root
       </code>
       <em>
        yields
       </em>
       <code>
        result
       </code>
       . It can be shown that there is always a way to achieve
       <code>
        result
       </code>
       .
      </p>
      <p>
       A
       <strong>
        leaf node
       </strong>
       is a node that has zero children.
      </p>
      <p>
       Note:
       <code>
        NOT
       </code>
       nodes have either a left child or a right child, but other non-leaf nodes have both a left child and a right child.
      </p>
      <p>
      </p>
      <p>
       <strong class="example">
        Example 1:
       </strong>
      </p>
      <p>
       <img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2300-2399/2313.Minimum%20Flips%20in%20Binary%20Tree%20to%20Get%20Result/images/operationstree.png" style="width: 500px; height: 179px;"/>
      </p>
      <pre>
<strong>Input:</strong> root = [3,5,4,2,null,1,1,1,0], result = true
<strong>Output:</strong> 2
<strong>Explanation:</strong>
It can be shown that a minimum of 2 nodes have to be flipped to make the root of the tree
evaluate to true. One way to achieve this is shown in the diagram above.
</pre>
      <p>
       <strong class="example">
        Example 2:
       </strong>
      </p>
      <pre>
<strong>Input:</strong> root = [0], result = false
<strong>Output:</strong> 0
<strong>Explanation:</strong>
The root of the tree already evaluates to false, so 0 nodes have to be flipped.
</pre>
      <p>
      </p>
      <p>
       <strong>
        Constraints:
       </strong>
      </p>
      <ul>
       <li>
        The number of nodes in the tree is in the range
        <code>
         [1, 10
         <sup>
          5
         </sup>
         ]
        </code>
        .
       </li>
       <li>
        <code>
         0 &lt;= Node.val &lt;= 5
        </code>
       </li>
       <li>
        <code>
         OR
        </code>
        ,
        <code>
         AND
        </code>
        , and
        <code>
         XOR
        </code>
        nodes have
        <code>
         2
        </code>
        children.
       </li>
       <li>
        <code>
         NOT
        </code>
        nodes have
        <code>
         1
        </code>
        child.
       </li>
       <li>
        Leaf nodes have a value of
        <code>
         0
        </code>
        or
        <code>
         1
        </code>
        .
       </li>
       <li>
        Non-leaf nodes have a value of
        <code>
         2
        </code>
        ,
        <code>
         3
        </code>
        ,
        <code>
         4
        </code>
        , or
        <code>
         5
        </code>
        .
       </li>
      </ul>
      <h2 id="solutions">
       Solutions
      </h2>
      <ul class="uk-tab" data-uk-switcher="{connect:'#3eed9019-6aa3-41de-a988-8956f6bcc95e'}">
       <li class="uk-active">
        <a href="solution-2313.html">
         Java
        </a>
       </li>
       <li>
        <a href="solution-2313.html">
         C++
        </a>
       </li>
       <li>
        <a href="solution-2313.html">
         Python
        </a>
       </li>
       <li>
        <a href="solution-2313.html">
         Go
        </a>
       </li>
       <li>
        <a href="solution-2313.html">
         TypeScript
        </a>
       </li>
      </ul>
      <ul class="uk-switcher uk-margin" id="3eed9019-6aa3-41de-a988-8956f6bcc95e">
       <li>
        <div class="language-java highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minimumFlips</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">)[</span><span class="n">result</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="o">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="o">};</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="o">^</span> <span class="mi">1</span><span class="o">};</span>
        <span class="o">}</span>
        <span class="kt">var</span> <span class="n">l</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="kt">var</span> <span class="n">r</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">l</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">r</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="n">b</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">l</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">r</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">l</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">r</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">l</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">r</span><span class="o">[</span><span class="mi">1</span><span class="o">]));</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">a</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">l</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">r</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">l</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">r</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">l</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">r</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">l</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">r</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">4</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">a</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">l</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">r</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">l</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">r</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
            <span class="n">b</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">l</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">r</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">l</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">r</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">a</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">l</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">r</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
            <span class="n">b</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">l</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">r</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-cpp highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">minimumFlips</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="p">{</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">};</span>
            <span class="p">}</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">^</span> <span class="mi">1</span><span class="p">};</span>
            <span class="p">}</span>
            <span class="k">auto</span> <span class="p">[</span><span class="n">l0</span><span class="p">,</span> <span class="n">l1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="k">auto</span> <span class="p">[</span><span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">l0</span> <span class="o">+</span> <span class="n">r0</span><span class="p">;</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">min</span><span class="p">({</span><span class="n">l0</span> <span class="o">+</span> <span class="n">r1</span><span class="p">,</span> <span class="n">l1</span> <span class="o">+</span> <span class="n">r0</span><span class="p">,</span> <span class="n">l1</span> <span class="o">+</span> <span class="n">r1</span><span class="p">});</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">min</span><span class="p">({</span><span class="n">l0</span> <span class="o">+</span> <span class="n">r0</span><span class="p">,</span> <span class="n">l0</span> <span class="o">+</span> <span class="n">r1</span><span class="p">,</span> <span class="n">l1</span> <span class="o">+</span> <span class="n">r0</span><span class="p">});</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">l1</span> <span class="o">+</span> <span class="n">r1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">l0</span> <span class="o">+</span> <span class="n">r0</span><span class="p">,</span> <span class="n">l1</span> <span class="o">+</span> <span class="n">r1</span><span class="p">);</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">l0</span> <span class="o">+</span> <span class="n">r1</span><span class="p">,</span> <span class="n">l1</span> <span class="o">+</span> <span class="n">r0</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">r1</span><span class="p">);</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">l0</span><span class="p">,</span> <span class="n">r0</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">};</span>
        <span class="p">};</span>
        <span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span> <span class="o">?</span> <span class="n">b</span> <span class="o">:</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-py highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minimumFlips</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">result</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">inf</span><span class="p">,</span> <span class="n">inf</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">^</span> <span class="mi">1</span>
            <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">),</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="nb">int</span><span class="p">(</span><span class="n">result</span><span class="p">)]</span>

</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-go highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="c">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */</span>
<span class="k">func</span> <span class="n">minimumFlips</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">,</span> <span class="n">result</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">dfs</span> <span class="k">func</span><span class="p">(</span><span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>
	<span class="n">dfs</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="m">1</span> <span class="o">&lt;&lt;</span> <span class="m">30</span><span class="p">,</span> <span class="m">1</span> <span class="o">&lt;&lt;</span> <span class="m">30</span>
		<span class="p">}</span>
		<span class="n">x</span> <span class="o">:=</span> <span class="n">root</span><span class="o">.</span><span class="n">Val</span>
		<span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="m">2</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">^</span> <span class="m">1</span>
		<span class="p">}</span>
		<span class="n">l0</span><span class="p">,</span> <span class="n">l1</span> <span class="o">:=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="p">)</span>
		<span class="n">r0</span><span class="p">,</span> <span class="n">r1</span> <span class="o">:=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="p">)</span>
		<span class="k">var</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span>
		<span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="m">2</span> <span class="p">{</span>
			<span class="n">a</span> <span class="o">=</span> <span class="n">l0</span> <span class="o">+</span> <span class="n">r0</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">l0</span><span class="o">+</span><span class="n">r1</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">l1</span><span class="o">+</span><span class="n">r0</span><span class="p">,</span> <span class="n">l1</span><span class="o">+</span><span class="n">r1</span><span class="p">))</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="m">3</span> <span class="p">{</span>
			<span class="n">a</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">l0</span><span class="o">+</span><span class="n">r0</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">l0</span><span class="o">+</span><span class="n">r1</span><span class="p">,</span> <span class="n">l1</span><span class="o">+</span><span class="n">r0</span><span class="p">))</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">l1</span> <span class="o">+</span> <span class="n">r1</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="m">4</span> <span class="p">{</span>
			<span class="n">a</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">l0</span><span class="o">+</span><span class="n">r0</span><span class="p">,</span> <span class="n">l1</span><span class="o">+</span><span class="n">r1</span><span class="p">)</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">l0</span><span class="o">+</span><span class="n">r1</span><span class="p">,</span> <span class="n">l1</span><span class="o">+</span><span class="n">r0</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">a</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">r1</span><span class="p">)</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">l0</span><span class="p">,</span> <span class="n">r0</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
	<span class="p">}</span>
	<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">result</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">b</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">a</span>
<span class="p">}</span>
</code></pre>
         </div>
        </div>
       </li>
       <li>
        <div class="language-ts highlighter-rouge">
         <div class="highlight">
          <pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>

<span class="kd">function</span> <span class="nx">minimumFlips</span><span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">result</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="nx">TreeNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">number</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">val</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">x</span> <span class="o">^</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="kd">const</span> <span class="p">[</span><span class="nx">l0</span><span class="p">,</span> <span class="nx">l1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
        <span class="kd">const</span> <span class="p">[</span><span class="nx">r0</span><span class="p">,</span> <span class="nx">r1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">[</span><span class="nx">l0</span> <span class="o">+</span> <span class="nx">r0</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">l0</span> <span class="o">+</span> <span class="nx">r1</span><span class="p">,</span> <span class="nx">l1</span> <span class="o">+</span> <span class="nx">r0</span><span class="p">,</span> <span class="nx">l1</span> <span class="o">+</span> <span class="nx">r1</span><span class="p">)];</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">l0</span> <span class="o">+</span> <span class="nx">r0</span><span class="p">,</span> <span class="nx">l0</span> <span class="o">+</span> <span class="nx">r1</span><span class="p">,</span> <span class="nx">l1</span> <span class="o">+</span> <span class="nx">r0</span><span class="p">),</span> <span class="nx">l1</span> <span class="o">+</span> <span class="nx">r1</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">l0</span> <span class="o">+</span> <span class="nx">r0</span><span class="p">,</span> <span class="nx">l1</span> <span class="o">+</span> <span class="nx">r1</span><span class="p">),</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">l0</span> <span class="o">+</span> <span class="nx">r1</span><span class="p">,</span> <span class="nx">l1</span> <span class="o">+</span> <span class="nx">r0</span><span class="p">)];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">l1</span><span class="p">,</span> <span class="nx">r1</span><span class="p">),</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">l0</span><span class="p">,</span> <span class="nx">r0</span><span class="p">)];</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">)[</span><span class="nx">result</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

</code></pre>
         </div>
        </div>
       </li>
      </ul>
      
     </article>
     
     
     <div class="disqus-comments">
      <div class="comments">
       <div id="disqus_thread">
       </div>
       <script type="text/javascript">
        var disqus_shortname = 'leetcodeca';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
       </script>
       <noscript>
        Please enable JavaScript to view the
        <a href="solution-2313.html">
         comments powered by Disqus.
        </a>
       </noscript>
      </div>
     </div>
    </div>
   </div>
  </div>
  
  <script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js">
  </script>
  <script crossorigin="anonymous" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js">
  </script>
  <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
  <script src="assets_js_beautifuljekyll.js">
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js">
  </script>
  <script src="assets_js_anchor-js-config.js">
  </script>
 </body>
</html>
